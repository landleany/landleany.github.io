<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="peer 启动后是如何获取 channel 中的 block ？首先，peer node start 时，会初始化 gossipService，我们可以通过 service.GetGossipService() 方法获取全局对象 gossipService。下面介绍下该对象的结构：    12345678910111213141516171819202122232425262728// 接口如下t">
<meta property="og:type" content="article">
<meta property="og:title" content="fabric-peer">
<meta property="og:url" content="http://yoursite.com/2018/06/07/fabric-peer/index.html">
<meta property="og:site_name" content="Drip">
<meta property="og:description" content="peer 启动后是如何获取 channel 中的 block ？首先，peer node start 时，会初始化 gossipService，我们可以通过 service.GetGossipService() 方法获取全局对象 gossipService。下面介绍下该对象的结构：    12345678910111213141516171819202122232425262728// 接口如下t">
<meta property="og:updated_time" content="2018-06-22T02:27:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fabric-peer">
<meta name="twitter:description" content="peer 启动后是如何获取 channel 中的 block ？首先，peer node start 时，会初始化 gossipService，我们可以通过 service.GetGossipService() 方法获取全局对象 gossipService。下面介绍下该对象的结构：    12345678910111213141516171819202122232425262728// 接口如下t">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>fabric-peer</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2018/06/22/network/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/05/03/fabric-policy/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2018/06/07/fabric-peer/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2018/06/07/fabric-peer/&text=fabric-peer"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2018/06/07/fabric-peer/&is_video=false&description=fabric-peer"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=fabric-peer&body=Check out this article: http://yoursite.com/2018/06/07/fabric-peer/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2018/06/07/fabric-peer/&name=fabric-peer&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#peer-启动后是如何获取-channel-中的-block-？"><span class="toc-number">1.</span> <span class="toc-text">peer 启动后是如何获取 channel 中的 block ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Merkle-tree"><span class="toc-number">2.</span> <span class="toc-text">Merkle tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vscc-校验交易过程"><span class="toc-number">3.</span> <span class="toc-text">vscc 校验交易过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#commit-block-过程"><span class="toc-number">4.</span> <span class="toc-text">commit block 过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gossip-协议介绍"><span class="toc-number">5.</span> <span class="toc-text">Gossip 协议介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fabric-中的-pull-based-gossip-实现"><span class="toc-number">6.</span> <span class="toc-text">Fabric 中的 pull-based gossip 实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-中私密数据的保护"><span class="toc-number">7.</span> <span class="toc-text">fabric 中私密数据的保护</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        fabric-peer
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Drip</span>
      </span>
      
    <div class="postdate">
        <time datetime="2018-06-07T05:30:30.000Z" itemprop="datePublished">2018-06-07</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="peer-启动后是如何获取-channel-中的-block-？"><a href="#peer-启动后是如何获取-channel-中的-block-？" class="headerlink" title="peer 启动后是如何获取 channel 中的 block ？"></a>peer 启动后是如何获取 channel 中的 block ？</h1><p>首先，<code>peer node start</code> 时，会初始化 <code>gossipService</code>，我们可以通过 <code>service.GetGossipService()</code> 方法获取全局对象 <code>gossipService</code>。下面介绍下该对象的结构：   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 接口如下</span></div><div class="line"><span class="keyword">type</span> GossipService <span class="keyword">interface</span> &#123;</div><div class="line">	gossip.Gossip</div><div class="line"></div><div class="line">	<span class="comment">// DistributePrivateData distributes private data to the peers in the collections</span></div><div class="line">	<span class="comment">// according to policies induced by the PolicyStore and PolicyParser</span></div><div class="line">	DistributePrivateData(chainID <span class="keyword">string</span>, txID <span class="keyword">string</span>, privateData *rwset.TxPvtReadWriteSet) error</div><div class="line">	<span class="comment">// NewConfigEventer creates a ConfigProcessor which the channelconfig.BundleSource can ultimately route config updates to</span></div><div class="line">	NewConfigEventer() ConfigProcessor</div><div class="line">	<span class="comment">// InitializeChannel allocates the state provider and should be invoked once per channel per execution</span></div><div class="line">	InitializeChannel(chainID <span class="keyword">string</span>, endpoints []<span class="keyword">string</span>, support Support) </div><div class="line">	<span class="comment">// AddPayload appends message payload to for given chain</span></div><div class="line">	AddPayload(chainID <span class="keyword">string</span>, payload *gproto.Payload) error</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现如下</span></div><div class="line"><span class="keyword">type</span> gossipServiceImpl <span class="keyword">struct</span> &#123;</div><div class="line">	gossipSvc</div><div class="line">	privateHandlers <span class="keyword">map</span>[<span class="keyword">string</span>]privateHandler</div><div class="line">	chains          <span class="keyword">map</span>[<span class="keyword">string</span>]state.GossipStateProvider</div><div class="line">	leaderElection  <span class="keyword">map</span>[<span class="keyword">string</span>]election.LeaderElectionService</div><div class="line">	deliveryService <span class="keyword">map</span>[<span class="keyword">string</span>]deliverclient.DeliverService</div><div class="line">	deliveryFactory DeliveryServiceFactory</div><div class="line">	lock            sync.RWMutex</div><div class="line">	mcs             api.MessageCryptoService</div><div class="line">	peerIdentity    []<span class="keyword">byte</span></div><div class="line">	secAdv          api.SecurityAdvisor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续，当我们调用 <code>peer channel join</code> 这条命令时，其实是调用了系统合约 <code>cscc (channel system chaincode)</code> 中的 <code>joinChannel</code> 方法，该方法会调用 <code>createChain</code> 方法，该方法在 gossipService 中初始化了一个通道对象，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">createChain</span><span class="params">(cid <span class="keyword">string</span>, ledger ledger.PeerLedger, cb *common.Block)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="comment">// 省略 ...</span></div><div class="line">    service.GetGossipService().InitializeChannel(bundle.ConfigtxValidator().ChainID(), ordererAddresses, service.Support&#123;</div><div class="line">        Validator: validator,</div><div class="line">        Committer: c,</div><div class="line">        Store:     store,</div><div class="line">        Cs:        simpleCollectionStore,</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 省略 ...</span></div></pre></td></tr></table></figure>
<p><code>gossipService</code> 的 <code>InitializeChannel</code> 方法会在该对象内部的 <code>deliveryService: map[string]deliverclient.DeliverService</code> 字典中插入该通道名的 <code>DeliverService</code>，该对象结构如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> DeliverService <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// StartDeliverForChannel dynamically starts delivery of new blocks from ordering service</span></div><div class="line">	<span class="comment">// to channel peers.</span></div><div class="line">	<span class="comment">// When the delivery finishes, the finalizer func is called</span></div><div class="line">	StartDeliverForChannel(chainID <span class="keyword">string</span>, ledgerInfo blocksprovider.LedgerInfo, finalizer <span class="function"><span class="keyword">func</span><span class="params">()</span>) <span class="title">error</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">	// <span class="title">StopDeliverForChannel</span> <span class="title">dynamically</span> <span class="title">stops</span> <span class="title">delivery</span> <span class="title">of</span> <span class="title">new</span> <span class="title">blocks</span> <span class="title">from</span> <span class="title">ordering</span> <span class="title">service</span></span></div><div class="line"><span class="function">	// <span class="title">to</span> <span class="title">channel</span> <span class="title">peers</span>.</span></div><div class="line"><span class="function">	<span class="title">StopDeliverForChannel</span><span class="params">(chainID <span class="keyword">string</span>)</span> <span class="title">error</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">	// <span class="title">UpdateEndpoints</span></span></div><div class="line"><span class="function">	<span class="title">UpdateEndpoints</span><span class="params">(chainID <span class="keyword">string</span>, endpoints []<span class="keyword">string</span>)</span> <span class="title">error</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">	// <span class="title">Stop</span> <span class="title">terminates</span> <span class="title">delivery</span> <span class="title">service</span> <span class="title">and</span> <span class="title">closes</span> <span class="title">the</span> <span class="title">connection</span></span></div><div class="line"><span class="function">	<span class="title">Stop</span><span class="params">()</span></span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure></p>
<p>然后，<code>leaderElection := viper.GetBool(&quot;peer.gossip.useLeaderElection&quot;)</code> 以及 <code>isStaticOrgLeader := viper.GetBool(&quot;peer.gossip.orgLeader&quot;)</code>，这两个变量是互斥的，如果 <code>leaderElection</code> 为真，则开始 gossip 选举 leader，否则如果 <code>isStaticOrgLeader</code> 为真，则调用 <code>g.deliveryService[chainID].StartDeliverForChannel</code> 开始拉块。<br>而 <code>StartDeliverForChannel</code> 方法最终调用到 <code>func (b *blocksProviderImpl) DeliverBlocks()</code> 方法（位于：github.com/hyperledger/fabric/core/deliverservice/blocksprovider/blocksprovider.go）       </p>
<p>然后调用 <code>blocksProviderImpl.gossip.Gossip(msp)</code> 发送刚刚通过 deliver 获取的区块。其中的 <code>gossip</code> 对象的接口定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> GossipServiceAdapter <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// PeersOfChannel returns slice with members of specified channel</span></div><div class="line">	PeersOfChannel(gossipcommon.ChainID) []discovery.NetworkMember</div><div class="line"></div><div class="line">	<span class="comment">// AddPayload adds payload to the local state sync buffer</span></div><div class="line">	AddPayload(chainID <span class="keyword">string</span>, payload *gossip_proto.Payload) error</div><div class="line"></div><div class="line">	<span class="comment">// Gossip the message across the peers</span></div><div class="line">	Gossip(msg *gossip_proto.GossipMessage)</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">`      </span></div><div class="line"><span class="string">具体实现如下 (github.com/hyperledger/fabric/gossip/gossip/gossip_impl.go)： </span></div><div class="line"><span class="string">`</span><span class="string">``</span> <span class="keyword">go</span></div><div class="line"><span class="keyword">type</span> gossipServiceImpl <span class="keyword">struct</span> &#123;</div><div class="line">	selfIdentity          api.PeerIdentityType</div><div class="line">	includeIdentityPeriod time.Time</div><div class="line">	certStore             *certStore</div><div class="line">	idMapper              identity.Mapper</div><div class="line">	presumedDead          <span class="keyword">chan</span> common.PKIidType</div><div class="line">	disc                  discovery.Discovery</div><div class="line">	comm                  comm.Comm</div><div class="line">	incTime               time.Time</div><div class="line">	selfOrg               api.OrgIdentityType</div><div class="line">	*comm.ChannelDeMultiplexer</div><div class="line">	logger            *logging.Logger</div><div class="line">	stopSignal        *sync.WaitGroup</div><div class="line">	conf              *Config</div><div class="line">	toDieChan         <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	stopFlag          <span class="keyword">int32</span></div><div class="line">	emitter           batchingEmitter</div><div class="line">	discAdapter       *discoveryAdapter</div><div class="line">	secAdvisor        api.SecurityAdvisor</div><div class="line">	chanState         *channelState</div><div class="line">	disSecAdap        *discoverySecurityAdapter</div><div class="line">	mcs               api.MessageCryptoService</div><div class="line">	stateInfoMsgStore msgstore.MessageStore</div><div class="line">	certPuller        pull.Mediator</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在创建 <code>gossipServiceImpl</code> 时，会初始化 <code>emitter</code> 字段，类型为 <code>batchingEmitter</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> batchingEmitter <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// Add adds a message to be batched</span></div><div class="line">	Add(<span class="keyword">interface</span>&#123;&#125;)</div><div class="line">	<span class="comment">// Stop stops the component</span></div><div class="line">	Stop()</div><div class="line">	<span class="comment">// Size returns the amount of pending messages to be emitted</span></div><div class="line">	Size() <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iterations: 每条数据发送的次数</span></div><div class="line"><span class="comment">// Add() 后，如果信息条数达到 burstSize，则自动 emit()</span></div><div class="line"><span class="comment">// 如果超过 latency 时间，也会 emit()</span></div><div class="line"><span class="comment">// cb 才是真正发送的函数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newBatchingEmitter</span><span class="params">(iterations, burstSize <span class="keyword">int</span>, latency time.Duration, cb emitBatchCallback)</span> <span class="title">batchingEmitter</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> iterations &lt; <span class="number">0</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(errors.Errorf(<span class="string">"Got a negative iterations number"</span>))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	p := &amp;batchingEmitterImpl&#123;</div><div class="line">		cb:         cb,</div><div class="line">		delay:      latency,</div><div class="line">		iterations: iterations,</div><div class="line">		burstSize:  burstSize,</div><div class="line">		lock:       &amp;sync.Mutex&#123;&#125;,</div><div class="line">		buff:       <span class="built_in">make</span>([]*batchedMessage, <span class="number">0</span>),</div><div class="line">		stopFlag:   <span class="keyword">int32</span>(<span class="number">0</span>),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> iterations != <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">go</span> p.periodicEmit() <span class="comment">// 以 latency 为间隔，调用 cb 发送数据</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> p</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>newBatchingEmitter</code> 中传入的 <code>cb emitBatchCallback</code> 是 <code>sendGossipBatch</code>，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *gossipServiceImpl)</span> <span class="title">sendGossipBatch</span><span class="params">(a []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	msgs2Gossip := <span class="built_in">make</span>([]*emittedGossipMessage, <span class="built_in">len</span>(a))</div><div class="line">	<span class="keyword">for</span> i, e := <span class="keyword">range</span> a &#123;</div><div class="line">		msgs2Gossip[i] = e.(*emittedGossipMessage)</div><div class="line">	&#125;</div><div class="line">	g.gossipBatch(msgs2Gossip)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终调用发送：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Send the messages to the remote peers</span></div><div class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> messagesOfChannel &#123;</div><div class="line">    filteredPeers := g.removeSelfLoop(msg, peers2Send)</div><div class="line">    g.comm.Send(msg.SignedGossipMessage, filteredPeers...)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，<code>g.comm</code>，接口定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Comm <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// GetPKIid returns this instance's PKI id</span></div><div class="line">	GetPKIid() common.PKIidType</div><div class="line">	<span class="comment">// Send sends a message to remote peers</span></div><div class="line">	Send(msg *proto.SignedGossipMessage, peers ...*RemotePeer)</div><div class="line">	<span class="comment">// SendWithAck sends a message to remote peers, waiting for acknowledgement from minAck of them, or until a certain timeout expires</span></div><div class="line">	SendWithAck(msg *proto.SignedGossipMessage, timeout time.Duration, minAck <span class="keyword">int</span>, peers ...*RemotePeer) AggregatedSendResult</div><div class="line">	<span class="comment">// Probe probes a remote node and returns nil if its responsive,</span></div><div class="line">	<span class="comment">// and an error if it's not.</span></div><div class="line">	Probe(peer *RemotePeer) error</div><div class="line">	<span class="comment">// Handshake authenticates a remote peer and returns</span></div><div class="line">	<span class="comment">// (its identity, nil) on success and (nil, error)</span></div><div class="line">	Handshake(peer *RemotePeer) (api.PeerIdentityType, error)</div><div class="line">	<span class="comment">// Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.</span></div><div class="line">	<span class="comment">// Each message from the channel can be used to send a reply back to the sender</span></div><div class="line">	Accept(common.MessageAcceptor) &lt;-<span class="keyword">chan</span> proto.ReceivedMessage  </div><div class="line">	<span class="comment">// PresumedDead returns a read-only channel for node endpoints that are suspected to be offline</span></div><div class="line">	PresumedDead() &lt;-<span class="keyword">chan</span> common.PKIidType</div><div class="line">	<span class="comment">// CloseConn closes a connection to a certain endpoint</span></div><div class="line">	CloseConn(peer *RemotePeer)</div><div class="line">	<span class="comment">// Stop stops the module</span></div><div class="line">	Stop()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用工厂方法创建 <code>Comm</code>，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewCommInstance creates a new comm instance that binds itself to the given gRPC server</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCommInstance</span><span class="params">(s *grpc.Server, certs *common.TLSCertificates, idStore identity.Mapper,</span></span></div><div class="line"><span class="function"><span class="params">	peerIdentity api.PeerIdentityType, secureDialOpts api.PeerSecureDialOpts,</span></span></div><div class="line"><span class="function"><span class="params">	dialOpts ...grpc.DialOption)</span> <span class="params">(Comm, error)</span></span> &#123;</div><div class="line"></div><div class="line">	commInst, err := NewCommInstanceWithServer(<span class="number">-1</span>, idStore, peerIdentity, secureDialOpts, dialOpts...)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithStack(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	commInst.(*commImpl).tlsCerts = certs</div><div class="line">	proto.RegisterGossipServer(s, commInst.(*commImpl))</div><div class="line"></div><div class="line">	<span class="keyword">return</span> commInst, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>Comm</code> 的实现类 <code>commImpl</code>，有个 <code>createConnection</code> 方法，用来创建 <code>gossipClient</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *commImpl)</span> <span class="title">createConnection</span><span class="params">(endpoint <span class="keyword">string</span>, expectedPKIID common.PKIidType)</span> <span class="params">(*connection, error)</span></span> &#123;</div><div class="line">    <span class="comment">// 省略 ...</span></div><div class="line">    cl := proto.NewGossipClient(cc)</div><div class="line">    stream, err = cl.GossipStream(ctx)</div><div class="line">    <span class="comment">// 省略 ...</span></div><div class="line">	<span class="comment">// 这个函数是 conn 接收到数据后的处理函数</span></div><div class="line">	h := <span class="function"><span class="keyword">func</span><span class="params">(m *proto.SignedGossipMessage)</span></span> &#123;</div><div class="line">		c.logger.Debug(<span class="string">"Got message:"</span>, m)</div><div class="line">		c.msgPublisher.DeMultiplex(&amp;ReceivedMessageImpl&#123;</div><div class="line">			conn:                conn,</div><div class="line">			lock:                conn,</div><div class="line">			SignedGossipMessage: m,</div><div class="line">			connInfo:            connInfo,</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 省略 ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>commImpl.Send()</code> 方法只是把值放入到了 chan 中，内部有个协程不断的取出来并调用 <code>stream.Send()</code> 发送       </p>
<p>上面的 <code>msgPublisher</code> 是一个 Pub/Sub 模块，类型是 <code>ChannelDeMultiplexer</code>，存在于 <code>commImpl</code> 的结构体中   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ChannelDeMultiplexer is a struct that can receive channel registrations (AddChannel)</span></div><div class="line"><span class="comment">// and publications (DeMultiplex) and it broadcasts the publications to registrations</span></div><div class="line"><span class="comment">// according to their predicate</span></div><div class="line"><span class="keyword">type</span> ChannelDeMultiplexer <span class="keyword">struct</span> &#123;</div><div class="line">	channels []*channel</div><div class="line">	lock     *sync.RWMutex</div><div class="line">	closed   <span class="keyword">int32</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 注册监听者</span></div><div class="line"><span class="comment">// AddChannel registers a channel with a certain predicate</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ChannelDeMultiplexer)</span> <span class="title">AddChannel</span><span class="params">(predicate common.MessageAcceptor)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">	m.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> m.lock.Unlock()</div><div class="line">	ch := &amp;channel&#123;ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>), pred: predicate&#125;</div><div class="line">	m.channels = <span class="built_in">append</span>(m.channels, ch)</div><div class="line">	<span class="keyword">return</span> ch.ch</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 发送数据</span></div><div class="line"><span class="comment">// DeMultiplex broadcasts the message to all channels that were returned</span></div><div class="line"><span class="comment">// by AddChannel calls and that hold the respected predicates.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ChannelDeMultiplexer)</span> <span class="title">DeMultiplex</span><span class="params">(msg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="built_in">recover</span>()</div><div class="line">	&#125;() <span class="comment">// recover from sending on a closed channel</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.isClosed() &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	m.lock.RLock()</div><div class="line">	channels := m.channels</div><div class="line">	m.lock.RUnlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> channels &#123;</div><div class="line">		<span class="keyword">if</span> ch.pred(msg) &#123;</div><div class="line">			ch.ch &lt;- msg</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>Comm interface</code> <code>commImpl struct</code> 的 <code>Accept</code> 方法，传入一个 msg 过滤器，返回一个通道，从这个通道可以获取所有符合该过滤器的 gossip 消息，Accept 方法就是调用 <code>ChannelDeMultiplexer</code> 的 <code>AddChannel</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="string">``</span><span class="string">`</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">当 `</span>NewGossipService()<span class="string">` 创建全局的对象时，会调用 `</span><span class="keyword">go</span> g.start()<span class="string">` 开启数据监听处理函数，而 start 方法中</span></div><div class="line"><span class="string">`</span><span class="string">``</span> <span class="keyword">go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *gossipServiceImpl)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">go</span> g.syncDiscovery()</div><div class="line">	<span class="keyword">go</span> g.handlePresumedDead()</div><div class="line"></div><div class="line">	msgSelector := <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line">		gMsg, isGossipMsg := msg.(proto.ReceivedMessage)</div><div class="line">		<span class="keyword">if</span> !isGossipMsg &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">		isConn := gMsg.GetGossipMessage().GetConn() != <span class="literal">nil</span></div><div class="line">		isEmpty := gMsg.GetGossipMessage().GetEmpty() != <span class="literal">nil</span></div><div class="line">		isPrivateData := gMsg.GetGossipMessage().IsPrivateDataMsg()</div><div class="line"></div><div class="line">		<span class="keyword">return</span> !(isConn || isEmpty || isPrivateData)</div><div class="line">	&#125;</div><div class="line">	incMsgs := g.comm.Accept(msgSelector) <span class="comment">// 这里调用了 Accept 方法，加入了数据监听者，过滤得到非连接、非空、非private数据</span></div><div class="line">	<span class="keyword">go</span> g.acceptMessages(incMsgs)  <span class="comment">// 处理得到的数据</span></div><div class="line">	g.logger.Info(<span class="string">"Gossip instance"</span>, g.conf.ID, <span class="string">"started"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>gossipServiceImpl.acceptMesages</code> 调用 <code>gossipServiceImpl.handleMessage</code>，然后它继续调用 <code>GossipChannel</code> 接口的 <code>HandleMessage</code> 处理消息。    </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GossipChannel 处理通道相关的 gossip 消息</span></div><div class="line"><span class="comment">// GossipChannel defines an object that deals with all channel-related messages</span></div><div class="line"><span class="keyword">type</span> GossipChannel <span class="keyword">interface</span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">// GetPeers returns a list of peers with metadata as published by them</span></div><div class="line">	GetPeers() []discovery.NetworkMember</div><div class="line"></div><div class="line">	<span class="comment">// PeerFilter receives a SubChannelSelectionCriteria and returns a RoutingFilter that selects</span></div><div class="line">	<span class="comment">// only peer identities that match the given criteria</span></div><div class="line">	PeerFilter(api.SubChannelSelectionCriteria) filter.RoutingFilter</div><div class="line"></div><div class="line">	<span class="comment">// IsMemberInChan checks whether the given member is eligible to be in the channel</span></div><div class="line">	IsMemberInChan(member discovery.NetworkMember) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// UpdateStateInfo updates this channel's StateInfo message</span></div><div class="line">	<span class="comment">// that is periodically published</span></div><div class="line">	UpdateStateInfo(msg *proto.SignedGossipMessage)</div><div class="line"></div><div class="line">	<span class="comment">// IsOrgInChannel returns whether the given organization is in the channel</span></div><div class="line">	IsOrgInChannel(membersOrg api.OrgIdentityType) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// EligibleForChannel returns whether the given member should get blocks</span></div><div class="line">	<span class="comment">// for this channel</span></div><div class="line">	EligibleForChannel(member discovery.NetworkMember) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// HandleMessage processes a message sent by a remote peer</span></div><div class="line">	HandleMessage(proto.ReceivedMessage)</div><div class="line"></div><div class="line">	<span class="comment">// AddToMsgStore adds a given GossipMessage to the message store</span></div><div class="line">	AddToMsgStore(msg *proto.SignedGossipMessage)</div><div class="line"></div><div class="line">	<span class="comment">// ConfigureChannel (re)configures the list of organizations</span></div><div class="line">	<span class="comment">// that are eligible to be in the channel</span></div><div class="line">	ConfigureChannel(joinMsg api.JoinChannelMessage)</div><div class="line"></div><div class="line">	<span class="comment">// LeaveChannel makes the peer leave the channel</span></div><div class="line">	LeaveChannel()</div><div class="line"></div><div class="line">	<span class="comment">// Stop stops the channel's activity</span></div><div class="line">	Stop()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>GossipChannel</code> 是保存在 <code>gossipService</code> 的 <code>channelState</code> 的 map 字典中，其 <code>HandleMessage</code> 方法，将数据加入（Add() 方法）到 <code>MessageStore</code> 中，使用 <code>gossipChannel</code> 中一个结构体变量 <code>blockMsgStore</code>，类型为 <code>MessageStore</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MessageStore 是一个起缓冲作用的对象</span></div><div class="line"><span class="keyword">type</span> MessageStore <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// add adds a message to the store</span></div><div class="line">	<span class="comment">// returns true or false whether the message was added to the store</span></div><div class="line">	Add(msg <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// Checks if message is valid for insertion to store</span></div><div class="line">	<span class="comment">// returns true or false whether the message can be added to the store</span></div><div class="line">	CheckValid(msg <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// size returns the amount of messages in the store</span></div><div class="line">	Size() <span class="keyword">int</span></div><div class="line"></div><div class="line">	<span class="comment">// get returns all messages in the store</span></div><div class="line">	Get() []<span class="keyword">interface</span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Stop all associated go routines</span></div><div class="line">	Stop()</div><div class="line"></div><div class="line">	<span class="comment">// Purge purges all messages that are accepted by</span></div><div class="line">	<span class="comment">// the given predicate</span></div><div class="line">	Purge(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure></p>
<p><code>GossipStateProvider</code> </p>
<h1 id="Merkle-tree"><a href="#Merkle-tree" class="headerlink" title="Merkle tree"></a>Merkle tree</h1><p><a href="http://www.zhibimo.com/read/wang-miao/mastering-bitcoin/Chapter07.html" target="_blank" rel="external">不错的介绍</a>     </p>
<p>比特币每个区块头部都有一个 <code>Merkle tree root</code>，而不是 <code>所有交易 hash 值的总 hash 值（这同等与整个区块内容的 hash 值）</code>，为了快速方便 <code>验证一个交易（hash）是否存在于该区块中</code>。如果采用 <code>所有交易 hash 值的总 hash 值（或区块内容的 hash 值）</code> 的方式，则为了验证一个交易是否存在，首先得计算该交易的 hash 值，然后获得该区块内 <strong>所有交易</strong> 的 hash 值/或是拉取 <strong>整个区块内容</strong>（这是因为首先要验证获取的区块内容（所有交易）是否与区块头中的 hash 一致，这很重要，因为只有区块头部的 hash 值才是用户信任的源头）。 而如果采用 <code>Merkle tree root</code> 的方式，则只要获得 <strong>log(n)</strong> 个交易的 hash 值（只要有一条分支到达 root 即可），实现简单支付验证（SPV）       </p>
<p>另外 Merkle tree 的作用是快速的比较数据部分内容是否不一致</p>
<h1 id="vscc-校验交易过程"><a href="#vscc-校验交易过程" class="headerlink" title="vscc 校验交易过程"></a>vscc 校验交易过程</h1><h1 id="commit-block-过程"><a href="#commit-block-过程" class="headerlink" title="commit block 过程"></a>commit block 过程</h1><p><code>NewCommonStorageDBProvider</code></p>
<p><code>PeerLedgerProvider</code> 是一个工厂，产生 <code>PeerLedger</code>，它包括了操作 <code>账本</code>、<code>世界状态</code> 等数据的对象。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PeerLedgerProvider <span class="keyword">interface</span> &#123;</div><div class="line">	Initialize(statelisteners StateListeners)</div><div class="line">	<span class="comment">// Create creates a new ledger with the given genesis block.</span></div><div class="line">	<span class="comment">// This function guarantees that the creation of ledger and committing the genesis block would an atomic action</span></div><div class="line">	<span class="comment">// The chain id retrieved from the genesis block is treated as a ledger id</span></div><div class="line">	Create(genesisBlock *common.Block) (PeerLedger, error)</div><div class="line">	<span class="comment">// Open opens an already created ledger</span></div><div class="line">	Open(ledgerID <span class="keyword">string</span>) (PeerLedger, error)</div><div class="line">	<span class="comment">// Exists tells whether the ledger with given id exists</span></div><div class="line">	Exists(ledgerID <span class="keyword">string</span>) (<span class="keyword">bool</span>, error)</div><div class="line">	<span class="comment">// List lists the ids of the existing ledgers</span></div><div class="line">	List() ([]<span class="keyword">string</span>, error)</div><div class="line">	<span class="comment">// Close closes the PeerLedgerProvider</span></div><div class="line">	Close()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>PeerLedger</code> 的接口如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PeerLedger <span class="keyword">interface</span> &#123;</div><div class="line">	commonledger.Ledger</div><div class="line">	<span class="comment">// GetTransactionByID retrieves a transaction by id</span></div><div class="line">	GetTransactionByID(txID <span class="keyword">string</span>) (*peer.ProcessedTransaction, error)</div><div class="line">	<span class="comment">// GetBlockByHash returns a block given it's hash</span></div><div class="line">	GetBlockByHash(blockHash []<span class="keyword">byte</span>) (*common.Block, error)</div><div class="line">	<span class="comment">// GetBlockByTxID returns a block which contains a transaction</span></div><div class="line">	GetBlockByTxID(txID <span class="keyword">string</span>) (*common.Block, error)</div><div class="line">	<span class="comment">// GetTxValidationCodeByTxID returns reason code of transaction validation</span></div><div class="line">	GetTxValidationCodeByTxID(txID <span class="keyword">string</span>) (peer.TxValidationCode, error)</div><div class="line">	<span class="comment">// NewTxSimulator gives handle to a transaction simulator.</span></div><div class="line">	<span class="comment">// A client can obtain more than one 'TxSimulator's for parallel execution.</span></div><div class="line">	<span class="comment">// Any snapshoting/synchronization should be performed at the implementation level if required</span></div><div class="line">	NewTxSimulator(txid <span class="keyword">string</span>) (TxSimulator, error)</div><div class="line">	<span class="comment">// NewQueryExecutor gives handle to a query executor.</span></div><div class="line">	<span class="comment">// A client can obtain more than one 'QueryExecutor's for parallel execution.</span></div><div class="line">	<span class="comment">// Any synchronization should be performed at the implementation level if required</span></div><div class="line">	NewQueryExecutor() (QueryExecutor, error)</div><div class="line">	<span class="comment">// NewHistoryQueryExecutor gives handle to a history query executor.</span></div><div class="line">	<span class="comment">// A client can obtain more than one 'HistoryQueryExecutor's for parallel execution.</span></div><div class="line">	<span class="comment">// Any synchronization should be performed at the implementation level if required</span></div><div class="line">	NewHistoryQueryExecutor() (HistoryQueryExecutor, error)</div><div class="line">	<span class="comment">// GetPvtDataAndBlockByNum returns the block and the corresponding pvt data.</span></div><div class="line">	<span class="comment">// The pvt data is filtered by the list of 'ns/collections' supplied</span></div><div class="line">	<span class="comment">// A nil filter does not filter any results and causes retrieving all the pvt data for the given blockNum</span></div><div class="line">	GetPvtDataAndBlockByNum(blockNum <span class="keyword">uint64</span>, filter PvtNsCollFilter) (*BlockAndPvtData, error)</div><div class="line">	<span class="comment">// GetPvtDataByNum returns only the pvt data  corresponding to the given block number</span></div><div class="line">	<span class="comment">// The pvt data is filtered by the list of 'ns/collections' supplied in the filter</span></div><div class="line">	<span class="comment">// A nil filter does not filter any results and causes retrieving all the pvt data for the given blockNum</span></div><div class="line">	GetPvtDataByNum(blockNum <span class="keyword">uint64</span>, filter PvtNsCollFilter) ([]*TxPvtData, error)</div><div class="line">	<span class="comment">// CommitWithPvtData commits the block and the corresponding pvt data in an atomic operation</span></div><div class="line">	CommitWithPvtData(blockAndPvtdata *BlockAndPvtData) error</div><div class="line">	<span class="comment">// Purge removes private read-writes set generated by endorsers at block height lesser than</span></div><div class="line">	<span class="comment">// a given maxBlockNumToRetain. In other words, Purge only retains private read-write sets</span></div><div class="line">	<span class="comment">// that were generated at block height of maxBlockNumToRetain or higher.</span></div><div class="line">	PurgePrivateData(maxBlockNumToRetain <span class="keyword">uint64</span>) error</div><div class="line">	<span class="comment">// PrivateDataMinBlockNum returns the lowest retained endorsement block height</span></div><div class="line">	PrivateDataMinBlockNum() (<span class="keyword">uint64</span>, error)</div><div class="line">	<span class="comment">//Prune prunes the blocks/transactions that satisfy the given policy</span></div><div class="line">	Prune(policy commonledger.PrunePolicy) error</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>PeerLedgerProvider</code> 的实现类 <code>Provider</code> 产生 <code>PeerLedger</code> 的代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(provider *Provider)</span> <span class="title">openInternal</span><span class="params">(ledgerID <span class="keyword">string</span>)</span> <span class="params">(ledger.PeerLedger, error)</span></span> &#123;</div><div class="line">	<span class="comment">// Get the block store for a chain/ledger</span></div><div class="line">	blockStore, err := provider.ledgerStoreProvider.Open(ledgerID)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Get the versioned database (state database) for a chain/ledger</span></div><div class="line">	<span class="comment">// 操作 state db，即世界状态</span></div><div class="line">	vDB, err := provider.vdbProvider.GetDBHandle(ledgerID) </div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Get the history database (index for history of values by key) for a chain/ledger</span></div><div class="line">	historyDB, err := provider.historydbProvider.GetDBHandle(ledgerID)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Create a kvLedger for this chain/ledger, which encasulates the underlying data stores</span></div><div class="line">	<span class="comment">// (id store, blockstore, state database, history database)</span></div><div class="line">	l, err := newKVLedger(ledgerID, blockStore, vDB, historyDB, provider.stateListeners)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> l, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过一个全局方法就可以获得对应通道的 <code>PeerLedger</code>，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLedger</span><span class="params">(cid <span class="keyword">string</span>)</span> <span class="title">ledger</span>.<span class="title">PeerLedger</span></span> &#123;</div><div class="line">	chains.RLock()</div><div class="line">	<span class="keyword">defer</span> chains.RUnlock()</div><div class="line">	<span class="keyword">if</span> c, ok := chains.list[cid]; ok &#123;</div><div class="line">		<span class="keyword">return</span> c.cs.ledger</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>kvLedger</code> 是 <code>ledger.PeerLedger</code> 的实现类<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> kvLedger <span class="keyword">struct</span> &#123;</div><div class="line">	ledgerID        <span class="keyword">string</span></div><div class="line">	blockStore      *ledgerstorage.Store</div><div class="line">	txtmgmt         txmgr.TxMgr</div><div class="line">	historyDB       historydb.HistoryDB</div><div class="line">	blockAPIsRWLock *sync.RWMutex</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Gossip-协议介绍"><a href="#Gossip-协议介绍" class="headerlink" title="Gossip 协议介绍"></a>Gossip 协议介绍</h1><p><a href="http://kaiyuan.me/2015/07/08/Gossip/" target="_blank" rel="external">链接</a><br>同步时间是集群规模的对数时间，也叫“反熵”算法。<br>应用 gossip 的应用有：Cassandra     </p>
<h1 id="Fabric-中的-pull-based-gossip-实现"><a href="#Fabric-中的-pull-based-gossip-实现" class="headerlink" title="Fabric 中的 pull-based gossip 实现"></a>Fabric 中的 pull-based gossip 实现</h1><p><a href="https://blog.csdn.net/idsuf698987/article/details/77948977" target="_blank" rel="external">很好的文档</a><br>首先介绍 <code>PullEngine</code> 是底层的算法实现，不考虑数据的存储和计算，内部存的是数据的摘要，结构体如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PullEngine is the component that actually invokes the pull algorithm</span></div><div class="line"><span class="comment">// with the help of the PullAdapter</span></div><div class="line"><span class="comment">// 底层的功能实现，与上层具体数据结构解耦，与业务相关的实现交由 PullAdapter 接口实现</span></div><div class="line"><span class="keyword">type</span> PullEngine <span class="keyword">struct</span> &#123;</div><div class="line">	PullAdapter        <span class="comment">// 这个比较关键，是个接口（算法的上层数据结构实现），可以替换具体的实现，默认实现见下方介绍</span></div><div class="line">	stopFlag           <span class="keyword">int32</span></div><div class="line">	state              *util.Set   <span class="comment">// 不涉及具体的数据结构，只是存储其字符串类型的摘要</span></div><div class="line">	item2owners        <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>  <span class="comment">// map[摘要][]&#123;回应该摘要的peer列表&#125;</span></div><div class="line">	peers2nonces       <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>    <span class="comment">// map[peer]nonce</span></div><div class="line">	nonces2peers       <span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">string</span>    <span class="comment">// map[nonce]peer</span></div><div class="line">	acceptingDigests   <span class="keyword">int32</span>   <span class="comment">// 标志位，表示是否开始接收摘要</span></div><div class="line">	acceptingResponses <span class="keyword">int32</span>   <span class="comment">// 标志位，表示是否开始接收数据</span></div><div class="line">	lock               sync.Mutex</div><div class="line">	outgoingNONCES     *util.Set   <span class="comment">// 发出的 nonce 集合</span></div><div class="line">	incomingNONCES     *util.Set   <span class="comment">// 接收的 nonce 集合</span></div><div class="line">	digFilter          DigestFilter  <span class="comment">// 摘要过滤器生产工厂</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建 <code>PullEngine</code> 对象时，会启动一个协程，如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewPullEngineWithFilter creates an instance of a PullEngine with a certain sleep time</span></div><div class="line"><span class="comment">// between pull initiations, and uses the given filters when sending digests and responses</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPullEngineWithFilter</span><span class="params">(participant PullAdapter, sleepTime time.Duration, df DigestFilter)</span> *<span class="title">PullEngine</span></span> &#123;</div><div class="line">	engine := &amp;PullEngine&#123;</div><div class="line">		PullAdapter:        participant,</div><div class="line">		stopFlag:           <span class="keyword">int32</span>(<span class="number">0</span>),</div><div class="line">		state:              util.NewSet(),</div><div class="line">		item2owners:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>),</div><div class="line">		peers2nonces:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>),</div><div class="line">		nonces2peers:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">string</span>),</div><div class="line">		acceptingDigests:   <span class="keyword">int32</span>(<span class="number">0</span>),</div><div class="line">		acceptingResponses: <span class="keyword">int32</span>(<span class="number">0</span>),</div><div class="line">		incomingNONCES:     util.NewSet(),</div><div class="line">		outgoingNONCES:     util.NewSet(),</div><div class="line">		digFilter:          df,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> !engine.toDie() &#123;</div><div class="line">			time.Sleep(sleepTime)</div><div class="line">			<span class="keyword">if</span> engine.toDie() &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			engine.initiatePull()  <span class="comment">// 间隔发送 pull，拉取其他节点上的数据</span></div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> engine</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">initiatePull</span><span class="params">()</span></span> &#123;</div><div class="line">	engine.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> engine.lock.Unlock()</div><div class="line"></div><div class="line">	engine.acceptDigests()</div><div class="line">	<span class="keyword">for</span> _, peer := <span class="keyword">range</span> engine.SelectPeers() &#123;</div><div class="line">		nonce := engine.newNONCE()</div><div class="line">		engine.outgoingNONCES.Add(nonce)</div><div class="line">		engine.nonces2peers[nonce] = peer</div><div class="line">		engine.peers2nonces[peer] = nonce</div><div class="line">		engine.Hello(peer, nonce)   <span class="comment">// Hello 就是一个 pull 请求，收到 Hello 的节点会发送自己所有的摘要列表</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	digestWaitTime := util.GetDurationOrDefault(<span class="string">"peer.gossip.digestWaitTime"</span>, defDigestWaitTime)</div><div class="line">	time.AfterFunc(digestWaitTime, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		engine.processIncomingDigests()</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OnHello notifies the engine a hello has arrived</span></div><div class="line"><span class="comment">// 其实就是当 pull 请求到达后，发送所有满足过滤条件的摘要回去（从 state 集合中获取摘要），</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">OnHello</span><span class="params">(nonce <span class="keyword">uint64</span>, context <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	engine.incomingNONCES.Add(nonce)</div><div class="line"></div><div class="line">	requestWaitTime := util.GetDurationOrDefault(<span class="string">"peer.gossip.requestWaitTime"</span>, defRequestWaitTime)</div><div class="line">	time.AfterFunc(requestWaitTime, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		engine.incomingNONCES.Remove(nonce)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	a := engine.state.ToArray()</div><div class="line">	<span class="keyword">var</span> digest []<span class="keyword">string</span></div><div class="line">	filter := engine.digFilter(context)</div><div class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> a &#123;</div><div class="line">		dig := item.(<span class="keyword">string</span>)</div><div class="line">		<span class="keyword">if</span> !filter(dig) &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		digest = <span class="built_in">append</span>(digest, dig)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(digest) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	engine.SendDigest(digest, nonce, context)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OnDigest notifies the engine that a digest has arrived</span></div><div class="line"><span class="comment">// 实现就是当收到某个节点传回的摘要列表后，整理一下，归类同一个摘要的所有发送源（节点）信息，存于 item2owners 中</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">OnDigest</span><span class="params">(digest []<span class="keyword">string</span>, nonce <span class="keyword">uint64</span>, context <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !engine.isAcceptingDigests() || !engine.outgoingNONCES.Exists(nonce) &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	engine.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> engine.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> digest &#123;</div><div class="line">		<span class="keyword">if</span> engine.state.Exists(n) &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> _, exists := engine.item2owners[n]; !exists &#123;</div><div class="line">			engine.item2owners[n] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		engine.item2owners[n] = <span class="built_in">append</span>(engine.item2owners[n], engine.nonces2peers[nonce])</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 <code>initiatePull</code> 中可知，发送 <code>Hello</code> 的一段时间后，会调用 <code>engine.processIncomingDigests</code>，如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据 item2owners 字典，整理出某个远程节点上，需要请求的摘要列表，存于 requestMapping 字典中</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">processIncomingDigests</span><span class="params">()</span></span> &#123;</div><div class="line">	engine.ignoreDigests()</div><div class="line"></div><div class="line">	engine.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> engine.lock.Unlock()</div><div class="line"></div><div class="line">	requestMapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</div><div class="line">	<span class="keyword">for</span> n, sources := <span class="keyword">range</span> engine.item2owners &#123;</div><div class="line">		<span class="comment">// select a random source</span></div><div class="line">		source := sources[util.RandomInt(<span class="built_in">len</span>(sources))]</div><div class="line">		<span class="keyword">if</span> _, exists := requestMapping[source]; !exists &#123;</div><div class="line">			requestMapping[source] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// append the number to that source</span></div><div class="line">		requestMapping[source] = <span class="built_in">append</span>(requestMapping[source], n)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	engine.acceptResponses()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> dest, seqsToReq := <span class="keyword">range</span> requestMapping &#123;</div><div class="line">		engine.SendReq(dest, seqsToReq, engine.peers2nonces[dest])  <span class="comment">// 请求节点，获取它上面 seqsToReq 列表里摘要所对应的数据</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	responseWaitTime := util.GetDurationOrDefault(<span class="string">"peer.gossip.responseWaitTime"</span>, defResponseWaitTime)</div><div class="line">	time.AfterFunc(responseWaitTime, engine.endPull)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OnReq notifies the engine a request has arrived</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">OnReq</span><span class="params">(items []<span class="keyword">string</span>, nonce <span class="keyword">uint64</span>, context <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !engine.incomingNONCES.Exists(nonce) &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	engine.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> engine.lock.Unlock()</div><div class="line"></div><div class="line">	filter := engine.digFilter(context)</div><div class="line">	<span class="keyword">var</span> items2Send []<span class="keyword">string</span></div><div class="line">	<span class="comment">// 获取满足过滤条件，且存在于当前节点的摘要列表</span></div><div class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</div><div class="line">		<span class="keyword">if</span> engine.state.Exists(item) &amp;&amp; filter(item) &#123;</div><div class="line">			items2Send = <span class="built_in">append</span>(items2Send, item)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(items2Send) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 关键点，调用 PullAdapter 接口的 SendRes 方法，传入的是 摘要列表，该方法内部应该会根据摘要获取真实数据并发送</span></div><div class="line">	<span class="keyword">go</span> engine.SendRes(items2Send, context, nonce)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OnRes notifies the engine a response has arrived</span></div><div class="line"><span class="comment">// 更新自身的 state 集合，上层业务相关的处理在 PullAdapter 中处理，并不在该函数中！</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">OnRes</span><span class="params">(items []<span class="keyword">string</span>, nonce <span class="keyword">uint64</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !engine.outgoingNONCES.Exists(nonce) || !engine.isAcceptingResponses() &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	engine.Add(items...) <span class="comment">// 新的摘要加入 state 集合</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PullAdapter</code> 接口的实现类如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> pullMediatorImpl <span class="keyword">struct</span> &#123;</div><div class="line">	sync.RWMutex</div><div class="line">	*PullAdapter</div><div class="line">	msgType2Hook <span class="keyword">map</span>[MsgType][]MessageHook</div><div class="line">	config       Config</div><div class="line">	logger       *logging.Logger</div><div class="line">	itemID2Msg   <span class="keyword">map</span>[<span class="keyword">string</span>]*proto.SignedGossipMessage</div><div class="line">	engine       *algo.PullEngine</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PullAdapter defines methods of the pullStore to interact</span></div><div class="line"><span class="comment">// with various modules of gossip</span></div><div class="line"><span class="keyword">type</span> PullAdapter <span class="keyword">struct</span> &#123;</div><div class="line">	Sndr             Sender   </div><div class="line">	MemSvc           MembershipService    <span class="comment">// 获取 peer 节点信息</span></div><div class="line">	IdExtractor      proto.IdentifierExtractor   <span class="comment">// 根据 gossipMsg 获取对应摘要</span></div><div class="line">	MsgCons          proto.MsgConsumer  </div><div class="line">	EgressDigFilter  EgressDigestFilter</div><div class="line">	IngressDigFilter IngressDigestFilter</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其 <code>SendRes</code> 方法实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SendRes sends an array of items to a remote PullEngine identified by a context.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pullMediatorImpl)</span> <span class="title">SendRes</span><span class="params">(items []<span class="keyword">string</span>, context <span class="keyword">interface</span>&#123;&#125;, nonce <span class="keyword">uint64</span>)</span></span> &#123;</div><div class="line">	items2return := []*proto.Envelope&#123;&#125;</div><div class="line">	p.RLock()</div><div class="line">	<span class="keyword">defer</span> p.RUnlock()</div><div class="line">	<span class="comment">// 根据传入的摘要列表，获取需要发送的数据实体，存于 items2return</span></div><div class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</div><div class="line">		<span class="keyword">if</span> msg, exists := p.itemID2Msg[item]; exists &#123;</div><div class="line">			items2return = <span class="built_in">append</span>(items2return, msg.Envelope)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	returnedUpdate := &amp;proto.GossipMessage&#123;</div><div class="line">		Channel: p.config.Channel,</div><div class="line">		Tag:     p.config.Tag,</div><div class="line">		Nonce:   <span class="number">0</span>,</div><div class="line">		Content: &amp;proto.GossipMessage_DataUpdate&#123;</div><div class="line">			DataUpdate: &amp;proto.DataUpdate&#123;</div><div class="line">				MsgType: p.config.MsgType,</div><div class="line">				Nonce:   nonce,</div><div class="line">				Data:    items2return,</div><div class="line">			&#125;,</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">	remotePeer := context.(proto.ReceivedMessage).GetConnectionInfo()</div><div class="line">	p.logger.Debug(<span class="string">"Sending"</span>, <span class="built_in">len</span>(returnedUpdate.GetDataUpdate().Data), p.config.MsgType, <span class="string">"items to"</span>, remotePeer)</div><div class="line">	context.(proto.ReceivedMessage).Respond(returnedUpdate)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pullMediatorImpl.HandleMessage</code> 是调用底层 <code>PullEngine</code> 中 <code>onHello</code>，<code>onDigest</code>，<code>onReq</code>，<code>onReq</code> 的 handler 方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pullMediatorImpl)</span> <span class="title">HandleMessage</span><span class="params">(m proto.ReceivedMessage)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> m.GetGossipMessage() == <span class="literal">nil</span> || !m.GetGossipMessage().IsPullMsg() &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	msg := m.GetGossipMessage()</div><div class="line">	msgType := msg.GetPullMsgType()</div><div class="line">	<span class="keyword">if</span> msgType != p.config.MsgType &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	p.logger.Debug(msg)</div><div class="line"></div><div class="line">	itemIDs := []<span class="keyword">string</span>&#123;&#125;</div><div class="line">	items := []*proto.SignedGossipMessage&#123;&#125;</div><div class="line">	<span class="keyword">var</span> pullMsgType MsgType</div><div class="line"></div><div class="line">	<span class="keyword">if</span> helloMsg := msg.GetHello(); helloMsg != <span class="literal">nil</span> &#123;</div><div class="line">		pullMsgType = HelloMsgType</div><div class="line">		p.engine.OnHello(helloMsg.Nonce, m)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> digest := msg.GetDataDig(); digest != <span class="literal">nil</span> &#123;</div><div class="line">		d := p.PullAdapter.IngressDigFilter(digest)</div><div class="line">		itemIDs = d.Digests</div><div class="line">		pullMsgType = DigestMsgType</div><div class="line">		p.engine.OnDigest(d.Digests, d.Nonce, m)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> req := msg.GetDataReq(); req != <span class="literal">nil</span> &#123;</div><div class="line">		itemIDs = req.Digests</div><div class="line">		pullMsgType = RequestMsgType</div><div class="line">		p.engine.OnReq(req.Digests, req.Nonce, m)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> res := msg.GetDataUpdate(); res != <span class="literal">nil</span> &#123;</div><div class="line">		itemIDs = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(res.Data))</div><div class="line">		items = <span class="built_in">make</span>([]*proto.SignedGossipMessage, <span class="built_in">len</span>(res.Data))</div><div class="line">		pullMsgType = ResponseMsgType</div><div class="line">		<span class="keyword">for</span> i, pulledMsg := <span class="keyword">range</span> res.Data &#123;</div><div class="line">			msg, err := pulledMsg.ToGossipMessage()</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				p.logger.Warningf(<span class="string">"Data update contains an invalid message: %+v"</span>, errors.WithStack(err))</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			p.MsgCons(msg)</div><div class="line">			itemIDs[i] = p.IdExtractor(msg)</div><div class="line">			items[i] = msg</div><div class="line">			p.Lock()</div><div class="line">			p.itemID2Msg[itemIDs[i]] = msg</div><div class="line">			p.Unlock()</div><div class="line">		&#125;</div><div class="line">		p.engine.OnRes(itemIDs, res.Nonce)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Invoke hooks for relevant message type</span></div><div class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> p.hooksByMsgType(pullMsgType) &#123;</div><div class="line">		h(itemIDs, items, m)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>GossipChannel（接口定义见上面）</code> 的实现类如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> gossipChannel <span class="keyword">struct</span> &#123;</div><div class="line">	Adapter</div><div class="line">	sync.RWMutex</div><div class="line">	shouldGossipStateInfo     <span class="keyword">int32</span></div><div class="line">	mcs                       api.MessageCryptoService</div><div class="line">	pkiID                     common.PKIidType</div><div class="line">	selfOrg                   api.OrgIdentityType</div><div class="line">	stopChan                  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	stateInfoMsg              *proto.SignedGossipMessage</div><div class="line">	orgs                      []api.OrgIdentityType</div><div class="line">	joinMsg                   api.JoinChannelMessage</div><div class="line">	blockMsgStore             msgstore.MessageStore</div><div class="line">	stateInfoMsgStore         *stateInfoCache</div><div class="line">	leaderMsgStore            msgstore.MessageStore</div><div class="line">	chainID                   common.ChainID</div><div class="line">	blocksPuller              pull.Mediator   <span class="comment">// 这个是 pullMediatorImpl </span></div><div class="line">	logger                    *logging.Logger</div><div class="line">	stateInfoPublishScheduler *time.Ticker</div><div class="line">	stateInfoRequestScheduler *time.Ticker</div><div class="line">	memFilter                 *membershipFilter</div><div class="line">	ledgerHeight              <span class="keyword">uint64</span></div><div class="line">	leftChannel               <span class="keyword">int32</span></div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span> <span class="keyword">go</span></div><div class="line"><span class="keyword">type</span> Mediator <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// Stop stop the Mediator</span></div><div class="line">	Stop()</div><div class="line">	<span class="comment">// RegisterMsgHook registers a message hook to a specific type of pull message</span></div><div class="line">	RegisterMsgHook(MsgType, MessageHook)</div><div class="line">	<span class="comment">// Add adds a GossipMessage to the Mediator</span></div><div class="line">	Add(*proto.SignedGossipMessage)</div><div class="line">	<span class="comment">// Remove removes a GossipMessage from the Mediator with a matching digest,</span></div><div class="line">	<span class="comment">// if such a message exits</span></div><div class="line">	Remove(digest <span class="keyword">string</span>)</div><div class="line">	<span class="comment">// HandleMessage handles a message from some remote peer</span></div><div class="line">	HandleMessage(msg proto.ReceivedMessage)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在创建 <code>gossipChannel</code> 对象时，会创建 <code>pullMediatorImpl</code> 对象( <code>blocksPuller</code> 字段 )，该对象会用 <code>NewPullEngineWithFilter</code>方法初始化内部的 <code>engine</code> 字段，产生 <code>PullEngine</code> 对象的同时，也会运行一个协程 <code>engine.initiatePull()</code> 不断的拉取（发送 <code>Hello()</code>）        </p>
<p><code>gossipChannel.HandleMessage</code> 是数据入口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HandleMessage processes a message sent by a remote peer</span></div><div class="line"><span class="comment">// 一开始会检查消息的正确性，发送方的组织是否在 channel 中等等</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gc *gossipChannel)</span> <span class="title">HandleMessage</span><span class="params">(msg proto.ReceivedMessage)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !gc.verifyMsg(msg) &#123;</div><div class="line">		gc.logger.Warning(<span class="string">"Failed verifying message:"</span>, msg.GetGossipMessage().GossipMessage)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	m := msg.GetGossipMessage()</div><div class="line">	<span class="keyword">if</span> !m.IsChannelRestricted() &#123;</div><div class="line">		gc.logger.Warning(<span class="string">"Got message"</span>, msg.GetGossipMessage(), <span class="string">"but it's not a per-channel message, discarding it"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	orgID := gc.GetOrgOfPeer(msg.GetConnectionInfo().ID)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(orgID) == <span class="number">0</span> &#123;</div><div class="line">		gc.logger.Debug(<span class="string">"Couldn't find org identity of peer"</span>, msg.GetConnectionInfo())</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> !gc.IsOrgInChannel(orgID) &#123;</div><div class="line">		gc.logger.Warning(<span class="string">"Point to point message came from"</span>, msg.GetConnectionInfo(),</div><div class="line">			<span class="string">", org("</span>, <span class="keyword">string</span>(orgID), <span class="string">") but it's not eligible for the channel"</span>, <span class="keyword">string</span>(gc.chainID))</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.IsStateInfoPullRequestMsg() &#123;</div><div class="line">		msg.Respond(gc.createStateInfoSnapshot(orgID))</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.IsStateInfoSnapshot() &#123;</div><div class="line">		gc.handleStateInfSnapshot(m.GossipMessage, msg.GetConnectionInfo().ID)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.IsDataMsg() || m.IsStateInfoMsg() &#123;</div><div class="line">		added := <span class="literal">false</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> m.IsDataMsg() &#123;</div><div class="line">			<span class="keyword">if</span> m.GetDataMsg().Payload == <span class="literal">nil</span> &#123;</div><div class="line">				gc.logger.Warning(<span class="string">"Payload is empty, got it from"</span>, msg.GetConnectionInfo().ID)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Would this block go into the message store if it was verified?</span></div><div class="line">			<span class="keyword">if</span> !gc.blockMsgStore.CheckValid(msg.GetGossipMessage()) &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> !gc.verifyBlock(m.GossipMessage, msg.GetConnectionInfo().ID) &#123;</div><div class="line">				gc.logger.Warning(<span class="string">"Failed verifying block"</span>, m.GetDataMsg().Payload.SeqNum)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			added = gc.blockMsgStore.Add(msg.GetGossipMessage())</div><div class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// StateInfoMsg verification should be handled in a layer above</span></div><div class="line">			<span class="comment">//  since we don't have access to the id mapper here</span></div><div class="line">			added = gc.stateInfoMsgStore.Add(msg.GetGossipMessage())</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> added &#123;</div><div class="line">			<span class="comment">// Forward the message</span></div><div class="line">			gc.Forward(msg)</div><div class="line">			<span class="comment">// DeMultiplex to local subscribers</span></div><div class="line">			gc.DeMultiplex(m)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> m.IsDataMsg() &#123;</div><div class="line">				gc.blocksPuller.Add(msg.GetGossipMessage())</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 即 hello, digest, req, res 这类消息</span></div><div class="line">	<span class="keyword">if</span> m.IsPullMsg() &amp;&amp; m.GetPullMsgType() == proto.PullMsgType_BLOCK_MSG &#123;</div><div class="line">		<span class="keyword">if</span> gc.hasLeftChannel() &#123;</div><div class="line">			gc.logger.Info(<span class="string">"Received Pull message from"</span>, msg.GetConnectionInfo().Endpoint, <span class="string">"but left the channel"</span>, <span class="keyword">string</span>(gc.chainID))</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// If we don't have a StateInfo message from the peer,</span></div><div class="line">		<span class="comment">// no way of validating its eligibility in the channel.</span></div><div class="line">		<span class="keyword">if</span> gc.stateInfoMsgStore.MsgByID(msg.GetConnectionInfo().ID) == <span class="literal">nil</span> &#123;</div><div class="line">			gc.logger.Debug(<span class="string">"Don't have StateInfo message of peer"</span>, msg.GetConnectionInfo())</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> !gc.eligibleForChannelAndSameOrg(discovery.NetworkMember&#123;PKIid: msg.GetConnectionInfo().ID&#125;) &#123;</div><div class="line">			gc.logger.Warning(msg.GetConnectionInfo(), <span class="string">"isn't eligible for pulling blocks of"</span>, <span class="keyword">string</span>(gc.chainID))</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 即 res 这个消息</span></div><div class="line">		<span class="keyword">if</span> m.IsDataUpdate() &#123;</div><div class="line">			<span class="comment">// Iterate over the envelopes, and filter out blocks</span></div><div class="line">			<span class="comment">// that we already have in the blockMsgStore, or blocks that</span></div><div class="line">			<span class="comment">// are too far in the past.</span></div><div class="line">			filteredEnvelopes := []*proto.Envelope&#123;&#125;</div><div class="line">			<span class="keyword">for</span> _, item := <span class="keyword">range</span> m.GetDataUpdate().Data &#123;</div><div class="line">				gMsg, err := item.ToGossipMessage()</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					gc.logger.Warningf(<span class="string">"Data update contains an invalid message: %+v"</span>, errors.WithStack(err))</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> !bytes.Equal(gMsg.Channel, []<span class="keyword">byte</span>(gc.chainID)) &#123;</div><div class="line">					gc.logger.Warning(<span class="string">"DataUpdate message contains item with channel"</span>, gMsg.Channel, <span class="string">"but should be"</span>, gc.chainID)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="comment">// Would this block go into the message store if it was verified?</span></div><div class="line">				<span class="keyword">if</span> !gc.blockMsgStore.CheckValid(msg.GetGossipMessage()) &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> !gc.verifyBlock(gMsg.GossipMessage, msg.GetConnectionInfo().ID) &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				added := gc.blockMsgStore.Add(gMsg)</div><div class="line">				<span class="keyword">if</span> !added &#123;</div><div class="line">					<span class="comment">// If this block doesn't need to be added, it means it either already</span></div><div class="line">					<span class="comment">// exists in memory or that it is too far in the past</span></div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125;</div><div class="line">				filteredEnvelopes = <span class="built_in">append</span>(filteredEnvelopes, item)</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Replace the update message with just the blocks that should be processed</span></div><div class="line">			m.GetDataUpdate().Data = filteredEnvelopes</div><div class="line">		&#125;</div><div class="line">		gc.blocksPuller.HandleMessage(msg)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.IsLeadershipMsg() &#123;</div><div class="line">		<span class="comment">// Handling leadership message</span></div><div class="line">		added := gc.leaderMsgStore.Add(m)</div><div class="line">		<span class="keyword">if</span> added &#123;</div><div class="line">			gc.DeMultiplex(m)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>gossipChannel</code> 中的 <code>Adapter</code> 是为了调用 <code>gossipServiceImpl</code> 的接口，定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Adapter enables the gossipChannel</span></div><div class="line"><span class="comment">// to communicate with gossipServiceImpl.</span></div><div class="line"><span class="keyword">type</span> Adapter <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// GetConf returns the configuration that this GossipChannel will posses</span></div><div class="line">	GetConf() Config</div><div class="line"></div><div class="line">	<span class="comment">// Gossip gossips a message in the channel</span></div><div class="line">	Gossip(message *proto.SignedGossipMessage)</div><div class="line"></div><div class="line">	<span class="comment">// Forward sends a message to the next hops</span></div><div class="line">	Forward(message proto.ReceivedMessage)</div><div class="line"></div><div class="line">	<span class="comment">// DeMultiplex de-multiplexes an item to subscribers</span></div><div class="line">	DeMultiplex(<span class="keyword">interface</span>&#123;&#125;)</div><div class="line"></div><div class="line">	<span class="comment">// GetMembership returns the known alive peers and their information</span></div><div class="line">	GetMembership() []discovery.NetworkMember</div><div class="line"></div><div class="line">	<span class="comment">// Lookup returns a network member, or nil if not found</span></div><div class="line">	Lookup(PKIID common.PKIidType) *discovery.NetworkMember</div><div class="line"></div><div class="line">	<span class="comment">// Send sends a message to a list of peers</span></div><div class="line">	Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer)</div><div class="line"></div><div class="line">	<span class="comment">// ValidateStateInfoMessage returns an error if a message</span></div><div class="line">	<span class="comment">// hasn't been signed correctly, nil otherwise.</span></div><div class="line">	ValidateStateInfoMessage(message *proto.SignedGossipMessage) error</div><div class="line"></div><div class="line">	<span class="comment">// GetOrgOfPeer returns the organization ID of a given peer PKI-ID</span></div><div class="line">	GetOrgOfPeer(pkiID common.PKIidType) api.OrgIdentityType</div><div class="line"></div><div class="line">	<span class="comment">// GetIdentityByPKIID returns an identity of a peer with a certain</span></div><div class="line">	<span class="comment">// pkiID, or nil if not found</span></div><div class="line">	GetIdentityByPKIID(pkiID common.PKIidType) api.PeerIdentityType</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Adapter</code> 接口的实现类 <code>gossipAdapterImpl</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> gossipAdapterImpl <span class="keyword">struct</span> &#123;</div><div class="line">	*gossipServiceImpl</div><div class="line">	discovery.Discovery</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例如 <code>gossipAdapterImpl.Gossip</code> 的实现就是调用 <code>gossipServiceImpl</code> 的相关方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Gossip gossips a message</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ga *gossipAdapterImpl)</span> <span class="title">Gossip</span><span class="params">(msg *proto.SignedGossipMessage)</span></span> &#123;</div><div class="line">	ga.gossipServiceImpl.emitter.Add(&amp;emittedGossipMessage&#123;</div><div class="line">		SignedGossipMessage: msg,</div><div class="line">		filter: <span class="function"><span class="keyword">func</span><span class="params">(_ common.PKIidType)</span> <span class="title">bool</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">		&#125;,</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>gossipServiceImpl.InitializeChannel</code> 方法中，会调用 <code>NewGossipStateProvider</code> 创建该通道的 <code>GossipStateProvider</code> 对象（后面分析这个对象的作用）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGossipStateProvider</span><span class="params">(chainID <span class="keyword">string</span>, services *ServicesMediator, ledger ledgerResources)</span> <span class="title">GossipStateProvider</span></span> &#123;</div><div class="line"></div><div class="line">	gossipChan, _ := services.Accept(<span class="function"><span class="keyword">func</span><span class="params">(message <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line">		<span class="comment">// Get only data messages</span></div><div class="line">		<span class="keyword">return</span> message.(*proto.GossipMessage).IsDataMsg() &amp;&amp;</div><div class="line">			bytes.Equal(message.(*proto.GossipMessage).Channel, []<span class="keyword">byte</span>(chainID))</div><div class="line">	&#125;, <span class="literal">false</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 省略 ...</span></div><div class="line"></div><div class="line">	<span class="comment">// Listen for incoming communication</span></div><div class="line">	<span class="keyword">go</span> s.listen()</div><div class="line"></div><div class="line">	<span class="comment">// Deliver in order messages into the incoming channel</span></div><div class="line">	<span class="keyword">go</span> s.deliverPayloads()</div><div class="line"></div><div class="line">	<span class="comment">// 省略 ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该函数中的 <code>ServicesMediator</code> 类型定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServicesMediator aggregated adapter to compound all mediator</span></div><div class="line"><span class="comment">// required by state transfer into single struct</span></div><div class="line"><span class="keyword">type</span> ServicesMediator <span class="keyword">struct</span> &#123;</div><div class="line">	GossipAdapter</div><div class="line">	MCSAdapter</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// GossipAdapter defines gossip/communication required interface for state provider</span></div><div class="line"><span class="keyword">type</span> GossipAdapter <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// Send sends a message to remote peers</span></div><div class="line">	Send(msg *proto.GossipMessage, peers ...*comm.RemotePeer)</div><div class="line"></div><div class="line">	<span class="comment">// Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.</span></div><div class="line">	<span class="comment">// If passThrough is false, the messages are processed by the gossip layer beforehand.</span></div><div class="line">	<span class="comment">// If passThrough is true, the gossip layer doesn't intervene and the messages</span></div><div class="line">	<span class="comment">// can be used to send a reply back to the sender</span></div><div class="line">	Accept(acceptor common2.MessageAcceptor, passThrough <span class="keyword">bool</span>) (&lt;-<span class="keyword">chan</span> *proto.GossipMessage, &lt;-<span class="keyword">chan</span> proto.ReceivedMessage)</div><div class="line"></div><div class="line">	<span class="comment">// UpdateChannelMetadata updates the self metadata the peer</span></div><div class="line">	<span class="comment">// publishes to other peers about its channel-related state</span></div><div class="line">	UpdateChannelMetadata(metadata []<span class="keyword">byte</span>, chainID common2.ChainID)</div><div class="line"></div><div class="line">	<span class="comment">// PeersOfChannel returns the NetworkMembers considered alive</span></div><div class="line">	<span class="comment">// and also subscribed to the channel given</span></div><div class="line">	PeersOfChannel(common2.ChainID) []discovery.NetworkMember</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>GossipAdapter</code> 接口的实现类型即为 <code>gossipServiceImpl</code>，因此其 <code>Accept</code> 方法如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.</span></div><div class="line"><span class="comment">// If passThrough is false, the messages are processed by the gossip layer beforehand.</span></div><div class="line"><span class="comment">// If passThrough is true, the gossip layer doesn't intervene and the messages</span></div><div class="line"><span class="comment">// can be used to send a reply back to the sender</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *gossipServiceImpl)</span> <span class="title">Accept</span><span class="params">(acceptor common.MessageAcceptor, passThrough <span class="keyword">bool</span>)</span> <span class="params">(&lt;-<span class="keyword">chan</span> *proto.GossipMessage, &lt;-<span class="keyword">chan</span> proto.ReceivedMessage)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> passThrough &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, g.comm.Accept(acceptor)</div><div class="line">	&#125;</div><div class="line">	acceptByType := <span class="function"><span class="keyword">func</span><span class="params">(o <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> o, isGossipMsg := o.(*proto.GossipMessage); isGossipMsg &#123;</div><div class="line">			<span class="keyword">return</span> acceptor(o)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> o, isSignedMsg := o.(*proto.SignedGossipMessage); isSignedMsg &#123;</div><div class="line">			sMsg := o</div><div class="line">			<span class="keyword">return</span> acceptor(sMsg.GossipMessage)</div><div class="line">		&#125;</div><div class="line">		g.logger.Warning(<span class="string">"Message type:"</span>, reflect.TypeOf(o), <span class="string">"cannot be evaluated"</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">	inCh := g.AddChannel(acceptByType)  <span class="comment">// 关键部分</span></div><div class="line">	outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *proto.GossipMessage, acceptChanSize)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> s := &lt;-g.toDieChan:</div><div class="line">				g.toDieChan &lt;- s</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> m := &lt;-inCh:</div><div class="line">				<span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				outCh &lt;- m.(*proto.SignedGossipMessage).GossipMessage</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> outCh, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>g.AddChannel</code> 方法是内嵌在 <code>gossipServiceImpl</code> 类型中的 <code>ChannelDeMultiplexer</code> 类型的方法，定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AddChannel registers a channel with a certain predicate</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ChannelDeMultiplexer)</span> <span class="title">AddChannel</span><span class="params">(predicate common.MessageAcceptor)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">	m.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> m.lock.Unlock()</div><div class="line">	ch := &amp;channel&#123;ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>), pred: predicate&#125;</div><div class="line">	m.channels = <span class="built_in">append</span>(m.channels, ch)</div><div class="line">	<span class="keyword">return</span> ch.ch</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DeMultiplex broadcasts the message to all channels that were returned</span></div><div class="line"><span class="comment">// by AddChannel calls and that hold the respected predicates.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ChannelDeMultiplexer)</span> <span class="title">DeMultiplex</span><span class="params">(msg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="built_in">recover</span>()</div><div class="line">	&#125;() <span class="comment">// recover from sending on a closed channel</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.isClosed() &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	m.lock.RLock()</div><div class="line">	channels := m.channels</div><div class="line">	m.lock.RUnlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> channels &#123;</div><div class="line">		<span class="keyword">if</span> ch.pred(msg) &#123;</div><div class="line">			ch.ch &lt;- msg</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此每次调用 <code>DeMultiplex</code> 派发消息时，会发送给符合对应 <code>predicate</code> 的通道     </p>
<p>其中 <code>s.listen</code> 方法定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GossipStateProviderImpl)</span> <span class="title">listen</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> s.done.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> msg := &lt;-s.gossipChan:   <span class="comment">// 这就是 AddChannel 后返回的通道 chan</span></div><div class="line">			logger.Debug(<span class="string">"Received new message via gossip channel"</span>)</div><div class="line">			<span class="keyword">go</span> s.queueNewMessage(msg)</div><div class="line">		<span class="keyword">case</span> msg := &lt;-s.commChan:</div><div class="line">			logger.Debug(<span class="string">"Dispatching a message"</span>, msg)</div><div class="line">			<span class="keyword">go</span> s.dispatch(msg)</div><div class="line">		<span class="keyword">case</span> &lt;-s.stopCh:</div><div class="line">			s.stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">			logger.Debug(<span class="string">"Stop listening for new messages"</span>)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>s.queueNewMessage</code> 就是将消息 push 到 <code>payloads</code> 对象中 （<code>PayloadsBuffer</code> 接口）     </p>
<p>而 <code>s.deliverPayloads</code> 就是不断的从 <code>payloads</code> 对象中读取数据，commit 到本地账本中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GossipStateProviderImpl)</span> <span class="title">deliverPayloads</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> s.done.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="comment">// Wait for notification that next seq has arrived</span></div><div class="line">		<span class="keyword">case</span> &lt;-s.payloads.Ready():</div><div class="line">			logger.Debugf(<span class="string">"Ready to transfer payloads to the ledger, next sequence number is = [%d]"</span>, s.payloads.Next())</div><div class="line">			<span class="comment">// Collect all subsequent payloads</span></div><div class="line">			<span class="keyword">for</span> payload := s.payloads.Pop(); payload != <span class="literal">nil</span>; payload = s.payloads.Pop() &#123;</div><div class="line">				rawBlock := &amp;common.Block&#123;&#125;</div><div class="line">				<span class="keyword">if</span> err := pb.Unmarshal(payload.Data, rawBlock); err != <span class="literal">nil</span> &#123;</div><div class="line">					logger.Errorf(<span class="string">"Error getting block with seqNum = %d due to (%+v)...dropping block"</span>, payload.SeqNum, errors.WithStack(err))</div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> rawBlock.Data == <span class="literal">nil</span> || rawBlock.Header == <span class="literal">nil</span> &#123;</div><div class="line">					logger.Errorf(<span class="string">"Block with claimed sequence %d has no header (%v) or data (%v)"</span>,</div><div class="line">						payload.SeqNum, rawBlock.Header, rawBlock.Data)</div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125;</div><div class="line">				logger.Debug(<span class="string">"New block with claimed sequence number "</span>, payload.SeqNum, <span class="string">" transactions num "</span>, <span class="built_in">len</span>(rawBlock.Data.Data))</div><div class="line"></div><div class="line">				<span class="comment">// Read all private data into slice</span></div><div class="line">				<span class="keyword">var</span> p util.PvtDataCollections</div><div class="line">				<span class="keyword">if</span> payload.PrivateData != <span class="literal">nil</span> &#123;</div><div class="line">					err := p.Unmarshal(payload.PrivateData)</div><div class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">						logger.Errorf(<span class="string">"Wasn't able to unmarshal private data for block seqNum = %d due to (%+v)...dropping block"</span>, payload.SeqNum, errors.WithStack(err))</div><div class="line">						<span class="keyword">continue</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> err := s.commitBlock(rawBlock, p); err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">if</span> executionErr, isExecutionErr := err.(*vsccErrors.VSCCExecutionFailureError); isExecutionErr &#123;</div><div class="line">						logger.Errorf(<span class="string">"Failed executing VSCC due to %v. Aborting chain processing"</span>, executionErr)</div><div class="line">						<span class="keyword">return</span></div><div class="line">					&#125;</div><div class="line">					logger.Panicf(<span class="string">"Cannot commit block to the ledger due to %+v"</span>, errors.WithStack(err))</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">case</span> &lt;-s.stopCh:</div><div class="line">			s.stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">			logger.Debug(<span class="string">"State provider has been stopped, finishing to push new blocks."</span>)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>目前看来 fabric gossip 既有 push，又有 pull</strong>      </p>
<h1 id="fabric-中私密数据的保护"><a href="#fabric-中私密数据的保护" class="headerlink" title="fabric 中私密数据的保护"></a>fabric 中私密数据的保护</h1><p><a href="https://blog.csdn.net/yeasy/article/details/80366828" target="_blank" rel="external">发展过程</a>     </p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#peer-启动后是如何获取-channel-中的-block-？"><span class="toc-number">1.</span> <span class="toc-text">peer 启动后是如何获取 channel 中的 block ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Merkle-tree"><span class="toc-number">2.</span> <span class="toc-text">Merkle tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vscc-校验交易过程"><span class="toc-number">3.</span> <span class="toc-text">vscc 校验交易过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#commit-block-过程"><span class="toc-number">4.</span> <span class="toc-text">commit block 过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gossip-协议介绍"><span class="toc-number">5.</span> <span class="toc-text">Gossip 协议介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fabric-中的-pull-based-gossip-实现"><span class="toc-number">6.</span> <span class="toc-text">Fabric 中的 pull-based gossip 实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-中私密数据的保护"><span class="toc-number">7.</span> <span class="toc-text">fabric 中私密数据的保护</span></a></li></ol>
    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 Landleany
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


