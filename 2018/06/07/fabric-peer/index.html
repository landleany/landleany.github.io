<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="peer 启动后是如何获取 channel 中的 block ？首先，peer node start 时，会初始化 gossipService，我们可以通过 service.GetGossipService() 方法获取全局对象 gossipService。下面介绍下该对象的结构：    12345678910111213141516171819202122232425262728// 接口如下t">
<meta property="og:type" content="article">
<meta property="og:title" content="fabric-peer">
<meta property="og:url" content="http://yoursite.com/2018/06/07/fabric-peer/index.html">
<meta property="og:site_name" content="Drip">
<meta property="og:description" content="peer 启动后是如何获取 channel 中的 block ？首先，peer node start 时，会初始化 gossipService，我们可以通过 service.GetGossipService() 方法获取全局对象 gossipService。下面介绍下该对象的结构：    12345678910111213141516171819202122232425262728// 接口如下t">
<meta property="og:updated_time" content="2018-07-20T09:11:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fabric-peer">
<meta name="twitter:description" content="peer 启动后是如何获取 channel 中的 block ？首先，peer node start 时，会初始化 gossipService，我们可以通过 service.GetGossipService() 方法获取全局对象 gossipService。下面介绍下该对象的结构：    12345678910111213141516171819202122232425262728// 接口如下t">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>fabric-peer</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2018/06/22/network/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/05/03/fabric-policy/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2018/06/07/fabric-peer/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2018/06/07/fabric-peer/&text=fabric-peer"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2018/06/07/fabric-peer/&is_video=false&description=fabric-peer"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=fabric-peer&body=Check out this article: http://yoursite.com/2018/06/07/fabric-peer/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2018/06/07/fabric-peer/&title=fabric-peer"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2018/06/07/fabric-peer/&name=fabric-peer&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#peer-启动后是如何获取-channel-中的-block-？"><span class="toc-number">1.</span> <span class="toc-text">peer 启动后是如何获取 channel 中的 block ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Merkle-tree"><span class="toc-number">2.</span> <span class="toc-text">Merkle tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vscc-校验交易过程"><span class="toc-number">3.</span> <span class="toc-text">vscc 校验交易过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#commit-block-过程"><span class="toc-number">4.</span> <span class="toc-text">commit block 过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gossip-协议介绍"><span class="toc-number">5.</span> <span class="toc-text">Gossip 协议介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fabric-中的-pull-based-gossip-实现"><span class="toc-number">6.</span> <span class="toc-text">Fabric 中的 pull-based gossip 实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-中私密数据的保护"><span class="toc-number">7.</span> <span class="toc-text">fabric 中私密数据的保护</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#发送-private-data-过程"><span class="toc-number">8.</span> <span class="toc-text">发送 private data 过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gossip-comm"><span class="toc-number">9.</span> <span class="toc-text">gossip/comm</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#protos-gossip-message-pb-go"><span class="toc-number">10.</span> <span class="toc-text">protos/gossip/message.pb.go</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据流"><span class="toc-number">11.</span> <span class="toc-text">数据流</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        fabric-peer
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Drip</span>
      </span>
      
    <div class="postdate">
        <time datetime="2018-06-07T05:30:30.000Z" itemprop="datePublished">2018-06-07</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="peer-启动后是如何获取-channel-中的-block-？"><a href="#peer-启动后是如何获取-channel-中的-block-？" class="headerlink" title="peer 启动后是如何获取 channel 中的 block ？"></a>peer 启动后是如何获取 channel 中的 block ？</h1><p>首先，<code>peer node start</code> 时，会初始化 <code>gossipService</code>，我们可以通过 <code>service.GetGossipService()</code> 方法获取全局对象 <code>gossipService</code>。下面介绍下该对象的结构：   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 接口如下</span></div><div class="line"><span class="keyword">type</span> GossipService <span class="keyword">interface</span> &#123;</div><div class="line">	gossip.Gossip</div><div class="line"></div><div class="line">	<span class="comment">// DistributePrivateData distributes private data to the peers in the collections</span></div><div class="line">	<span class="comment">// according to policies induced by the PolicyStore and PolicyParser</span></div><div class="line">	DistributePrivateData(chainID <span class="keyword">string</span>, txID <span class="keyword">string</span>, privateData *rwset.TxPvtReadWriteSet) error</div><div class="line">	<span class="comment">// NewConfigEventer creates a ConfigProcessor which the channelconfig.BundleSource can ultimately route config updates to</span></div><div class="line">	NewConfigEventer() ConfigProcessor</div><div class="line">	<span class="comment">// InitializeChannel allocates the state provider and should be invoked once per channel per execution</span></div><div class="line">	InitializeChannel(chainID <span class="keyword">string</span>, endpoints []<span class="keyword">string</span>, support Support) </div><div class="line">	<span class="comment">// AddPayload appends message payload to for given chain</span></div><div class="line">	AddPayload(chainID <span class="keyword">string</span>, payload *gproto.Payload) error</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现如下</span></div><div class="line"><span class="keyword">type</span> gossipServiceImpl <span class="keyword">struct</span> &#123;</div><div class="line">	gossipSvc</div><div class="line">	privateHandlers <span class="keyword">map</span>[<span class="keyword">string</span>]privateHandler</div><div class="line">	chains          <span class="keyword">map</span>[<span class="keyword">string</span>]state.GossipStateProvider</div><div class="line">	leaderElection  <span class="keyword">map</span>[<span class="keyword">string</span>]election.LeaderElectionService</div><div class="line">	deliveryService <span class="keyword">map</span>[<span class="keyword">string</span>]deliverclient.DeliverService</div><div class="line">	deliveryFactory DeliveryServiceFactory</div><div class="line">	lock            sync.RWMutex</div><div class="line">	mcs             api.MessageCryptoService</div><div class="line">	peerIdentity    []<span class="keyword">byte</span></div><div class="line">	secAdv          api.SecurityAdvisor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续，当我们调用 <code>peer channel join</code> 这条命令时，其实是调用了系统合约 <code>cscc (channel system chaincode)</code> 中的 <code>joinChannel</code> 方法，该方法会调用 <code>createChain</code> 方法，该方法在 gossipService 中初始化了一个通道对象，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">createChain</span><span class="params">(cid <span class="keyword">string</span>, ledger ledger.PeerLedger, cb *common.Block)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="comment">// 省略 ...</span></div><div class="line">    service.GetGossipService().InitializeChannel(bundle.ConfigtxValidator().ChainID(), ordererAddresses, service.Support&#123;</div><div class="line">        Validator: validator,</div><div class="line">        Committer: c,</div><div class="line">        Store:     store,</div><div class="line">        Cs:        simpleCollectionStore,</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 省略 ...</span></div></pre></td></tr></table></figure>
<p><code>gossipService</code> 的 <code>InitializeChannel</code> 方法会在该对象内部的 <code>deliveryService: map[string]deliverclient.DeliverService</code> 字典中插入该通道名的 <code>DeliverService</code>，该对象结构如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> DeliverService <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// StartDeliverForChannel dynamically starts delivery of new blocks from ordering service</span></div><div class="line">	<span class="comment">// to channel peers.</span></div><div class="line">	<span class="comment">// When the delivery finishes, the finalizer func is called</span></div><div class="line">	StartDeliverForChannel(chainID <span class="keyword">string</span>, ledgerInfo blocksprovider.LedgerInfo, finalizer <span class="function"><span class="keyword">func</span><span class="params">()</span>) <span class="title">error</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">	// <span class="title">StopDeliverForChannel</span> <span class="title">dynamically</span> <span class="title">stops</span> <span class="title">delivery</span> <span class="title">of</span> <span class="title">new</span> <span class="title">blocks</span> <span class="title">from</span> <span class="title">ordering</span> <span class="title">service</span></span></div><div class="line"><span class="function">	// <span class="title">to</span> <span class="title">channel</span> <span class="title">peers</span>.</span></div><div class="line"><span class="function">	<span class="title">StopDeliverForChannel</span><span class="params">(chainID <span class="keyword">string</span>)</span> <span class="title">error</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">	// <span class="title">UpdateEndpoints</span></span></div><div class="line"><span class="function">	<span class="title">UpdateEndpoints</span><span class="params">(chainID <span class="keyword">string</span>, endpoints []<span class="keyword">string</span>)</span> <span class="title">error</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">	// <span class="title">Stop</span> <span class="title">terminates</span> <span class="title">delivery</span> <span class="title">service</span> <span class="title">and</span> <span class="title">closes</span> <span class="title">the</span> <span class="title">connection</span></span></div><div class="line"><span class="function">	<span class="title">Stop</span><span class="params">()</span></span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure></p>
<p>然后，<code>leaderElection := viper.GetBool(&quot;peer.gossip.useLeaderElection&quot;)</code> 以及 <code>isStaticOrgLeader := viper.GetBool(&quot;peer.gossip.orgLeader&quot;)</code>，这两个变量是互斥的，如果 <code>leaderElection</code> 为真，则开始 gossip 选举 leader，否则如果 <code>isStaticOrgLeader</code> 为真，则调用 <code>g.deliveryService[chainID].StartDeliverForChannel</code> 开始拉块。<br>而 <code>StartDeliverForChannel</code> 方法最终调用到 <code>func (b *blocksProviderImpl) DeliverBlocks()</code> 方法（位于：github.com/hyperledger/fabric/core/deliverservice/blocksprovider/blocksprovider.go）       </p>
<p>然后调用 <code>blocksProviderImpl.gossip.Gossip(msp)</code> 发送刚刚通过 deliver 获取的区块。其中的 <code>gossip</code> 对象的接口定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> GossipServiceAdapter <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// PeersOfChannel returns slice with members of specified channel</span></div><div class="line">	PeersOfChannel(gossipcommon.ChainID) []discovery.NetworkMember</div><div class="line"></div><div class="line">	<span class="comment">// AddPayload adds payload to the local state sync buffer</span></div><div class="line">	AddPayload(chainID <span class="keyword">string</span>, payload *gossip_proto.Payload) error</div><div class="line"></div><div class="line">	<span class="comment">// Gossip the message across the peers</span></div><div class="line">	Gossip(msg *gossip_proto.GossipMessage)</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">`      </span></div><div class="line"><span class="string">具体实现如下 (github.com/hyperledger/fabric/gossip/gossip/gossip_impl.go)： </span></div><div class="line"><span class="string">`</span><span class="string">``</span> <span class="keyword">go</span></div><div class="line"><span class="keyword">type</span> gossipServiceImpl <span class="keyword">struct</span> &#123;</div><div class="line">	selfIdentity          api.PeerIdentityType</div><div class="line">	includeIdentityPeriod time.Time</div><div class="line">	certStore             *certStore</div><div class="line">	idMapper              identity.Mapper</div><div class="line">	presumedDead          <span class="keyword">chan</span> common.PKIidType</div><div class="line">	disc                  discovery.Discovery</div><div class="line">	comm                  comm.Comm</div><div class="line">	incTime               time.Time</div><div class="line">	selfOrg               api.OrgIdentityType</div><div class="line">	*comm.ChannelDeMultiplexer</div><div class="line">	logger            *logging.Logger</div><div class="line">	stopSignal        *sync.WaitGroup</div><div class="line">	conf              *Config</div><div class="line">	toDieChan         <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	stopFlag          <span class="keyword">int32</span></div><div class="line">	emitter           batchingEmitter</div><div class="line">	discAdapter       *discoveryAdapter</div><div class="line">	secAdvisor        api.SecurityAdvisor</div><div class="line">	chanState         *channelState</div><div class="line">	disSecAdap        *discoverySecurityAdapter</div><div class="line">	mcs               api.MessageCryptoService</div><div class="line">	stateInfoMsgStore msgstore.MessageStore</div><div class="line">	certPuller        pull.Mediator</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在创建 <code>gossipServiceImpl</code> 时，会初始化 <code>emitter</code> 字段，类型为 <code>batchingEmitter</code>:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> batchingEmitter <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// Add adds a message to be batched</span></div><div class="line">	Add(<span class="keyword">interface</span>&#123;&#125;)</div><div class="line">	<span class="comment">// Stop stops the component</span></div><div class="line">	Stop()</div><div class="line">	<span class="comment">// Size returns the amount of pending messages to be emitted</span></div><div class="line">	Size() <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iterations: 每条数据发送的次数</span></div><div class="line"><span class="comment">// Add() 后，如果信息条数达到 burstSize，则自动 emit()</span></div><div class="line"><span class="comment">// 如果超过 latency 时间，也会 emit()</span></div><div class="line"><span class="comment">// cb 才是真正发送的函数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newBatchingEmitter</span><span class="params">(iterations, burstSize <span class="keyword">int</span>, latency time.Duration, cb emitBatchCallback)</span> <span class="title">batchingEmitter</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> iterations &lt; <span class="number">0</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(errors.Errorf(<span class="string">"Got a negative iterations number"</span>))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	p := &amp;batchingEmitterImpl&#123;</div><div class="line">		cb:         cb,</div><div class="line">		delay:      latency,</div><div class="line">		iterations: iterations,</div><div class="line">		burstSize:  burstSize,</div><div class="line">		lock:       &amp;sync.Mutex&#123;&#125;,</div><div class="line">		buff:       <span class="built_in">make</span>([]*batchedMessage, <span class="number">0</span>),</div><div class="line">		stopFlag:   <span class="keyword">int32</span>(<span class="number">0</span>),</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> iterations != <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">go</span> p.periodicEmit() <span class="comment">// 以 latency 为间隔，调用 cb 发送数据</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> p</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>newBatchingEmitter</code> 中传入的 <code>cb emitBatchCallback</code> 是 <code>sendGossipBatch</code>，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *gossipServiceImpl)</span> <span class="title">sendGossipBatch</span><span class="params">(a []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	msgs2Gossip := <span class="built_in">make</span>([]*emittedGossipMessage, <span class="built_in">len</span>(a))</div><div class="line">	<span class="keyword">for</span> i, e := <span class="keyword">range</span> a &#123;</div><div class="line">		msgs2Gossip[i] = e.(*emittedGossipMessage)</div><div class="line">	&#125;</div><div class="line">	g.gossipBatch(msgs2Gossip)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终调用发送：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Send the messages to the remote peers</span></div><div class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> messagesOfChannel &#123;</div><div class="line">    filteredPeers := g.removeSelfLoop(msg, peers2Send)</div><div class="line">    g.comm.Send(msg.SignedGossipMessage, filteredPeers...)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，<code>g.comm</code>，接口定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Comm <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// GetPKIid returns this instance's PKI id</span></div><div class="line">	GetPKIid() common.PKIidType</div><div class="line">	<span class="comment">// Send sends a message to remote peers</span></div><div class="line">	Send(msg *proto.SignedGossipMessage, peers ...*RemotePeer)</div><div class="line">	<span class="comment">// SendWithAck sends a message to remote peers, waiting for acknowledgement from minAck of them, or until a certain timeout expires</span></div><div class="line">	SendWithAck(msg *proto.SignedGossipMessage, timeout time.Duration, minAck <span class="keyword">int</span>, peers ...*RemotePeer) AggregatedSendResult</div><div class="line">	<span class="comment">// Probe probes a remote node and returns nil if its responsive,</span></div><div class="line">	<span class="comment">// and an error if it's not.</span></div><div class="line">	Probe(peer *RemotePeer) error</div><div class="line">	<span class="comment">// Handshake authenticates a remote peer and returns</span></div><div class="line">	<span class="comment">// (its identity, nil) on success and (nil, error)</span></div><div class="line">	Handshake(peer *RemotePeer) (api.PeerIdentityType, error)</div><div class="line">	<span class="comment">// Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.</span></div><div class="line">	<span class="comment">// Each message from the channel can be used to send a reply back to the sender</span></div><div class="line">	Accept(common.MessageAcceptor) &lt;-<span class="keyword">chan</span> proto.ReceivedMessage  </div><div class="line">	<span class="comment">// PresumedDead returns a read-only channel for node endpoints that are suspected to be offline</span></div><div class="line">	PresumedDead() &lt;-<span class="keyword">chan</span> common.PKIidType</div><div class="line">	<span class="comment">// CloseConn closes a connection to a certain endpoint</span></div><div class="line">	CloseConn(peer *RemotePeer)</div><div class="line">	<span class="comment">// Stop stops the module</span></div><div class="line">	Stop()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用工厂方法创建 <code>Comm</code>，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewCommInstance creates a new comm instance that binds itself to the given gRPC server</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCommInstance</span><span class="params">(s *grpc.Server, certs *common.TLSCertificates, idStore identity.Mapper,</span></span></div><div class="line"><span class="function"><span class="params">	peerIdentity api.PeerIdentityType, secureDialOpts api.PeerSecureDialOpts,</span></span></div><div class="line"><span class="function"><span class="params">	dialOpts ...grpc.DialOption)</span> <span class="params">(Comm, error)</span></span> &#123;</div><div class="line"></div><div class="line">	commInst, err := NewCommInstanceWithServer(<span class="number">-1</span>, idStore, peerIdentity, secureDialOpts, dialOpts...)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithStack(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	commInst.(*commImpl).tlsCerts = certs</div><div class="line">	proto.RegisterGossipServer(s, commInst.(*commImpl))</div><div class="line"></div><div class="line">	<span class="keyword">return</span> commInst, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>Comm</code> 的实现类 <code>commImpl</code>，有个 <code>createConnection</code> 方法，用来创建 <code>gossipClient</code>，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *commImpl)</span> <span class="title">createConnection</span><span class="params">(endpoint <span class="keyword">string</span>, expectedPKIID common.PKIidType)</span> <span class="params">(*connection, error)</span></span> &#123;</div><div class="line">    <span class="comment">// 省略 ...</span></div><div class="line">    cl := proto.NewGossipClient(cc)</div><div class="line">    stream, err = cl.GossipStream(ctx)</div><div class="line">    <span class="comment">// 省略 ...</span></div><div class="line">	<span class="comment">// 这个函数是 conn 接收到数据后的处理函数</span></div><div class="line">	h := <span class="function"><span class="keyword">func</span><span class="params">(m *proto.SignedGossipMessage)</span></span> &#123;</div><div class="line">		c.logger.Debug(<span class="string">"Got message:"</span>, m)</div><div class="line">		c.msgPublisher.DeMultiplex(&amp;ReceivedMessageImpl&#123;</div><div class="line">			conn:                conn,</div><div class="line">			lock:                conn,</div><div class="line">			SignedGossipMessage: m,</div><div class="line">			connInfo:            connInfo,</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 省略 ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>commImpl.Send()</code> 方法只是把值放入到了 chan 中，内部有个协程不断的取出来并调用 <code>stream.Send()</code> 发送       </p>
<p>上面的 <code>msgPublisher</code> 是一个 Pub/Sub 模块，类型是 <code>ChannelDeMultiplexer</code>，存在于 <code>commImpl</code> 的结构体中   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ChannelDeMultiplexer is a struct that can receive channel registrations (AddChannel)</span></div><div class="line"><span class="comment">// and publications (DeMultiplex) and it broadcasts the publications to registrations</span></div><div class="line"><span class="comment">// according to their predicate</span></div><div class="line"><span class="keyword">type</span> ChannelDeMultiplexer <span class="keyword">struct</span> &#123;</div><div class="line">	channels []*channel</div><div class="line">	lock     *sync.RWMutex</div><div class="line">	closed   <span class="keyword">int32</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 注册监听者</span></div><div class="line"><span class="comment">// AddChannel registers a channel with a certain predicate</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ChannelDeMultiplexer)</span> <span class="title">AddChannel</span><span class="params">(predicate common.MessageAcceptor)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">	m.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> m.lock.Unlock()</div><div class="line">	ch := &amp;channel&#123;ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>), pred: predicate&#125;</div><div class="line">	m.channels = <span class="built_in">append</span>(m.channels, ch)</div><div class="line">	<span class="keyword">return</span> ch.ch</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 发送数据</span></div><div class="line"><span class="comment">// DeMultiplex broadcasts the message to all channels that were returned</span></div><div class="line"><span class="comment">// by AddChannel calls and that hold the respected predicates.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ChannelDeMultiplexer)</span> <span class="title">DeMultiplex</span><span class="params">(msg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="built_in">recover</span>()</div><div class="line">	&#125;() <span class="comment">// recover from sending on a closed channel</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.isClosed() &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	m.lock.RLock()</div><div class="line">	channels := m.channels</div><div class="line">	m.lock.RUnlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> channels &#123;</div><div class="line">		<span class="keyword">if</span> ch.pred(msg) &#123;</div><div class="line">			ch.ch &lt;- msg</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>Comm interface</code> <code>commImpl struct</code> 的 <code>Accept</code> 方法，传入一个 msg 过滤器，返回一个通道，从这个通道可以获取所有符合该过滤器的 gossip 消息，Accept 方法就是调用 <code>ChannelDeMultiplexer</code> 的 <code>AddChannel</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="string">``</span><span class="string">`</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">当 `</span>NewGossipService()<span class="string">` 创建全局的对象时，会调用 `</span><span class="keyword">go</span> g.start()<span class="string">` 开启数据监听处理函数，而 start 方法中</span></div><div class="line"><span class="string">`</span><span class="string">``</span> <span class="keyword">go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *gossipServiceImpl)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">go</span> g.syncDiscovery()</div><div class="line">	<span class="keyword">go</span> g.handlePresumedDead()</div><div class="line"></div><div class="line">	msgSelector := <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line">		gMsg, isGossipMsg := msg.(proto.ReceivedMessage)</div><div class="line">		<span class="keyword">if</span> !isGossipMsg &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">		isConn := gMsg.GetGossipMessage().GetConn() != <span class="literal">nil</span></div><div class="line">		isEmpty := gMsg.GetGossipMessage().GetEmpty() != <span class="literal">nil</span></div><div class="line">		isPrivateData := gMsg.GetGossipMessage().IsPrivateDataMsg()</div><div class="line"></div><div class="line">		<span class="keyword">return</span> !(isConn || isEmpty || isPrivateData)</div><div class="line">	&#125;</div><div class="line">	incMsgs := g.comm.Accept(msgSelector) <span class="comment">// 这里调用了 Accept 方法，加入了数据监听者，过滤得到非连接、非空、非private数据</span></div><div class="line">	<span class="keyword">go</span> g.acceptMessages(incMsgs)  <span class="comment">// 处理得到的数据</span></div><div class="line">	g.logger.Info(<span class="string">"Gossip instance"</span>, g.conf.ID, <span class="string">"started"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>gossipServiceImpl.acceptMesages</code> 调用 <code>gossipServiceImpl.handleMessage</code>，然后它继续调用 <code>GossipChannel</code> 接口的 <code>HandleMessage</code> 处理消息。    </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GossipChannel 处理通道相关的 gossip 消息</span></div><div class="line"><span class="comment">// GossipChannel defines an object that deals with all channel-related messages</span></div><div class="line"><span class="keyword">type</span> GossipChannel <span class="keyword">interface</span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">// GetPeers returns a list of peers with metadata as published by them</span></div><div class="line">	GetPeers() []discovery.NetworkMember</div><div class="line"></div><div class="line">	<span class="comment">// PeerFilter receives a SubChannelSelectionCriteria and returns a RoutingFilter that selects</span></div><div class="line">	<span class="comment">// only peer identities that match the given criteria</span></div><div class="line">	PeerFilter(api.SubChannelSelectionCriteria) filter.RoutingFilter</div><div class="line"></div><div class="line">	<span class="comment">// IsMemberInChan checks whether the given member is eligible to be in the channel</span></div><div class="line">	IsMemberInChan(member discovery.NetworkMember) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// UpdateStateInfo updates this channel's StateInfo message</span></div><div class="line">	<span class="comment">// that is periodically published</span></div><div class="line">	UpdateStateInfo(msg *proto.SignedGossipMessage)</div><div class="line"></div><div class="line">	<span class="comment">// IsOrgInChannel returns whether the given organization is in the channel</span></div><div class="line">	IsOrgInChannel(membersOrg api.OrgIdentityType) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// EligibleForChannel returns whether the given member should get blocks</span></div><div class="line">	<span class="comment">// for this channel</span></div><div class="line">	EligibleForChannel(member discovery.NetworkMember) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// HandleMessage processes a message sent by a remote peer</span></div><div class="line">	HandleMessage(proto.ReceivedMessage)</div><div class="line"></div><div class="line">	<span class="comment">// AddToMsgStore adds a given GossipMessage to the message store</span></div><div class="line">	AddToMsgStore(msg *proto.SignedGossipMessage)</div><div class="line"></div><div class="line">	<span class="comment">// ConfigureChannel (re)configures the list of organizations</span></div><div class="line">	<span class="comment">// that are eligible to be in the channel</span></div><div class="line">	ConfigureChannel(joinMsg api.JoinChannelMessage)</div><div class="line"></div><div class="line">	<span class="comment">// LeaveChannel makes the peer leave the channel</span></div><div class="line">	LeaveChannel()</div><div class="line"></div><div class="line">	<span class="comment">// Stop stops the channel's activity</span></div><div class="line">	Stop()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>GossipChannel</code> 是保存在 <code>gossipService</code> 的 <code>channelState</code> 的 map 字典中，其 <code>HandleMessage</code> 方法，将数据加入（Add() 方法）到 <code>MessageStore</code> 中，使用 <code>gossipChannel</code> 中一个结构体变量 <code>blockMsgStore</code>，类型为 <code>MessageStore</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MessageStore 是一个起缓冲作用的对象</span></div><div class="line"><span class="keyword">type</span> MessageStore <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// add adds a message to the store</span></div><div class="line">	<span class="comment">// returns true or false whether the message was added to the store</span></div><div class="line">	Add(msg <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// Checks if message is valid for insertion to store</span></div><div class="line">	<span class="comment">// returns true or false whether the message can be added to the store</span></div><div class="line">	CheckValid(msg <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span></div><div class="line"></div><div class="line">	<span class="comment">// size returns the amount of messages in the store</span></div><div class="line">	Size() <span class="keyword">int</span></div><div class="line"></div><div class="line">	<span class="comment">// get returns all messages in the store</span></div><div class="line">	Get() []<span class="keyword">interface</span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Stop all associated go routines</span></div><div class="line">	Stop()</div><div class="line"></div><div class="line">	<span class="comment">// Purge purges all messages that are accepted by</span></div><div class="line">	<span class="comment">// the given predicate</span></div><div class="line">	Purge(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure></p>
<p><code>GossipStateProvider</code> </p>
<h1 id="Merkle-tree"><a href="#Merkle-tree" class="headerlink" title="Merkle tree"></a>Merkle tree</h1><p><a href="http://www.zhibimo.com/read/wang-miao/mastering-bitcoin/Chapter07.html" target="_blank" rel="external">不错的介绍</a>     </p>
<p>比特币每个区块头部都有一个 <code>Merkle tree root</code>，而不是 <code>所有交易 hash 值的总 hash 值（这同等与整个区块内容的 hash 值）</code>，为了快速方便 <code>验证一个交易（hash）是否存在于该区块中</code>。如果采用 <code>所有交易 hash 值的总 hash 值（或区块内容的 hash 值）</code> 的方式，则为了验证一个交易是否存在，首先得计算该交易的 hash 值，然后获得该区块内 <strong>所有交易</strong> 的 hash 值/或是拉取 <strong>整个区块内容</strong>（这是因为首先要验证获取的区块内容（所有交易）是否与区块头中的 hash 一致，这很重要，因为只有区块头部的 hash 值才是用户信任的源头）。 而如果采用 <code>Merkle tree root</code> 的方式，则只要获得 <strong>log(n)</strong> 个交易的 hash 值（只要有一条分支到达 root 即可），实现简单支付验证（SPV）       </p>
<p>另外 Merkle tree 的作用是快速的比较数据部分内容是否不一致</p>
<h1 id="vscc-校验交易过程"><a href="#vscc-校验交易过程" class="headerlink" title="vscc 校验交易过程"></a>vscc 校验交易过程</h1><h1 id="commit-block-过程"><a href="#commit-block-过程" class="headerlink" title="commit block 过程"></a>commit block 过程</h1><p><code>NewCommonStorageDBProvider</code></p>
<p><code>PeerLedgerProvider</code> 是一个工厂，产生 <code>PeerLedger</code>，它包括了操作 <code>账本</code>、<code>世界状态</code> 等数据的对象。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PeerLedgerProvider <span class="keyword">interface</span> &#123;</div><div class="line">	Initialize(statelisteners StateListeners)</div><div class="line">	<span class="comment">// Create creates a new ledger with the given genesis block.</span></div><div class="line">	<span class="comment">// This function guarantees that the creation of ledger and committing the genesis block would an atomic action</span></div><div class="line">	<span class="comment">// The chain id retrieved from the genesis block is treated as a ledger id</span></div><div class="line">	Create(genesisBlock *common.Block) (PeerLedger, error)</div><div class="line">	<span class="comment">// Open opens an already created ledger</span></div><div class="line">	Open(ledgerID <span class="keyword">string</span>) (PeerLedger, error)</div><div class="line">	<span class="comment">// Exists tells whether the ledger with given id exists</span></div><div class="line">	Exists(ledgerID <span class="keyword">string</span>) (<span class="keyword">bool</span>, error)</div><div class="line">	<span class="comment">// List lists the ids of the existing ledgers</span></div><div class="line">	List() ([]<span class="keyword">string</span>, error)</div><div class="line">	<span class="comment">// Close closes the PeerLedgerProvider</span></div><div class="line">	Close()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>PeerLedger</code> 的接口如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PeerLedger <span class="keyword">interface</span> &#123;</div><div class="line">	commonledger.Ledger</div><div class="line">	<span class="comment">// GetTransactionByID retrieves a transaction by id</span></div><div class="line">	GetTransactionByID(txID <span class="keyword">string</span>) (*peer.ProcessedTransaction, error)</div><div class="line">	<span class="comment">// GetBlockByHash returns a block given it's hash</span></div><div class="line">	GetBlockByHash(blockHash []<span class="keyword">byte</span>) (*common.Block, error)</div><div class="line">	<span class="comment">// GetBlockByTxID returns a block which contains a transaction</span></div><div class="line">	GetBlockByTxID(txID <span class="keyword">string</span>) (*common.Block, error)</div><div class="line">	<span class="comment">// GetTxValidationCodeByTxID returns reason code of transaction validation</span></div><div class="line">	GetTxValidationCodeByTxID(txID <span class="keyword">string</span>) (peer.TxValidationCode, error)</div><div class="line">	<span class="comment">// NewTxSimulator gives handle to a transaction simulator.</span></div><div class="line">	<span class="comment">// A client can obtain more than one 'TxSimulator's for parallel execution.</span></div><div class="line">	<span class="comment">// Any snapshoting/synchronization should be performed at the implementation level if required</span></div><div class="line">	NewTxSimulator(txid <span class="keyword">string</span>) (TxSimulator, error)</div><div class="line">	<span class="comment">// NewQueryExecutor gives handle to a query executor.</span></div><div class="line">	<span class="comment">// A client can obtain more than one 'QueryExecutor's for parallel execution.</span></div><div class="line">	<span class="comment">// Any synchronization should be performed at the implementation level if required</span></div><div class="line">	NewQueryExecutor() (QueryExecutor, error)</div><div class="line">	<span class="comment">// NewHistoryQueryExecutor gives handle to a history query executor.</span></div><div class="line">	<span class="comment">// A client can obtain more than one 'HistoryQueryExecutor's for parallel execution.</span></div><div class="line">	<span class="comment">// Any synchronization should be performed at the implementation level if required</span></div><div class="line">	NewHistoryQueryExecutor() (HistoryQueryExecutor, error)</div><div class="line">	<span class="comment">// GetPvtDataAndBlockByNum returns the block and the corresponding pvt data.</span></div><div class="line">	<span class="comment">// The pvt data is filtered by the list of 'ns/collections' supplied</span></div><div class="line">	<span class="comment">// A nil filter does not filter any results and causes retrieving all the pvt data for the given blockNum</span></div><div class="line">	GetPvtDataAndBlockByNum(blockNum <span class="keyword">uint64</span>, filter PvtNsCollFilter) (*BlockAndPvtData, error)</div><div class="line">	<span class="comment">// GetPvtDataByNum returns only the pvt data  corresponding to the given block number</span></div><div class="line">	<span class="comment">// The pvt data is filtered by the list of 'ns/collections' supplied in the filter</span></div><div class="line">	<span class="comment">// A nil filter does not filter any results and causes retrieving all the pvt data for the given blockNum</span></div><div class="line">	GetPvtDataByNum(blockNum <span class="keyword">uint64</span>, filter PvtNsCollFilter) ([]*TxPvtData, error)</div><div class="line">	<span class="comment">// CommitWithPvtData commits the block and the corresponding pvt data in an atomic operation</span></div><div class="line">	CommitWithPvtData(blockAndPvtdata *BlockAndPvtData) error</div><div class="line">	<span class="comment">// Purge removes private read-writes set generated by endorsers at block height lesser than</span></div><div class="line">	<span class="comment">// a given maxBlockNumToRetain. In other words, Purge only retains private read-write sets</span></div><div class="line">	<span class="comment">// that were generated at block height of maxBlockNumToRetain or higher.</span></div><div class="line">	PurgePrivateData(maxBlockNumToRetain <span class="keyword">uint64</span>) error</div><div class="line">	<span class="comment">// PrivateDataMinBlockNum returns the lowest retained endorsement block height</span></div><div class="line">	PrivateDataMinBlockNum() (<span class="keyword">uint64</span>, error)</div><div class="line">	<span class="comment">//Prune prunes the blocks/transactions that satisfy the given policy</span></div><div class="line">	Prune(policy commonledger.PrunePolicy) error</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>PeerLedgerProvider</code> 的实现类 <code>Provider</code> 产生 <code>PeerLedger</code> 的代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(provider *Provider)</span> <span class="title">openInternal</span><span class="params">(ledgerID <span class="keyword">string</span>)</span> <span class="params">(ledger.PeerLedger, error)</span></span> &#123;</div><div class="line">	<span class="comment">// Get the block store for a chain/ledger</span></div><div class="line">	<span class="comment">// blockStore 中包含 账本 和 私有账本</span></div><div class="line">	blockStore, err := provider.ledgerStoreProvider.Open(ledgerID)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Get the versioned database (state database) for a chain/ledger</span></div><div class="line">	<span class="comment">// 操作 state db，即世界状态</span></div><div class="line">	<span class="comment">// 世界状态也会存储 私有数据</span></div><div class="line">	vDB, err := provider.vdbProvider.GetDBHandle(ledgerID) </div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Get the history database (index for history of values by key) for a chain/ledger</span></div><div class="line">	historyDB, err := provider.historydbProvider.GetDBHandle(ledgerID)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Create a kvLedger for this chain/ledger, which encasulates the underlying data stores</span></div><div class="line">	<span class="comment">// (id store, blockstore, state database, history database)</span></div><div class="line">	<span class="comment">// kvLedger 就是 PeerLedger 接口的实现类</span></div><div class="line">	l, err := newKVLedger(ledgerID, blockStore, vDB, historyDB, provider.stateListeners)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> l, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>KVLedger</code> 的创建过程，中间会创建 <code>TxMgr</code>，就是 simulator，操作 世界状态数据库的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewKVLedger constructs new `KVLedger`</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newKVLedger</span><span class="params">(ledgerID <span class="keyword">string</span>, blockStore *ledgerstorage.Store,</span></span></div><div class="line"><span class="function"><span class="params">	versionedDB privacyenabledstate.DB, historyDB historydb.HistoryDB,</span></span></div><div class="line"><span class="function"><span class="params">	stateListeners ledger.StateListeners)</span> <span class="params">(*kvLedger, error)</span></span> &#123;</div><div class="line"></div><div class="line">	logger.Debugf(<span class="string">"Creating KVLedger ledgerID=%s: "</span>, ledgerID)</div><div class="line"></div><div class="line">	<span class="comment">//Initialize transaction manager using state database</span></div><div class="line">	<span class="keyword">var</span> txmgmt txmgr.TxMgr</div><div class="line">	<span class="comment">// 在这里传入 世界状态的 DB handler，产生一个 txmgr</span></div><div class="line">	txmgmt = lockbasedtxmgr.NewLockBasedTxMgr(ledgerID, versionedDB, stateListeners)</div><div class="line"></div><div class="line">	<span class="comment">// Create a kvLedger for this chain/ledger, which encasulates the underlying</span></div><div class="line">	<span class="comment">// id store, blockstore, txmgr (state database), history database</span></div><div class="line">	l := &amp;kvLedger&#123;ledgerID, blockStore, txmgmt, historyDB, &amp;sync.RWMutex&#123;&#125;&#125;</div><div class="line"></div><div class="line">	<span class="comment">// TODO Move the function `GetChaincodeEventListener` to ledger interface and</span></div><div class="line">	<span class="comment">// this functionality of regiserting for events to ledgermgmt package so that this</span></div><div class="line">	<span class="comment">// is reused across other future ledger implementations</span></div><div class="line">	ccEventListener := versionedDB.GetChaincodeEventListener()</div><div class="line">	logger.Debugf(<span class="string">"Register state db for chaincode lifecycle events: %t"</span>, ccEventListener != <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> ccEventListener != <span class="literal">nil</span> &#123;</div><div class="line">		cceventmgmt.GetMgr().Register(ledgerID, ccEventListener)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//Recover both state DB and history DB if they are out of sync with block storage</span></div><div class="line">	<span class="keyword">if</span> err := l.recoverDBs(); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">`Error during state DB recovery:%s`</span>, err))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> l, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过一个全局方法就可以获得对应通道的 <code>PeerLedger</code>，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetLedger</span><span class="params">(cid <span class="keyword">string</span>)</span> <span class="title">ledger</span>.<span class="title">PeerLedger</span></span> &#123;</div><div class="line">	chains.RLock()</div><div class="line">	<span class="keyword">defer</span> chains.RUnlock()</div><div class="line">	<span class="keyword">if</span> c, ok := chains.list[cid]; ok &#123;</div><div class="line">		<span class="keyword">return</span> c.cs.ledger</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>kvLedger</code> 是 <code>ledger.PeerLedger</code> 的实现类<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> kvLedger <span class="keyword">struct</span> &#123;</div><div class="line">	ledgerID        <span class="keyword">string</span></div><div class="line">	blockStore      *ledgerstorage.Store</div><div class="line">	txtmgmt         txmgr.TxMgr</div><div class="line">	historyDB       historydb.HistoryDB</div><div class="line">	blockAPIsRWLock *sync.RWMutex</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Gossip-协议介绍"><a href="#Gossip-协议介绍" class="headerlink" title="Gossip 协议介绍"></a>Gossip 协议介绍</h1><p><a href="http://kaiyuan.me/2015/07/08/Gossip/" target="_blank" rel="external">链接</a><br>同步时间是集群规模的对数时间，也叫“反熵”算法。<br>应用 gossip 的应用有：Cassandra     </p>
<h1 id="Fabric-中的-pull-based-gossip-实现"><a href="#Fabric-中的-pull-based-gossip-实现" class="headerlink" title="Fabric 中的 pull-based gossip 实现"></a>Fabric 中的 pull-based gossip 实现</h1><p><a href="https://blog.csdn.net/idsuf698987/article/details/77948977" target="_blank" rel="external">很好的文档</a><br>首先介绍 <code>PullEngine</code> 是底层的算法实现，不考虑数据的存储和计算，内部存的是数据的摘要，结构体如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PullEngine is the component that actually invokes the pull algorithm</span></div><div class="line"><span class="comment">// with the help of the PullAdapter</span></div><div class="line"><span class="comment">// 底层的功能实现，与上层具体数据结构解耦，与业务相关的实现交由 PullAdapter 接口实现</span></div><div class="line"><span class="keyword">type</span> PullEngine <span class="keyword">struct</span> &#123;</div><div class="line">	PullAdapter        <span class="comment">// 这个比较关键，是个接口（算法的上层数据结构实现），可以替换具体的实现，默认实现见下方介绍</span></div><div class="line">	stopFlag           <span class="keyword">int32</span></div><div class="line">	state              *util.Set   <span class="comment">// 不涉及具体的数据结构，只是存储其字符串类型的摘要</span></div><div class="line">	item2owners        <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>  <span class="comment">// map[摘要][]&#123;回应该摘要的peer列表&#125;</span></div><div class="line">	peers2nonces       <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>    <span class="comment">// map[peer]nonce</span></div><div class="line">	nonces2peers       <span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">string</span>    <span class="comment">// map[nonce]peer</span></div><div class="line">	acceptingDigests   <span class="keyword">int32</span>   <span class="comment">// 标志位，表示是否开始接收摘要</span></div><div class="line">	acceptingResponses <span class="keyword">int32</span>   <span class="comment">// 标志位，表示是否开始接收数据</span></div><div class="line">	lock               sync.Mutex</div><div class="line">	outgoingNONCES     *util.Set   <span class="comment">// 发出的 nonce 集合</span></div><div class="line">	incomingNONCES     *util.Set   <span class="comment">// 接收的 nonce 集合</span></div><div class="line">	digFilter          DigestFilter  <span class="comment">// 摘要过滤器生产工厂</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建 <code>PullEngine</code> 对象时，会启动一个协程，如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewPullEngineWithFilter creates an instance of a PullEngine with a certain sleep time</span></div><div class="line"><span class="comment">// between pull initiations, and uses the given filters when sending digests and responses</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPullEngineWithFilter</span><span class="params">(participant PullAdapter, sleepTime time.Duration, df DigestFilter)</span> *<span class="title">PullEngine</span></span> &#123;</div><div class="line">	engine := &amp;PullEngine&#123;</div><div class="line">		PullAdapter:        participant,</div><div class="line">		stopFlag:           <span class="keyword">int32</span>(<span class="number">0</span>),</div><div class="line">		state:              util.NewSet(),</div><div class="line">		item2owners:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>),</div><div class="line">		peers2nonces:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>),</div><div class="line">		nonces2peers:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">string</span>),</div><div class="line">		acceptingDigests:   <span class="keyword">int32</span>(<span class="number">0</span>),</div><div class="line">		acceptingResponses: <span class="keyword">int32</span>(<span class="number">0</span>),</div><div class="line">		incomingNONCES:     util.NewSet(),</div><div class="line">		outgoingNONCES:     util.NewSet(),</div><div class="line">		digFilter:          df,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> !engine.toDie() &#123;</div><div class="line">			time.Sleep(sleepTime)</div><div class="line">			<span class="keyword">if</span> engine.toDie() &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			engine.initiatePull()  <span class="comment">// 间隔发送 pull，拉取其他节点上的数据</span></div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> engine</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">initiatePull</span><span class="params">()</span></span> &#123;</div><div class="line">	engine.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> engine.lock.Unlock()</div><div class="line"></div><div class="line">	engine.acceptDigests()</div><div class="line">	<span class="keyword">for</span> _, peer := <span class="keyword">range</span> engine.SelectPeers() &#123;</div><div class="line">		nonce := engine.newNONCE()</div><div class="line">		engine.outgoingNONCES.Add(nonce)</div><div class="line">		engine.nonces2peers[nonce] = peer</div><div class="line">		engine.peers2nonces[peer] = nonce</div><div class="line">		engine.Hello(peer, nonce)   <span class="comment">// Hello 就是一个 pull 请求，收到 Hello 的节点会发送自己所有的摘要列表</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	digestWaitTime := util.GetDurationOrDefault(<span class="string">"peer.gossip.digestWaitTime"</span>, defDigestWaitTime)</div><div class="line">	time.AfterFunc(digestWaitTime, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		engine.processIncomingDigests()</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OnHello notifies the engine a hello has arrived</span></div><div class="line"><span class="comment">// 其实就是当 pull 请求到达后，发送所有满足过滤条件的摘要回去（从 state 集合中获取摘要），</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">OnHello</span><span class="params">(nonce <span class="keyword">uint64</span>, context <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	engine.incomingNONCES.Add(nonce)</div><div class="line"></div><div class="line">	requestWaitTime := util.GetDurationOrDefault(<span class="string">"peer.gossip.requestWaitTime"</span>, defRequestWaitTime)</div><div class="line">	time.AfterFunc(requestWaitTime, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		engine.incomingNONCES.Remove(nonce)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	a := engine.state.ToArray()</div><div class="line">	<span class="keyword">var</span> digest []<span class="keyword">string</span></div><div class="line">	filter := engine.digFilter(context)</div><div class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> a &#123;</div><div class="line">		dig := item.(<span class="keyword">string</span>)</div><div class="line">		<span class="keyword">if</span> !filter(dig) &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line">		digest = <span class="built_in">append</span>(digest, dig)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(digest) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	engine.SendDigest(digest, nonce, context)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OnDigest notifies the engine that a digest has arrived</span></div><div class="line"><span class="comment">// 实现就是当收到某个节点传回的摘要列表后，整理一下，归类同一个摘要的所有发送源（节点）信息，存于 item2owners 中</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">OnDigest</span><span class="params">(digest []<span class="keyword">string</span>, nonce <span class="keyword">uint64</span>, context <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !engine.isAcceptingDigests() || !engine.outgoingNONCES.Exists(nonce) &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	engine.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> engine.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> digest &#123;</div><div class="line">		<span class="keyword">if</span> engine.state.Exists(n) &#123;</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> _, exists := engine.item2owners[n]; !exists &#123;</div><div class="line">			engine.item2owners[n] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		engine.item2owners[n] = <span class="built_in">append</span>(engine.item2owners[n], engine.nonces2peers[nonce])</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 <code>initiatePull</code> 中可知，发送 <code>Hello</code> 的一段时间后，会调用 <code>engine.processIncomingDigests</code>，如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据 item2owners 字典，整理出某个远程节点上，需要请求的摘要列表，存于 requestMapping 字典中</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">processIncomingDigests</span><span class="params">()</span></span> &#123;</div><div class="line">	engine.ignoreDigests()</div><div class="line"></div><div class="line">	engine.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> engine.lock.Unlock()</div><div class="line"></div><div class="line">	requestMapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</div><div class="line">	<span class="keyword">for</span> n, sources := <span class="keyword">range</span> engine.item2owners &#123;</div><div class="line">		<span class="comment">// select a random source</span></div><div class="line">		source := sources[util.RandomInt(<span class="built_in">len</span>(sources))]</div><div class="line">		<span class="keyword">if</span> _, exists := requestMapping[source]; !exists &#123;</div><div class="line">			requestMapping[source] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// append the number to that source</span></div><div class="line">		requestMapping[source] = <span class="built_in">append</span>(requestMapping[source], n)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	engine.acceptResponses()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> dest, seqsToReq := <span class="keyword">range</span> requestMapping &#123;</div><div class="line">		engine.SendReq(dest, seqsToReq, engine.peers2nonces[dest])  <span class="comment">// 请求节点，获取它上面 seqsToReq 列表里摘要所对应的数据</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	responseWaitTime := util.GetDurationOrDefault(<span class="string">"peer.gossip.responseWaitTime"</span>, defResponseWaitTime)</div><div class="line">	time.AfterFunc(responseWaitTime, engine.endPull)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OnReq notifies the engine a request has arrived</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">OnReq</span><span class="params">(items []<span class="keyword">string</span>, nonce <span class="keyword">uint64</span>, context <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !engine.incomingNONCES.Exists(nonce) &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	engine.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> engine.lock.Unlock()</div><div class="line"></div><div class="line">	filter := engine.digFilter(context)</div><div class="line">	<span class="keyword">var</span> items2Send []<span class="keyword">string</span></div><div class="line">	<span class="comment">// 获取满足过滤条件，且存在于当前节点的摘要列表</span></div><div class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</div><div class="line">		<span class="keyword">if</span> engine.state.Exists(item) &amp;&amp; filter(item) &#123;</div><div class="line">			items2Send = <span class="built_in">append</span>(items2Send, item)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(items2Send) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 关键点，调用 PullAdapter 接口的 SendRes 方法，传入的是 摘要列表，该方法内部应该会根据摘要获取真实数据并发送</span></div><div class="line">	<span class="keyword">go</span> engine.SendRes(items2Send, context, nonce)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OnRes notifies the engine a response has arrived</span></div><div class="line"><span class="comment">// 更新自身的 state 集合，上层业务相关的处理在 PullAdapter 中处理，并不在该函数中！</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *PullEngine)</span> <span class="title">OnRes</span><span class="params">(items []<span class="keyword">string</span>, nonce <span class="keyword">uint64</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !engine.outgoingNONCES.Exists(nonce) || !engine.isAcceptingResponses() &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	engine.Add(items...) <span class="comment">// 新的摘要加入 state 集合</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PullAdapter</code> 接口的实现类如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> pullMediatorImpl <span class="keyword">struct</span> &#123;</div><div class="line">	sync.RWMutex</div><div class="line">	*PullAdapter</div><div class="line">	msgType2Hook <span class="keyword">map</span>[MsgType][]MessageHook</div><div class="line">	config       Config</div><div class="line">	logger       *logging.Logger</div><div class="line">	itemID2Msg   <span class="keyword">map</span>[<span class="keyword">string</span>]*proto.SignedGossipMessage</div><div class="line">	engine       *algo.PullEngine</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PullAdapter defines methods of the pullStore to interact</span></div><div class="line"><span class="comment">// with various modules of gossip</span></div><div class="line"><span class="keyword">type</span> PullAdapter <span class="keyword">struct</span> &#123;</div><div class="line">	Sndr             Sender   </div><div class="line">	MemSvc           MembershipService    <span class="comment">// 获取 peer 节点信息</span></div><div class="line">	IdExtractor      proto.IdentifierExtractor   <span class="comment">// 根据 gossipMsg 获取对应摘要</span></div><div class="line">	MsgCons          proto.MsgConsumer  </div><div class="line">	EgressDigFilter  EgressDigestFilter</div><div class="line">	IngressDigFilter IngressDigestFilter</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其 <code>SendRes</code> 方法实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SendRes sends an array of items to a remote PullEngine identified by a context.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pullMediatorImpl)</span> <span class="title">SendRes</span><span class="params">(items []<span class="keyword">string</span>, context <span class="keyword">interface</span>&#123;&#125;, nonce <span class="keyword">uint64</span>)</span></span> &#123;</div><div class="line">	items2return := []*proto.Envelope&#123;&#125;</div><div class="line">	p.RLock()</div><div class="line">	<span class="keyword">defer</span> p.RUnlock()</div><div class="line">	<span class="comment">// 根据传入的摘要列表，获取需要发送的数据实体，存于 items2return</span></div><div class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</div><div class="line">		<span class="keyword">if</span> msg, exists := p.itemID2Msg[item]; exists &#123;</div><div class="line">			items2return = <span class="built_in">append</span>(items2return, msg.Envelope)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	returnedUpdate := &amp;proto.GossipMessage&#123;</div><div class="line">		Channel: p.config.Channel,</div><div class="line">		Tag:     p.config.Tag,</div><div class="line">		Nonce:   <span class="number">0</span>,</div><div class="line">		Content: &amp;proto.GossipMessage_DataUpdate&#123;</div><div class="line">			DataUpdate: &amp;proto.DataUpdate&#123;</div><div class="line">				MsgType: p.config.MsgType,</div><div class="line">				Nonce:   nonce,</div><div class="line">				Data:    items2return,</div><div class="line">			&#125;,</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">	remotePeer := context.(proto.ReceivedMessage).GetConnectionInfo()</div><div class="line">	p.logger.Debug(<span class="string">"Sending"</span>, <span class="built_in">len</span>(returnedUpdate.GetDataUpdate().Data), p.config.MsgType, <span class="string">"items to"</span>, remotePeer)</div><div class="line">	context.(proto.ReceivedMessage).Respond(returnedUpdate)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pullMediatorImpl.HandleMessage</code> 是调用底层 <code>PullEngine</code> 中 <code>onHello</code>，<code>onDigest</code>，<code>onReq</code>，<code>onReq</code> 的 handler 方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pullMediatorImpl)</span> <span class="title">HandleMessage</span><span class="params">(m proto.ReceivedMessage)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> m.GetGossipMessage() == <span class="literal">nil</span> || !m.GetGossipMessage().IsPullMsg() &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	msg := m.GetGossipMessage()</div><div class="line">	msgType := msg.GetPullMsgType()</div><div class="line">	<span class="keyword">if</span> msgType != p.config.MsgType &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	p.logger.Debug(msg)</div><div class="line"></div><div class="line">	itemIDs := []<span class="keyword">string</span>&#123;&#125;</div><div class="line">	items := []*proto.SignedGossipMessage&#123;&#125;</div><div class="line">	<span class="keyword">var</span> pullMsgType MsgType</div><div class="line"></div><div class="line">	<span class="keyword">if</span> helloMsg := msg.GetHello(); helloMsg != <span class="literal">nil</span> &#123;</div><div class="line">		pullMsgType = HelloMsgType</div><div class="line">		p.engine.OnHello(helloMsg.Nonce, m)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> digest := msg.GetDataDig(); digest != <span class="literal">nil</span> &#123;</div><div class="line">		d := p.PullAdapter.IngressDigFilter(digest)</div><div class="line">		itemIDs = d.Digests</div><div class="line">		pullMsgType = DigestMsgType</div><div class="line">		p.engine.OnDigest(d.Digests, d.Nonce, m)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> req := msg.GetDataReq(); req != <span class="literal">nil</span> &#123;</div><div class="line">		itemIDs = req.Digests</div><div class="line">		pullMsgType = RequestMsgType</div><div class="line">		p.engine.OnReq(req.Digests, req.Nonce, m)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> res := msg.GetDataUpdate(); res != <span class="literal">nil</span> &#123;</div><div class="line">		itemIDs = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(res.Data))</div><div class="line">		items = <span class="built_in">make</span>([]*proto.SignedGossipMessage, <span class="built_in">len</span>(res.Data))</div><div class="line">		pullMsgType = ResponseMsgType</div><div class="line">		<span class="keyword">for</span> i, pulledMsg := <span class="keyword">range</span> res.Data &#123;</div><div class="line">			msg, err := pulledMsg.ToGossipMessage()</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				p.logger.Warningf(<span class="string">"Data update contains an invalid message: %+v"</span>, errors.WithStack(err))</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			p.MsgCons(msg)</div><div class="line">			itemIDs[i] = p.IdExtractor(msg)</div><div class="line">			items[i] = msg</div><div class="line">			p.Lock()</div><div class="line">			p.itemID2Msg[itemIDs[i]] = msg</div><div class="line">			p.Unlock()</div><div class="line">		&#125;</div><div class="line">		p.engine.OnRes(itemIDs, res.Nonce)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Invoke hooks for relevant message type</span></div><div class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> p.hooksByMsgType(pullMsgType) &#123;</div><div class="line">		h(itemIDs, items, m)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>GossipChannel（接口定义见上面）</code> 的实现类如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> gossipChannel <span class="keyword">struct</span> &#123;</div><div class="line">	Adapter</div><div class="line">	sync.RWMutex</div><div class="line">	shouldGossipStateInfo     <span class="keyword">int32</span></div><div class="line">	mcs                       api.MessageCryptoService</div><div class="line">	pkiID                     common.PKIidType</div><div class="line">	selfOrg                   api.OrgIdentityType</div><div class="line">	stopChan                  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</div><div class="line">	stateInfoMsg              *proto.SignedGossipMessage</div><div class="line">	orgs                      []api.OrgIdentityType</div><div class="line">	joinMsg                   api.JoinChannelMessage</div><div class="line">	blockMsgStore             msgstore.MessageStore</div><div class="line">	stateInfoMsgStore         *stateInfoCache</div><div class="line">	leaderMsgStore            msgstore.MessageStore</div><div class="line">	chainID                   common.ChainID</div><div class="line">	blocksPuller              pull.Mediator   <span class="comment">// 这个是 pullMediatorImpl </span></div><div class="line">	logger                    *logging.Logger</div><div class="line">	stateInfoPublishScheduler *time.Ticker</div><div class="line">	stateInfoRequestScheduler *time.Ticker</div><div class="line">	memFilter                 *membershipFilter</div><div class="line">	ledgerHeight              <span class="keyword">uint64</span></div><div class="line">	leftChannel               <span class="keyword">int32</span></div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span> <span class="keyword">go</span></div><div class="line"><span class="keyword">type</span> Mediator <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// Stop stop the Mediator</span></div><div class="line">	Stop()</div><div class="line">	<span class="comment">// RegisterMsgHook registers a message hook to a specific type of pull message</span></div><div class="line">	RegisterMsgHook(MsgType, MessageHook)</div><div class="line">	<span class="comment">// Add adds a GossipMessage to the Mediator</span></div><div class="line">	Add(*proto.SignedGossipMessage)</div><div class="line">	<span class="comment">// Remove removes a GossipMessage from the Mediator with a matching digest,</span></div><div class="line">	<span class="comment">// if such a message exits</span></div><div class="line">	Remove(digest <span class="keyword">string</span>)</div><div class="line">	<span class="comment">// HandleMessage handles a message from some remote peer</span></div><div class="line">	HandleMessage(msg proto.ReceivedMessage)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在创建 <code>gossipChannel</code> 对象时，会创建 <code>pullMediatorImpl</code> 对象( <code>blocksPuller</code> 字段 )，该对象会用 <code>NewPullEngineWithFilter</code>方法初始化内部的 <code>engine</code> 字段，产生 <code>PullEngine</code> 对象的同时，也会运行一个协程 <code>engine.initiatePull()</code> 不断的拉取（发送 <code>Hello()</code>）        </p>
<p><code>gossipChannel.HandleMessage</code> 是数据入口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HandleMessage processes a message sent by a remote peer</span></div><div class="line"><span class="comment">// 一开始会检查消息的正确性，发送方的组织是否在 channel 中等等</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gc *gossipChannel)</span> <span class="title">HandleMessage</span><span class="params">(msg proto.ReceivedMessage)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !gc.verifyMsg(msg) &#123;</div><div class="line">		gc.logger.Warning(<span class="string">"Failed verifying message:"</span>, msg.GetGossipMessage().GossipMessage)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	m := msg.GetGossipMessage()</div><div class="line">	<span class="keyword">if</span> !m.IsChannelRestricted() &#123;</div><div class="line">		gc.logger.Warning(<span class="string">"Got message"</span>, msg.GetGossipMessage(), <span class="string">"but it's not a per-channel message, discarding it"</span>)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	orgID := gc.GetOrgOfPeer(msg.GetConnectionInfo().ID)</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(orgID) == <span class="number">0</span> &#123;</div><div class="line">		gc.logger.Debug(<span class="string">"Couldn't find org identity of peer"</span>, msg.GetConnectionInfo())</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> !gc.IsOrgInChannel(orgID) &#123;</div><div class="line">		gc.logger.Warning(<span class="string">"Point to point message came from"</span>, msg.GetConnectionInfo(),</div><div class="line">			<span class="string">", org("</span>, <span class="keyword">string</span>(orgID), <span class="string">") but it's not eligible for the channel"</span>, <span class="keyword">string</span>(gc.chainID))</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.IsStateInfoPullRequestMsg() &#123;</div><div class="line">		msg.Respond(gc.createStateInfoSnapshot(orgID))</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.IsStateInfoSnapshot() &#123;</div><div class="line">		gc.handleStateInfSnapshot(m.GossipMessage, msg.GetConnectionInfo().ID)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.IsDataMsg() || m.IsStateInfoMsg() &#123;</div><div class="line">		added := <span class="literal">false</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> m.IsDataMsg() &#123;</div><div class="line">			<span class="keyword">if</span> m.GetDataMsg().Payload == <span class="literal">nil</span> &#123;</div><div class="line">				gc.logger.Warning(<span class="string">"Payload is empty, got it from"</span>, msg.GetConnectionInfo().ID)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Would this block go into the message store if it was verified?</span></div><div class="line">			<span class="keyword">if</span> !gc.blockMsgStore.CheckValid(msg.GetGossipMessage()) &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> !gc.verifyBlock(m.GossipMessage, msg.GetConnectionInfo().ID) &#123;</div><div class="line">				gc.logger.Warning(<span class="string">"Failed verifying block"</span>, m.GetDataMsg().Payload.SeqNum)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">			added = gc.blockMsgStore.Add(msg.GetGossipMessage())</div><div class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// StateInfoMsg verification should be handled in a layer above</span></div><div class="line">			<span class="comment">//  since we don't have access to the id mapper here</span></div><div class="line">			added = gc.stateInfoMsgStore.Add(msg.GetGossipMessage())</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> added &#123;</div><div class="line">			<span class="comment">// Forward the message</span></div><div class="line">			gc.Forward(msg)</div><div class="line">			<span class="comment">// DeMultiplex to local subscribers</span></div><div class="line">			gc.DeMultiplex(m)</div><div class="line"></div><div class="line">			<span class="keyword">if</span> m.IsDataMsg() &#123;</div><div class="line">				gc.blocksPuller.Add(msg.GetGossipMessage())</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 即 hello, digest, req, res 这类消息</span></div><div class="line">	<span class="keyword">if</span> m.IsPullMsg() &amp;&amp; m.GetPullMsgType() == proto.PullMsgType_BLOCK_MSG &#123;</div><div class="line">		<span class="keyword">if</span> gc.hasLeftChannel() &#123;</div><div class="line">			gc.logger.Info(<span class="string">"Received Pull message from"</span>, msg.GetConnectionInfo().Endpoint, <span class="string">"but left the channel"</span>, <span class="keyword">string</span>(gc.chainID))</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// If we don't have a StateInfo message from the peer,</span></div><div class="line">		<span class="comment">// no way of validating its eligibility in the channel.</span></div><div class="line">		<span class="keyword">if</span> gc.stateInfoMsgStore.MsgByID(msg.GetConnectionInfo().ID) == <span class="literal">nil</span> &#123;</div><div class="line">			gc.logger.Debug(<span class="string">"Don't have StateInfo message of peer"</span>, msg.GetConnectionInfo())</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> !gc.eligibleForChannelAndSameOrg(discovery.NetworkMember&#123;PKIid: msg.GetConnectionInfo().ID&#125;) &#123;</div><div class="line">			gc.logger.Warning(msg.GetConnectionInfo(), <span class="string">"isn't eligible for pulling blocks of"</span>, <span class="keyword">string</span>(gc.chainID))</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 即 res 这个消息</span></div><div class="line">		<span class="keyword">if</span> m.IsDataUpdate() &#123;</div><div class="line">			<span class="comment">// Iterate over the envelopes, and filter out blocks</span></div><div class="line">			<span class="comment">// that we already have in the blockMsgStore, or blocks that</span></div><div class="line">			<span class="comment">// are too far in the past.</span></div><div class="line">			filteredEnvelopes := []*proto.Envelope&#123;&#125;</div><div class="line">			<span class="keyword">for</span> _, item := <span class="keyword">range</span> m.GetDataUpdate().Data &#123;</div><div class="line">				gMsg, err := item.ToGossipMessage()</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					gc.logger.Warningf(<span class="string">"Data update contains an invalid message: %+v"</span>, errors.WithStack(err))</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> !bytes.Equal(gMsg.Channel, []<span class="keyword">byte</span>(gc.chainID)) &#123;</div><div class="line">					gc.logger.Warning(<span class="string">"DataUpdate message contains item with channel"</span>, gMsg.Channel, <span class="string">"but should be"</span>, gc.chainID)</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="comment">// Would this block go into the message store if it was verified?</span></div><div class="line">				<span class="keyword">if</span> !gc.blockMsgStore.CheckValid(msg.GetGossipMessage()) &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> !gc.verifyBlock(gMsg.GossipMessage, msg.GetConnectionInfo().ID) &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				added := gc.blockMsgStore.Add(gMsg)</div><div class="line">				<span class="keyword">if</span> !added &#123;</div><div class="line">					<span class="comment">// If this block doesn't need to be added, it means it either already</span></div><div class="line">					<span class="comment">// exists in memory or that it is too far in the past</span></div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125;</div><div class="line">				filteredEnvelopes = <span class="built_in">append</span>(filteredEnvelopes, item)</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Replace the update message with just the blocks that should be processed</span></div><div class="line">			m.GetDataUpdate().Data = filteredEnvelopes</div><div class="line">		&#125;</div><div class="line">		gc.blocksPuller.HandleMessage(msg)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.IsLeadershipMsg() &#123;</div><div class="line">		<span class="comment">// Handling leadership message</span></div><div class="line">		added := gc.leaderMsgStore.Add(m)</div><div class="line">		<span class="keyword">if</span> added &#123;</div><div class="line">			gc.DeMultiplex(m)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>gossipChannel</code> 中的 <code>Adapter</code> 是为了调用 <code>gossipServiceImpl</code> 的接口，定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Adapter enables the gossipChannel</span></div><div class="line"><span class="comment">// to communicate with gossipServiceImpl.</span></div><div class="line"><span class="keyword">type</span> Adapter <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// GetConf returns the configuration that this GossipChannel will posses</span></div><div class="line">	GetConf() Config</div><div class="line"></div><div class="line">	<span class="comment">// Gossip gossips a message in the channel</span></div><div class="line">	Gossip(message *proto.SignedGossipMessage)</div><div class="line"></div><div class="line">	<span class="comment">// Forward sends a message to the next hops</span></div><div class="line">	Forward(message proto.ReceivedMessage)</div><div class="line"></div><div class="line">	<span class="comment">// DeMultiplex de-multiplexes an item to subscribers</span></div><div class="line">	DeMultiplex(<span class="keyword">interface</span>&#123;&#125;)</div><div class="line"></div><div class="line">	<span class="comment">// GetMembership returns the known alive peers and their information</span></div><div class="line">	GetMembership() []discovery.NetworkMember</div><div class="line"></div><div class="line">	<span class="comment">// Lookup returns a network member, or nil if not found</span></div><div class="line">	Lookup(PKIID common.PKIidType) *discovery.NetworkMember</div><div class="line"></div><div class="line">	<span class="comment">// Send sends a message to a list of peers</span></div><div class="line">	Send(msg *proto.SignedGossipMessage, peers ...*comm.RemotePeer)</div><div class="line"></div><div class="line">	<span class="comment">// ValidateStateInfoMessage returns an error if a message</span></div><div class="line">	<span class="comment">// hasn't been signed correctly, nil otherwise.</span></div><div class="line">	ValidateStateInfoMessage(message *proto.SignedGossipMessage) error</div><div class="line"></div><div class="line">	<span class="comment">// GetOrgOfPeer returns the organization ID of a given peer PKI-ID</span></div><div class="line">	GetOrgOfPeer(pkiID common.PKIidType) api.OrgIdentityType</div><div class="line"></div><div class="line">	<span class="comment">// GetIdentityByPKIID returns an identity of a peer with a certain</span></div><div class="line">	<span class="comment">// pkiID, or nil if not found</span></div><div class="line">	GetIdentityByPKIID(pkiID common.PKIidType) api.PeerIdentityType</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Adapter</code> 接口的实现类 <code>gossipAdapterImpl</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> gossipAdapterImpl <span class="keyword">struct</span> &#123;</div><div class="line">	*gossipServiceImpl</div><div class="line">	discovery.Discovery</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例如 <code>gossipAdapterImpl.Gossip</code> 的实现就是调用 <code>gossipServiceImpl</code> 的相关方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Gossip gossips a message</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ga *gossipAdapterImpl)</span> <span class="title">Gossip</span><span class="params">(msg *proto.SignedGossipMessage)</span></span> &#123;</div><div class="line">	ga.gossipServiceImpl.emitter.Add(&amp;emittedGossipMessage&#123;</div><div class="line">		SignedGossipMessage: msg,</div><div class="line">		filter: <span class="function"><span class="keyword">func</span><span class="params">(_ common.PKIidType)</span> <span class="title">bool</span></span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">		&#125;,</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>gossipServiceImpl.InitializeChannel</code> 方法中，会调用 <code>NewGossipStateProvider</code> 创建该通道的 <code>GossipStateProvider</code> 对象（后面分析这个对象的作用）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGossipStateProvider</span><span class="params">(chainID <span class="keyword">string</span>, services *ServicesMediator, ledger ledgerResources)</span> <span class="title">GossipStateProvider</span></span> &#123;</div><div class="line"></div><div class="line">	gossipChan, _ := services.Accept(<span class="function"><span class="keyword">func</span><span class="params">(message <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line">		<span class="comment">// Get only data messages</span></div><div class="line">		<span class="keyword">return</span> message.(*proto.GossipMessage).IsDataMsg() &amp;&amp;</div><div class="line">			bytes.Equal(message.(*proto.GossipMessage).Channel, []<span class="keyword">byte</span>(chainID))</div><div class="line">	&#125;, <span class="literal">false</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 省略 ...</span></div><div class="line"></div><div class="line">	<span class="comment">// Listen for incoming communication</span></div><div class="line">	<span class="keyword">go</span> s.listen()</div><div class="line"></div><div class="line">	<span class="comment">// Deliver in order messages into the incoming channel</span></div><div class="line">	<span class="keyword">go</span> s.deliverPayloads()</div><div class="line"></div><div class="line">	<span class="comment">// 省略 ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该函数中的 <code>ServicesMediator</code> 类型定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ServicesMediator aggregated adapter to compound all mediator</span></div><div class="line"><span class="comment">// required by state transfer into single struct</span></div><div class="line"><span class="keyword">type</span> ServicesMediator <span class="keyword">struct</span> &#123;</div><div class="line">	GossipAdapter</div><div class="line">	MCSAdapter</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// GossipAdapter defines gossip/communication required interface for state provider</span></div><div class="line"><span class="keyword">type</span> GossipAdapter <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// Send sends a message to remote peers</span></div><div class="line">	Send(msg *proto.GossipMessage, peers ...*comm.RemotePeer)</div><div class="line"></div><div class="line">	<span class="comment">// Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.</span></div><div class="line">	<span class="comment">// If passThrough is false, the messages are processed by the gossip layer beforehand.</span></div><div class="line">	<span class="comment">// If passThrough is true, the gossip layer doesn't intervene and the messages</span></div><div class="line">	<span class="comment">// can be used to send a reply back to the sender</span></div><div class="line">	Accept(acceptor common2.MessageAcceptor, passThrough <span class="keyword">bool</span>) (&lt;-<span class="keyword">chan</span> *proto.GossipMessage, &lt;-<span class="keyword">chan</span> proto.ReceivedMessage)</div><div class="line"></div><div class="line">	<span class="comment">// UpdateChannelMetadata updates the self metadata the peer</span></div><div class="line">	<span class="comment">// publishes to other peers about its channel-related state</span></div><div class="line">	UpdateChannelMetadata(metadata []<span class="keyword">byte</span>, chainID common2.ChainID)</div><div class="line"></div><div class="line">	<span class="comment">// PeersOfChannel returns the NetworkMembers considered alive</span></div><div class="line">	<span class="comment">// and also subscribed to the channel given</span></div><div class="line">	PeersOfChannel(common2.ChainID) []discovery.NetworkMember</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>GossipAdapter</code> 接口的实现类型即为 <code>gossipServiceImpl</code>，因此其 <code>Accept</code> 方法如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate.</span></div><div class="line"><span class="comment">// If passThrough is false, the messages are processed by the gossip layer beforehand.</span></div><div class="line"><span class="comment">// If passThrough is true, the gossip layer doesn't intervene and the messages</span></div><div class="line"><span class="comment">// can be used to send a reply back to the sender</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *gossipServiceImpl)</span> <span class="title">Accept</span><span class="params">(acceptor common.MessageAcceptor, passThrough <span class="keyword">bool</span>)</span> <span class="params">(&lt;-<span class="keyword">chan</span> *proto.GossipMessage, &lt;-<span class="keyword">chan</span> proto.ReceivedMessage)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> passThrough &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, g.comm.Accept(acceptor)</div><div class="line">	&#125;</div><div class="line">	acceptByType := <span class="function"><span class="keyword">func</span><span class="params">(o <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> o, isGossipMsg := o.(*proto.GossipMessage); isGossipMsg &#123;</div><div class="line">			<span class="keyword">return</span> acceptor(o)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> o, isSignedMsg := o.(*proto.SignedGossipMessage); isSignedMsg &#123;</div><div class="line">			sMsg := o</div><div class="line">			<span class="keyword">return</span> acceptor(sMsg.GossipMessage)</div><div class="line">		&#125;</div><div class="line">		g.logger.Warning(<span class="string">"Message type:"</span>, reflect.TypeOf(o), <span class="string">"cannot be evaluated"</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">	inCh := g.AddChannel(acceptByType)  <span class="comment">// 关键部分</span></div><div class="line">	outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *proto.GossipMessage, acceptChanSize)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> s := &lt;-g.toDieChan:</div><div class="line">				g.toDieChan &lt;- s</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> m := &lt;-inCh:</div><div class="line">				<span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span></div><div class="line">				&#125;</div><div class="line">				outCh &lt;- m.(*proto.SignedGossipMessage).GossipMessage</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> outCh, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>g.AddChannel</code> 方法是内嵌在 <code>gossipServiceImpl</code> 类型中的 <code>ChannelDeMultiplexer</code> 类型的方法，定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AddChannel registers a channel with a certain predicate</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ChannelDeMultiplexer)</span> <span class="title">AddChannel</span><span class="params">(predicate common.MessageAcceptor)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">	m.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> m.lock.Unlock()</div><div class="line">	ch := &amp;channel&#123;ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>), pred: predicate&#125;</div><div class="line">	m.channels = <span class="built_in">append</span>(m.channels, ch)</div><div class="line">	<span class="keyword">return</span> ch.ch</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DeMultiplex broadcasts the message to all channels that were returned</span></div><div class="line"><span class="comment">// by AddChannel calls and that hold the respected predicates.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *ChannelDeMultiplexer)</span> <span class="title">DeMultiplex</span><span class="params">(msg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="built_in">recover</span>()</div><div class="line">	&#125;() <span class="comment">// recover from sending on a closed channel</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> m.isClosed() &#123;</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	m.lock.RLock()</div><div class="line">	channels := m.channels</div><div class="line">	m.lock.RUnlock()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> channels &#123;</div><div class="line">		<span class="keyword">if</span> ch.pred(msg) &#123;</div><div class="line">			ch.ch &lt;- msg</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此每次调用 <code>DeMultiplex</code> 派发消息时，会发送给符合对应 <code>predicate</code> 的通道     </p>
<p>其中 <code>s.listen</code> 方法定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GossipStateProviderImpl)</span> <span class="title">listen</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> s.done.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> msg := &lt;-s.gossipChan:   <span class="comment">// 这就是 AddChannel 后返回的通道 chan</span></div><div class="line">			logger.Debug(<span class="string">"Received new message via gossip channel"</span>)</div><div class="line">			<span class="keyword">go</span> s.queueNewMessage(msg)</div><div class="line">		<span class="keyword">case</span> msg := &lt;-s.commChan:</div><div class="line">			logger.Debug(<span class="string">"Dispatching a message"</span>, msg)</div><div class="line">			<span class="keyword">go</span> s.dispatch(msg)</div><div class="line">		<span class="keyword">case</span> &lt;-s.stopCh:</div><div class="line">			s.stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">			logger.Debug(<span class="string">"Stop listening for new messages"</span>)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>s.queueNewMessage</code> 就是将消息 push 到 <code>payloads</code> 对象中 （<code>PayloadsBuffer</code> 接口）     </p>
<p>而 <code>s.deliverPayloads</code> 就是不断的从 <code>payloads</code> 对象中读取数据，commit 到本地账本中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *GossipStateProviderImpl)</span> <span class="title">deliverPayloads</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> s.done.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="comment">// Wait for notification that next seq has arrived</span></div><div class="line">		<span class="keyword">case</span> &lt;-s.payloads.Ready():</div><div class="line">			logger.Debugf(<span class="string">"Ready to transfer payloads to the ledger, next sequence number is = [%d]"</span>, s.payloads.Next())</div><div class="line">			<span class="comment">// Collect all subsequent payloads</span></div><div class="line">			<span class="keyword">for</span> payload := s.payloads.Pop(); payload != <span class="literal">nil</span>; payload = s.payloads.Pop() &#123;</div><div class="line">				rawBlock := &amp;common.Block&#123;&#125;</div><div class="line">				<span class="keyword">if</span> err := pb.Unmarshal(payload.Data, rawBlock); err != <span class="literal">nil</span> &#123;</div><div class="line">					logger.Errorf(<span class="string">"Error getting block with seqNum = %d due to (%+v)...dropping block"</span>, payload.SeqNum, errors.WithStack(err))</div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> rawBlock.Data == <span class="literal">nil</span> || rawBlock.Header == <span class="literal">nil</span> &#123;</div><div class="line">					logger.Errorf(<span class="string">"Block with claimed sequence %d has no header (%v) or data (%v)"</span>,</div><div class="line">						payload.SeqNum, rawBlock.Header, rawBlock.Data)</div><div class="line">					<span class="keyword">continue</span></div><div class="line">				&#125;</div><div class="line">				logger.Debug(<span class="string">"New block with claimed sequence number "</span>, payload.SeqNum, <span class="string">" transactions num "</span>, <span class="built_in">len</span>(rawBlock.Data.Data))</div><div class="line"></div><div class="line">				<span class="comment">// Read all private data into slice</span></div><div class="line">				<span class="keyword">var</span> p util.PvtDataCollections</div><div class="line">				<span class="keyword">if</span> payload.PrivateData != <span class="literal">nil</span> &#123;</div><div class="line">					err := p.Unmarshal(payload.PrivateData)</div><div class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">						logger.Errorf(<span class="string">"Wasn't able to unmarshal private data for block seqNum = %d due to (%+v)...dropping block"</span>, payload.SeqNum, errors.WithStack(err))</div><div class="line">						<span class="keyword">continue</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> err := s.commitBlock(rawBlock, p); err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">if</span> executionErr, isExecutionErr := err.(*vsccErrors.VSCCExecutionFailureError); isExecutionErr &#123;</div><div class="line">						logger.Errorf(<span class="string">"Failed executing VSCC due to %v. Aborting chain processing"</span>, executionErr)</div><div class="line">						<span class="keyword">return</span></div><div class="line">					&#125;</div><div class="line">					logger.Panicf(<span class="string">"Cannot commit block to the ledger due to %+v"</span>, errors.WithStack(err))</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">case</span> &lt;-s.stopCh:</div><div class="line">			s.stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">			logger.Debug(<span class="string">"State provider has been stopped, finishing to push new blocks."</span>)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>目前看来 fabric gossip 既有 push，又有 pull</strong>      </p>
<h1 id="fabric-中私密数据的保护"><a href="#fabric-中私密数据的保护" class="headerlink" title="fabric 中私密数据的保护"></a>fabric 中私密数据的保护</h1><p><a href="https://blog.csdn.net/yeasy/article/details/80366828" target="_blank" rel="external">发展过程</a><br><code>collections-config</code> 初始化合约时的配置参数<br><code>V1_1_PVTDATA_EXPERIMENTAL</code> 需要 channel 开启私有数据开关（configtx.yaml），开启方式如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="attr">SampleSingleMSPChannelV1_1:</span></div><div class="line">	<span class="attr">Consortium:</span> <span class="string">SampleConsortium</span></div><div class="line">	<span class="attr">Application:</span></div><div class="line">		<span class="attr">Organizations:</span></div><div class="line">			<span class="bullet">-</span> <span class="meta">*SampleOrg</span></div><div class="line">		<span class="attr">Capabilities:</span>  <span class="comment"># 通道的能力/功能 </span></div><div class="line">			<span class="string">&lt;&lt;:</span> <span class="meta">*ApplicationCapabilities</span></div><div class="line"></div><div class="line"><span class="comment">################################################################################</span></div><div class="line"><span class="attr">Capabilities:</span>   <span class="comment"># 预设的通道能力</span></div><div class="line"><span class="attr">    Application:</span> <span class="meta">&amp;ApplicationCapabilities</span></div><div class="line">        <span class="comment"># V1.1 for Application is a catchall flag for behavior which has been</span></div><div class="line">        <span class="comment"># determined to be desired for all peers running v1.0.x, but the</span></div><div class="line">        <span class="comment"># modification of which would cause incompatibilities.  Users should</span></div><div class="line">        <span class="comment"># leave this flag set to true.</span></div><div class="line"><span class="attr">        V1_1:</span> <span class="literal">true</span></div><div class="line">        <span class="comment"># V1_1_PVTDATA_EXPERIMENTAL is an Application capability to enable the</span></div><div class="line">        <span class="comment"># private data capability.  It is only supported when using peers built</span></div><div class="line">        <span class="comment"># with experimental build tag.  When set to true, private data</span></div><div class="line">        <span class="comment"># collections can be configured upon chaincode instantiation and</span></div><div class="line">        <span class="comment"># utilized within chaincode Invokes.</span></div><div class="line">        <span class="comment"># <span class="doctag">NOTE:</span> Use of this feature with non "experimental" binaries on the</span></div><div class="line">        <span class="comment"># network may cause a fork.</span></div><div class="line"><span class="attr">        V1_1_PVTDATA_EXPERIMENTAL:</span> <span class="literal">false</span>   <span class="comment"># 关键，修改其为 true</span></div><div class="line">        <span class="comment"># V1_1_RESOURCETREE_EXPERIMENTAL is an Application capability to enable</span></div><div class="line">        <span class="comment"># the resources capability. Currently this is needed for defining</span></div><div class="line">        <span class="comment"># resource-based access control (RBAC). RBAC helps set fine-grained</span></div><div class="line">        <span class="comment"># access control on system resources such as the endorser and various</span></div><div class="line">        <span class="comment"># system chaincodes. Default is v1.0-based access control based on</span></div><div class="line">        <span class="comment"># CHANNEL_READERS and CHANNEL_WRITERS.</span></div><div class="line">        <span class="comment"># <span class="doctag">NOTE:</span> Use of this feature with non "experimental" binaries on</span></div><div class="line">        <span class="comment"># the network may cause a fork.</span></div><div class="line"><span class="attr">        V1_1_RESOURCETREE_EXPERIMENTAL:</span> <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>测试方法： <code>github.com/hyperledger/fabric/examples/chaincode/go/map/map_experimental.go</code> 中即为官方提供的测试合约。但是该合约成功运行还需要一个前提：<code>stub shim.ChaincodeStubInterface</code> 改造，需要编译为 <code>experimental</code>，以 <code>github.com/hyperledger/fabric/core/chaincode/shim/interfaces_experimental.go</code> 文件为例，文件头部有如下注释内容：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build experimental</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Copyright IBM Corp. All Rights Reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">SPDX-License-Identifier: Apache-2.0</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure></p>
<p><code>// +build experimental</code> 这是条件编译，其中 <code>experimental</code> 是 <code>build tag</code>，golang 内置了几种跟系统相关的 tag，例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build linux,386 darwin,!cgo</span></div><div class="line">等同于   </div><div class="line">(linux AND <span class="number">386</span>) OR (darwin AND (NOT cgo))</div></pre></td></tr></table></figure></p>
<p>由上可见，<code>逗号</code> 表示 <code>and</code>，<code>空格</code> 表示 <code>or</code>   </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +build linux darwin</span></div><div class="line"><span class="comment">// +build 386</span></div><div class="line">等同于    </div><div class="line">(linux OR darwin) AND <span class="number">386</span></div></pre></td></tr></table></figure>
<p>由上可见，<code>跨行</code> 表示 <code>and</code>    </p>
<p>而 <code>// +build ignore</code> 表示不参与编译<br><strong>注意: build tag 只能出现在文件首部，且最后面必须要有一个空行，否则会当做为一般注释处理</strong><br>对于自定义的 tag，例如 <code>experimental</code>，需要在编译时加上对应 tag，例如 <code>go build -tags</code>      </p>
<p>除了在文件头添加 <code>// +build</code> 以外，golang 的条件编译还支持 <code>文件名后缀</code>，例如 <code>interfaces_experimental.go</code>，两者用一种即可。    </p>
<h1 id="发送-private-data-过程"><a href="#发送-private-data-过程" class="headerlink" title="发送 private data 过程"></a>发送 private data 过程</h1><p>一， 首先还是需要编译一套支持 private data 的 fabric 代码<br>二，书写合约，对应存放私有数据的函数需要调用 <code>stub.PutPrivateData(collection, key, []byte(value))</code>。其中 <code>collection</code> 是私有数据接收的集合名，在 chaincode instantiate 时配置好。   </p>
<p>首先 peer 会调用 <code>ChaincodeSupport.Launch</code> 方法来拉起合约容器（如果没有起来），并设置到 <code>Ready</code> 状态<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Launch will launch the chaincode if not running (if running return nil) and will wait for handler of the chaincode to get into FSM ready state.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chaincodeSupport *ChaincodeSupport)</span> <span class="title">Launch</span><span class="params">(context context.Context, cccid *ccprovider.CCContext, spec <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*pb.ChaincodeID, *pb.ChaincodeInput, error)</span></span> &#123;</div><div class="line">	<span class="comment">//build the chaincode</span></div><div class="line">	<span class="keyword">var</span> cID *pb.ChaincodeID</div><div class="line">	<span class="keyword">var</span> cMsg *pb.ChaincodeInput</div><div class="line"></div><div class="line">	<span class="keyword">var</span> cds *pb.ChaincodeDeploymentSpec</div><div class="line">	<span class="keyword">var</span> ci *pb.ChaincodeInvocationSpec</div><div class="line">	<span class="keyword">if</span> cds, _ = spec.(*pb.ChaincodeDeploymentSpec); cds == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> ci, _ = spec.(*pb.ChaincodeInvocationSpec); ci == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="built_in">panic</span>(<span class="string">"Launch should be called with deployment or invocation spec"</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> cds != <span class="literal">nil</span> &#123;</div><div class="line">		cID = cds.ChaincodeSpec.ChaincodeId</div><div class="line">		cMsg = cds.ChaincodeSpec.Input</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		cID = ci.ChaincodeSpec.ChaincodeId</div><div class="line">		cMsg = ci.ChaincodeSpec.Input</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	canName := cccid.GetCanonicalName()</div><div class="line">	chaincodeSupport.runningChaincodes.Lock()</div><div class="line">	<span class="keyword">var</span> chrte *chaincodeRTEnv</div><div class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="comment">//if its in the map, there must be a connected stream...nothing to do</span></div><div class="line">	<span class="keyword">if</span> chrte, ok = chaincodeSupport.chaincodeHasBeenLaunched(canName); ok &#123;</div><div class="line">		<span class="keyword">if</span> !chrte.handler.registered &#123;</div><div class="line">			chaincodeSupport.runningChaincodes.Unlock()</div><div class="line">			err = errors.Errorf(<span class="string">"premature execution - chaincode (%s) launched and waiting for registration"</span>, canName)</div><div class="line">			chaincodeLogger.Debugf(<span class="string">"%+v"</span>, err)</div><div class="line">			<span class="keyword">return</span> cID, cMsg, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> chrte.handler.isRunning() &#123;</div><div class="line">			<span class="keyword">if</span> chaincodeLogger.IsEnabledFor(logging.DEBUG) &#123;</div><div class="line">				chaincodeLogger.Debugf(<span class="string">"chaincode is running(no need to launch) : %s"</span>, canName)</div><div class="line">			&#125;</div><div class="line">			chaincodeSupport.runningChaincodes.Unlock()</div><div class="line">			<span class="keyword">return</span> cID, cMsg, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		chaincodeLogger.Debugf(<span class="string">"Container not in READY state(%s)...send init/ready"</span>, chrte.handler.FSM.Current())</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">//chaincode is not up... but is the launch process underway? this is</span></div><div class="line">		<span class="comment">//strictly not necessary as the actual launch process will catch this</span></div><div class="line">		<span class="comment">//(in launchAndWaitForRegister), just a bit of optimization for thundering</span></div><div class="line">		<span class="comment">//herds</span></div><div class="line">		<span class="keyword">if</span> chaincodeSupport.launchStarted(canName) &#123;</div><div class="line">			chaincodeSupport.runningChaincodes.Unlock()</div><div class="line">			err = errors.Errorf(<span class="string">"premature execution - chaincode (%s) is being launched"</span>, canName)</div><div class="line">			<span class="keyword">return</span> cID, cMsg, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	chaincodeSupport.runningChaincodes.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> cds == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">if</span> cccid.Syscc &#123;</div><div class="line">			<span class="keyword">return</span> cID, cMsg, errors.Errorf(<span class="string">"a syscc should be running (it cannot be launched) %s"</span>, canName)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> chaincodeSupport.userRunsCC &#123;</div><div class="line">			chaincodeLogger.Error(<span class="string">"You are attempting to perform an action other than Deploy on Chaincode that is not ready and you are in developer mode. Did you forget to Deploy your chaincode?"</span>)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">var</span> depPayload []<span class="keyword">byte</span></div><div class="line"></div><div class="line">		<span class="comment">//hopefully we are restarting from existing image and the deployed transaction exists</span></div><div class="line">		<span class="comment">//(this will also validate the ID from the LSCC if we're not using the config-tree approach)</span></div><div class="line">		depPayload, err = GetCDS(context, cccid.TxID, cccid.SignedProposal, cccid.Proposal, cccid.ChainID, cID.Name)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> cID, cMsg, errors.WithMessage(err, fmt.Sprintf(<span class="string">"could not get ChaincodeDeploymentSpec for %s"</span>, canName))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> depPayload == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> cID, cMsg, errors.WithMessage(err, fmt.Sprintf(<span class="string">"nil ChaincodeDeploymentSpec for %s"</span>, canName))</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		cds = &amp;pb.ChaincodeDeploymentSpec&#123;&#125;</div><div class="line"></div><div class="line">		<span class="comment">//Get lang from original deployment</span></div><div class="line">		err = proto.Unmarshal(depPayload, cds)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> cID, cMsg, errors.Wrap(err, fmt.Sprintf(<span class="string">"failed to unmarshal deployment transactions for %s"</span>, canName))</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//from here on : if we launch the container and get an error, we need to stop the container</span></div><div class="line"></div><div class="line">	<span class="comment">//launch container if it is a System container or not in dev mode</span></div><div class="line">	<span class="keyword">if</span> (!chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) &amp;&amp; (chrte == <span class="literal">nil</span> || chrte.handler == <span class="literal">nil</span>) &#123;</div><div class="line">		<span class="comment">//NOTE-We need to streamline code a bit so the data from LSCC gets passed to this thus</span></div><div class="line">		<span class="comment">//avoiding the need to go to the FS. In particular, we should use cdsfs completely. It is</span></div><div class="line">		<span class="comment">//just a vestige of old protocol that we continue to use ChaincodeDeploymentSpec for</span></div><div class="line">		<span class="comment">//anything other than Install. In particular, instantiate, invoke, upgrade should be using</span></div><div class="line">		<span class="comment">//just some form of ChaincodeInvocationSpec.</span></div><div class="line">		<span class="comment">//</span></div><div class="line">		<span class="comment">//But for now, if we are invoking we have gone through the LSCC path above. If  instantiating</span></div><div class="line">		<span class="comment">//or upgrading currently we send a CDS with nil CodePackage. In this case the codepath</span></div><div class="line">		<span class="comment">//in the endorser has gone through LSCC validation. Just get the code from the FS.</span></div><div class="line">		<span class="keyword">if</span> cds.CodePackage == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">//no code bytes for these situations</span></div><div class="line">			<span class="keyword">if</span> !(chaincodeSupport.userRunsCC || cds.ExecEnv == pb.ChaincodeDeploymentSpec_SYSTEM) &#123;</div><div class="line">				ccpack, err := ccprovider.GetChaincodeFromFS(cID.Name, cID.Version)</div><div class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">					<span class="keyword">return</span> cID, cMsg, err</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				cds = ccpack.GetDepSpec()</div><div class="line">				chaincodeLogger.Debugf(<span class="string">"launchAndWaitForRegister fetched %d bytes from file system"</span>, <span class="built_in">len</span>(cds.CodePackage))</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		builder := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.Reader, error)</span></span> &#123; <span class="keyword">return</span> platforms.GenerateDockerBuild(cds) &#125;</div><div class="line"></div><div class="line">		err = chaincodeSupport.launchAndWaitForRegister(context, cccid, cds, &amp;ccLauncherImpl&#123;context, chaincodeSupport, cccid, cds, builder&#125;)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			chaincodeLogger.Errorf(<span class="string">"launchAndWaitForRegister failed: %+v"</span>, err)</div><div class="line">			<span class="keyword">return</span> cID, cMsg, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">//launch will set the chaincode in Ready state</span></div><div class="line">		err = chaincodeSupport.sendReady(context, cccid, chaincodeSupport.ccStartupTimeout)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			err = errors.WithMessage(err, <span class="string">"failed to init chaincode"</span>)</div><div class="line">			chaincodeLogger.Errorf(<span class="string">"%+v"</span>, err)</div><div class="line">			errIgnore := chaincodeSupport.Stop(context, cccid, cds)</div><div class="line">			<span class="keyword">if</span> errIgnore != <span class="literal">nil</span> &#123;</div><div class="line">				chaincodeLogger.Errorf(<span class="string">"stop failed: %+v"</span>, errIgnore)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		chaincodeLogger.Debug(<span class="string">"sending init completed"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	chaincodeLogger.Debug(<span class="string">"LaunchChaincode complete"</span>)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> cID, cMsg, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，<code>launchAndWaitForRegister</code> 方法，会调用 <code>launcher.launch</code> 启动容器（如果未启动的话）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//launchAndWaitForRegister will launch container if not already running. Use</span></div><div class="line"><span class="comment">//the targz to create the image if not found. It uses the supplied launcher</span></div><div class="line"><span class="comment">//for launching the chaincode. UTs use the launcher freely to test various</span></div><div class="line"><span class="comment">//conditions such as timeouts, failed launches and other errors</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chaincodeSupport *ChaincodeSupport)</span> <span class="title">launchAndWaitForRegister</span><span class="params">(ctxt context.Context, cccid *ccprovider.CCContext, cds *pb.ChaincodeDeploymentSpec, launcher launcherIntf)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// 忽略 ...</span></div><div class="line"></div><div class="line">	<span class="comment">// 关键，通知是否 registered</span></div><div class="line">	notfy := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">	errChan := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">var</span> err error</div><div class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="comment">//notify ONLY if we encountered an error</span></div><div class="line">			<span class="comment">//else either timeout or ready notify should</span></div><div class="line">			<span class="comment">//kick in</span></div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				errChan &lt;- err</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line"></div><div class="line">		resp, err := launcher.launch(ctxt, notfy)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || (resp != <span class="literal">nil</span> &amp;&amp; resp.(container.VMCResp).Err != <span class="literal">nil</span>) &#123;</div><div class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">				err = resp.(container.VMCResp).Err</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">//if the launch was successful and leads to proper registration,</span></div><div class="line">			<span class="comment">//this error could be ignored in the select below. On the other</span></div><div class="line">			<span class="comment">//hand the error might be triggered for select in which case</span></div><div class="line">			<span class="comment">//the launch will be cleaned up</span></div><div class="line">			err = errors.WithMessage(err, <span class="string">"error starting container"</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="comment">// 忽略 ...</span></div><div class="line"></div><div class="line">	<span class="comment">//wait for REGISTER state</span></div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> ok := &lt;-notfy:</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			err = errors.Errorf(<span class="string">"registration failed for %s(networkid:%s,peerid:%s,tx:%s)"</span>, canName, chaincodeSupport.peerNetworkID, chaincodeSupport.peerID, cccid.TxID)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 忽略 ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而这个 <code>launcher.launch</code> 即为 <code>ccLauncherImpl.launch</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用 VMCProcess 启动 docker 容器</span></div><div class="line"><span class="comment">//launches the chaincode using the supplied context and notifier</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ccl *ccLauncherImpl)</span> <span class="title">launch</span><span class="params">(ctxt context.Context, notfy <span class="keyword">chan</span> <span class="keyword">bool</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	<span class="comment">//launch the chaincode</span></div><div class="line">	args, env, filesToUpload, err := ccl.ccSupport.getLaunchConfigs(ccl.cccid, ccl.cds.ChaincodeSpec.Type)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	canName := ccl.cccid.GetCanonicalName()</div><div class="line"></div><div class="line">	chaincodeLogger.Debugf(<span class="string">"start container: %s(networkid:%s,peerid:%s)"</span>, canName, ccl.ccSupport.peerNetworkID, ccl.ccSupport.peerID)</div><div class="line">	chaincodeLogger.Debugf(<span class="string">"start container with args: %s"</span>, strings.Join(args, <span class="string">" "</span>))</div><div class="line">	chaincodeLogger.Debugf(<span class="string">"start container with env:\n\t%s"</span>, strings.Join(env, <span class="string">"\n\t"</span>))</div><div class="line"></div><div class="line">	<span class="comment">//set up the shadow handler JIT before container launch to</span></div><div class="line">	<span class="comment">//reduce window of when an external chaincode can sneak in</span></div><div class="line">	<span class="comment">//and use the launching context and make it its own</span></div><div class="line">	<span class="comment">// 关键部分，在这里设置了一个占位符 handler，详见下面</span></div><div class="line">	preLaunchFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">		ccl.ccSupport.preLaunchSetup(canName, notfy)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ccid := ccintf.CCID&#123;ChaincodeSpec: ccl.cds.ChaincodeSpec, NetworkID: ccl.ccSupport.peerNetworkID, PeerID: ccl.ccSupport.peerID, Version: ccl.cccid.Version&#125;</div><div class="line">	sir := container.StartImageReq&#123;CCID: ccid, Builder: ccl.builder, Args: args, Env: env, FilesToUpload: filesToUpload, PrelaunchFunc: preLaunchFunc&#125;</div><div class="line">	ipcCtxt := context.WithValue(ctxt, ccintf.GetCCHandlerKey(), ccl.ccSupport)</div><div class="line"></div><div class="line">	vmtype, _ := ccl.ccSupport.getVMType(ccl.cds)</div><div class="line">	resp, err := container.VMCProcess(ipcCtxt, vmtype, sir)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> resp, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ccl.ccSupport.preLaunchSetup(canName, notfy)</code> 设置了一个 handler 占位符<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 chaincodeMap 中设置了一个占位符 handler，且只配置了 notfy</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chaincodeSupport *ChaincodeSupport)</span> <span class="title">preLaunchSetup</span><span class="params">(chaincode <span class="keyword">string</span>, notfy <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">	chaincodeSupport.runningChaincodes.Lock()</div><div class="line">	<span class="keyword">defer</span> chaincodeSupport.runningChaincodes.Unlock()</div><div class="line">	<span class="comment">//register placeholder Handler. This will be transferred in registerHandler</span></div><div class="line">	<span class="comment">//<span class="doctag">NOTE:</span> from this point, existence of handler for this chaincode means the chaincode</span></div><div class="line">	<span class="comment">//is in the process of getting started (or has been started)</span></div><div class="line">	chaincodeSupport.runningChaincodes.chaincodeMap[chaincode] = &amp;chaincodeRTEnv&#123;handler: &amp;Handler&#123;readyNotify: notfy&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，peer 会调用 <code>ChaincodeSupport.Execute</code> 执行交易<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chaincodeSupport *ChaincodeSupport)</span> <span class="title">Execute</span><span class="params">(ctxt context.Context, cccid *ccprovider.CCContext, msg *pb.ChaincodeMessage, timeout time.Duration)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</div><div class="line">	chaincodeLogger.Debugf(<span class="string">"Entry"</span>)</div><div class="line">	<span class="keyword">defer</span> chaincodeLogger.Debugf(<span class="string">"Exit"</span>)</div><div class="line">	canName := cccid.GetCanonicalName()</div><div class="line">	chaincodeLogger.Debugf(<span class="string">"chaincode canonical name: %s"</span>, canName)</div><div class="line">	chaincodeSupport.runningChaincodes.Lock()</div><div class="line">	<span class="comment">//we expect the chaincode to be running... sanity check</span></div><div class="line">	chrte, ok := chaincodeSupport.chaincodeHasBeenLaunched(canName)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		chaincodeSupport.runningChaincodes.Unlock()</div><div class="line">		chaincodeLogger.Debugf(<span class="string">"cannot execute-chaincode is not running: %s"</span>, canName)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"cannot execute transaction for %s"</span>, canName)</div><div class="line">	&#125;</div><div class="line">	chaincodeSupport.runningChaincodes.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> notfy <span class="keyword">chan</span> *pb.ChaincodeMessage</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">if</span> notfy, err = chrte.handler.sendExecuteMessage(ctxt, cccid.ChainID, msg, cccid.SignedProposal, cccid.Proposal); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprintf(<span class="string">"error sending"</span>))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> ccresp *pb.ChaincodeMessage</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> ccresp = &lt;-notfy:</div><div class="line">		<span class="comment">//response is sent to user or calling chaincode. ChaincodeMessage_ERROR</span></div><div class="line">		<span class="comment">//are typically treated as error</span></div><div class="line">	<span class="keyword">case</span> &lt;-time.After(timeout):</div><div class="line">		err = errors.New(<span class="string">"timeout expired while executing transaction"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//our responsibility to delete transaction context if sendExecuteMessage succeeded</span></div><div class="line">	chrte.handler.deleteTxContext(msg.ChannelId, msg.Txid)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ccresp, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>notfy</code> 会在 <code>Handler.notifyDuringStartup(val bool)</code> 函数中被传入 val 值，false 表示初始化合约失败，true 表示成功且进入 registered 状态<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 是在 handler 收到合约端发送的 REGISTER 事件后，进入 EstablishedState 时，传入 notfy 为 true</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *Handler)</span> <span class="title">enterEstablishedState</span><span class="params">(e *fsm.Event, state <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	handler.notifyDuringStartup(<span class="literal">true</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此 <code>launchAndWaitForRegister</code> 的确是阻塞直到合约发送 REGISTER，peer 端 handler 进入 EstablishedState 状态       </p>
<p>每个自定义合约在运行后，会与 peer 建立 grpc 连接，相关代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// chaincodes.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(cc Chaincode)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// If Start() is called, we assume this is a standalone chaincode and set</span></div><div class="line">	<span class="comment">// up formatted logging.</span></div><div class="line">	SetupChaincodeLogging()</div><div class="line"></div><div class="line">	chaincodename := viper.GetString(<span class="string">"chaincode.id.name"</span>)</div><div class="line">	<span class="keyword">if</span> chaincodename == <span class="string">""</span> &#123;</div><div class="line">		<span class="keyword">return</span> errors.New(<span class="string">"error chaincode id not provided"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err := factory.InitFactories(factory.GetDefaultOpts())</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">"internal error, BCCSP could not be initialized with default options"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//mock stream not set up ... get real stream</span></div><div class="line">	<span class="keyword">if</span> streamGetter == <span class="literal">nil</span> &#123;</div><div class="line">		streamGetter = userChaincodeStreamGetter</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 与 peer 的 ChaincodeServer 建立 grpc 连接</span></div><div class="line">	<span class="comment">// 其实是调用 grpc server 端的 Register 接口，获得 stream</span></div><div class="line">	stream, err := streamGetter(chaincodename)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 循环处理消息</span></div><div class="line">	err = chatWithPeer(chaincodename, stream, cc)</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>chatWithPeer</code> 中，向 peer 的 ChaincodeServer 发送了 <code>REGISTER</code> 信号<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">chatWithPeer</span><span class="params">(chaincodename <span class="keyword">string</span>, stream PeerChaincodeStream, cc Chaincode)</span> <span class="title">error</span></span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">// Create the shim handler responsible for all control logic</span></div><div class="line">	handler := newChaincodeHandler(stream, cc)</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> stream.CloseSend()</div><div class="line">	<span class="comment">// Send the ChaincodeID during register.</span></div><div class="line">	chaincodeID := &amp;pb.ChaincodeID&#123;Name: chaincodename&#125;</div><div class="line">	payload, err := proto.Marshal(chaincodeID)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">"error marshalling chaincodeID during chaincode registration"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Register on the stream</span></div><div class="line">	chaincodeLogger.Debugf(<span class="string">"Registering.. sending %s"</span>, pb.ChaincodeMessage_REGISTER)</div><div class="line">	<span class="comment">// 发送 REG 信号，驱动 peer 端的 FSM 状态机</span></div><div class="line">	<span class="keyword">if</span> err = handler.serialSend(&amp;pb.ChaincodeMessage&#123;Type: pb.ChaincodeMessage_REGISTER, Payload: payload&#125;); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">"error sending chaincode REGISTER"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 开启 for 循环处理消息</span></div><div class="line">	<span class="comment">// 忽略 ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的，在 peer 的 <code>ChaincodeServer</code> 中，<code>Register</code> grpc 接口定义在 <code>ChaincodeSupport</code> 类型中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Register the bidi stream entry point called by chaincode to register with the Peer.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chaincodeSupport *ChaincodeSupport)</span> <span class="title">Register</span><span class="params">(stream pb.ChaincodeSupport_RegisterServer)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> chaincodeSupport.HandleChaincodeStream(stream.Context(), stream)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HandleChaincodeStream implements ccintf.HandleChaincodeStream for all vms to call with appropriate stream</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chaincodeSupport *ChaincodeSupport)</span> <span class="title">HandleChaincodeStream</span><span class="params">(ctxt context.Context, stream ccintf.ChaincodeStream)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> HandleChaincodeStream(chaincodeSupport, ctxt, stream)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleChaincodeStream</span><span class="params">(chaincodeSupport *ChaincodeSupport, ctxt context.Context, stream ccintf.ChaincodeStream)</span> <span class="title">error</span></span> &#123;</div><div class="line">	deadline, ok := ctxt.Deadline()</div><div class="line">	chaincodeLogger.Debugf(<span class="string">"Current context deadline = %s, ok = %v"</span>, deadline, ok)</div><div class="line">	handler := newChaincodeSupportHandler(chaincodeSupport, stream)</div><div class="line">	<span class="keyword">return</span> handler.processStream()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 最终调用 </span></div><div class="line"><span class="comment">// handleMessage is the entrance method for Peer's handling of Chaincode messages.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *Handler)</span> <span class="title">handleMessage</span><span class="params">(msg *pb.ChaincodeMessage)</span> <span class="title">error</span></span> &#123;</div><div class="line">	chaincodeLogger.Debugf(<span class="string">"[%s]Fabric side Handling ChaincodeMessage of type: %s in state %s"</span>, shorttxid(msg.Txid), msg.Type, handler.FSM.Current())</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (msg.Type == pb.ChaincodeMessage_COMPLETED || msg.Type == pb.ChaincodeMessage_ERROR) &amp;&amp; handler.FSM.Current() == <span class="string">"ready"</span> &#123;</div><div class="line">		chaincodeLogger.Debugf(<span class="string">"[%s]HandleMessage- COMPLETED. Notify"</span>, msg.Txid)</div><div class="line">		handler.notify(msg)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> handler.FSM.Cannot(msg.Type.String()) &#123;</div><div class="line">		<span class="comment">// Other errors</span></div><div class="line">		<span class="keyword">return</span> errors.Errorf(<span class="string">"[%s]Chaincode handler validator FSM cannot handle message (%s) with payload size (%d) while in state: %s"</span>, msg.Txid, msg.Type.String(), <span class="built_in">len</span>(msg.Payload), handler.FSM.Current())</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 根据触发 FSM 状态机</span></div><div class="line">	eventErr := handler.FSM.Event(msg.Type.String(), msg)</div><div class="line">	filteredErr := filterError(eventErr)</div><div class="line">	<span class="keyword">if</span> filteredErr != <span class="literal">nil</span> &#123;</div><div class="line">		chaincodeLogger.Errorf(<span class="string">"[%s]Failed to trigger FSM event %s: %s"</span>, msg.Txid, msg.Type.String(), filteredErr)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> filteredErr</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例如，当收到合约端发送的 <code>REGISTER</code> 事件后，FSM 会触发 <code>registerHandler</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chaincodeSupport *ChaincodeSupport)</span> <span class="title">registerHandler</span><span class="params">(chaincodehandler *Handler)</span> <span class="title">error</span></span> &#123;</div><div class="line">	key := chaincodehandler.ChaincodeID.Name</div><div class="line"></div><div class="line">	chaincodeSupport.runningChaincodes.Lock()</div><div class="line">	<span class="keyword">defer</span> chaincodeSupport.runningChaincodes.Unlock()</div><div class="line"></div><div class="line">	chrte2, ok := chaincodeSupport.chaincodeHasBeenLaunched(key)</div><div class="line">	<span class="keyword">if</span> ok &amp;&amp; chrte2.handler.registered == <span class="literal">true</span> &#123;</div><div class="line">		chaincodeLogger.Debugf(<span class="string">"duplicate registered handler(key:%s) return error"</span>, key)</div><div class="line">		<span class="comment">// Duplicate, return error</span></div><div class="line">		<span class="keyword">return</span> newDuplicateChaincodeHandlerError(chaincodehandler)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//a placeholder, unregistered handler will be setup by transaction processing that comes</span></div><div class="line">	<span class="comment">//through via consensus. In this case we swap the handler and give it the notify channel</span></div><div class="line">	<span class="comment">// 关键部分 </span></div><div class="line">	<span class="comment">// 将上面创建的占位 handler 中的 readyNotify 赋值给最终的 handler</span></div><div class="line">	<span class="keyword">if</span> chrte2 != <span class="literal">nil</span> &#123;</div><div class="line">		chaincodehandler.readyNotify = chrte2.handler.readyNotify</div><div class="line">		chrte2.handler = chaincodehandler</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> chaincodeSupport.userRunsCC == <span class="literal">false</span> &#123;</div><div class="line">			<span class="comment">//this chaincode was not launched by the peer and is attempting</span></div><div class="line">			<span class="comment">//to register. Don't allow this.</span></div><div class="line">			<span class="keyword">return</span> errors.Errorf(<span class="string">"peer will not accept external chaincode connection %v (except in dev mode)"</span>, chaincodehandler.ChaincodeID)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 已经注册的 chaincode handler 加入到 map 中，chaincodeRTEnv 好像没有用，就是包装一下 handler</span></div><div class="line">		chaincodeSupport.runningChaincodes.chaincodeMap[key] = &amp;chaincodeRTEnv&#123;handler: chaincodehandler&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	chaincodehandler.registered = <span class="literal">true</span></div><div class="line"></div><div class="line">	<span class="comment">//now we are ready to receive messages and send back responses</span></div><div class="line">	chaincodehandler.txCtxs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*transactionContext)</div><div class="line">	chaincodehandler.txidMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</div><div class="line"></div><div class="line">	chaincodeLogger.Debugf(<span class="string">"registered handler complete for chaincode %s"</span>, key)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="gossip-comm"><a href="#gossip-comm" class="headerlink" title="gossip/comm"></a>gossip/comm</h1><p>里面会创建一个 gRPC server，实现 gossip.proto service 接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> mspMessageCryptoService <span class="keyword">struct</span> &#123;</div><div class="line">	channelPolicyManagerGetter policies.ChannelPolicyManagerGetter</div><div class="line">	localSigner                crypto.LocalSigner</div><div class="line">	deserializer               mgmt.DeserializersManager</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspMessageCryptoService)</span> <span class="title">VerifyBlock</span><span class="params">(chainID common.ChainID, seqNum <span class="keyword">uint64</span>, signedBlock []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="protos-gossip-message-pb-go"><a href="#protos-gossip-message-pb-go" class="headerlink" title="protos/gossip/message.pb.go"></a>protos/gossip/message.pb.go</h1><p>定义了一个 <code>StateInfo</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> StateInfo <span class="keyword">struct</span> &#123;</div><div class="line">	Metadata  []<span class="keyword">byte</span>    <span class="string">`protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`</span></div><div class="line">	Timestamp *PeerTime <span class="string">`protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`</span></div><div class="line">	PkiId     []<span class="keyword">byte</span>    <span class="string">`protobuf:"bytes,3,opt,name=pki_id,json=pkiId,proto3" json:"pki_id,omitempty"`</span></div><div class="line">	<span class="comment">// channel_MAC is an authentication code that proves</span></div><div class="line">	<span class="comment">// that the peer that sent this message knows</span></div><div class="line">	<span class="comment">// the name of the channel.</span></div><div class="line">	<span class="comment">// Channel_MAC 是由 peer 的 PkiId 和 chainid 计算出来的，用于确认该 peer 是否真正知道 chainid</span></div><div class="line">	Channel_MAC []<span class="keyword">byte</span>      <span class="string">`protobuf:"bytes,4,opt,name=channel_MAC,json=channelMAC,proto3" json:"channel_MAC,omitempty"`</span></div><div class="line">	Properties  *Properties <span class="string">`protobuf:"bytes,5,opt,name=properties" json:"properties,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Properties <span class="keyword">struct</span> &#123;</div><div class="line">	LedgerHeight <span class="keyword">uint64</span> <span class="string">`protobuf:"varint,1,opt,name=ledger_height,json=ledgerHeight" json:"ledger_height,omitempty"`</span></div><div class="line">	LeftChannel  <span class="keyword">bool</span>   <span class="string">`protobuf:"varint,2,opt,name=left_channel,json=leftChannel" json:"left_channel,omitempty"`</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>GossipChannel</code> 在创建时，会定义的发送自己这个 peer 的对应该 channel 的 StateInfo，同时也定时请求该通道内其他 peer 的 StateInfo，重要的是 StateInfo 中的 LedgerHeight 信息。     </p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><p>GossipService -&gt; Gossip -&gt; GossipChannel -&gt; PullEngine</p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#peer-启动后是如何获取-channel-中的-block-？"><span class="toc-number">1.</span> <span class="toc-text">peer 启动后是如何获取 channel 中的 block ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Merkle-tree"><span class="toc-number">2.</span> <span class="toc-text">Merkle tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vscc-校验交易过程"><span class="toc-number">3.</span> <span class="toc-text">vscc 校验交易过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#commit-block-过程"><span class="toc-number">4.</span> <span class="toc-text">commit block 过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gossip-协议介绍"><span class="toc-number">5.</span> <span class="toc-text">Gossip 协议介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fabric-中的-pull-based-gossip-实现"><span class="toc-number">6.</span> <span class="toc-text">Fabric 中的 pull-based gossip 实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-中私密数据的保护"><span class="toc-number">7.</span> <span class="toc-text">fabric 中私密数据的保护</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#发送-private-data-过程"><span class="toc-number">8.</span> <span class="toc-text">发送 private data 过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gossip-comm"><span class="toc-number">9.</span> <span class="toc-text">gossip/comm</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#protos-gossip-message-pb-go"><span class="toc-number">10.</span> <span class="toc-text">protos/gossip/message.pb.go</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据流"><span class="toc-number">11.</span> <span class="toc-text">数据流</span></a></li></ol>
    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 Landleany
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


