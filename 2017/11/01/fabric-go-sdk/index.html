<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="不错的学习文档  go 包管理器，基本是基于vendor目录链接官方依赖包管理工具：dep12$ dep init    初始化$ dep ensure  分析源码，将项目所需的库填充(populate)至vendor目录下 lock.json 和 package.json一般来说依赖包管理器会有两个文件：  package.json 用户定义的文件，里面定义了项目依赖的库的版本(^,~表示版本">
<meta property="og:type" content="article">
<meta property="og:title" content="fabric-go-sdk笔记">
<meta property="og:url" content="http://yoursite.com/2017/11/01/fabric-go-sdk/index.html">
<meta property="og:site_name" content="Drip">
<meta property="og:description" content="不错的学习文档  go 包管理器，基本是基于vendor目录链接官方依赖包管理工具：dep12$ dep init    初始化$ dep ensure  分析源码，将项目所需的库填充(populate)至vendor目录下 lock.json 和 package.json一般来说依赖包管理器会有两个文件：  package.json 用户定义的文件，里面定义了项目依赖的库的版本(^,~表示版本">
<meta property="og:updated_time" content="2017-11-18T14:22:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fabric-go-sdk笔记">
<meta name="twitter:description" content="不错的学习文档  go 包管理器，基本是基于vendor目录链接官方依赖包管理工具：dep12$ dep init    初始化$ dep ensure  分析源码，将项目所需的库填充(populate)至vendor目录下 lock.json 和 package.json一般来说依赖包管理器会有两个文件：  package.json 用户定义的文件，里面定义了项目依赖的库的版本(^,~表示版本">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>fabric-go-sdk笔记</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2017/11/11/fabric_1/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2017/10/22/golang/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2017/11/01/fabric-go-sdk/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&text=fabric-go-sdk笔记"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&is_video=false&description=fabric-go-sdk笔记"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=fabric-go-sdk笔记&body=Check out this article: http://yoursite.com/2017/11/01/fabric-go-sdk/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&name=fabric-go-sdk笔记&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-包管理器，基本是基于vendor目录"><span class="toc-number">1.</span> <span class="toc-text">go 包管理器，基本是基于vendor目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lock-json-和-package-json"><span class="toc-number">2.</span> <span class="toc-text">lock.json 和 package.json</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bccsp"><span class="toc-number">3.</span> <span class="toc-text">bccsp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fixture"><span class="toc-number">4.</span> <span class="toc-text">fixture</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkcs11"><span class="toc-number">5.</span> <span class="toc-text">pkcs11</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BCCSP服务"><span class="toc-number">6.</span> <span class="toc-text">BCCSP服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目录结构"><span class="toc-number">7.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-client-和-sdk-client-的区别"><span class="toc-number">8.</span> <span class="toc-text">fabric-client 和 sdk-client 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSR"><span class="toc-number">9.</span> <span class="toc-text">CSR</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-ca-client-的-Enroll-方法，先在本地调用-GenCSR-生成私钥和CSR请求-包含公钥-，然后再用CSR请求fabric-ca-服务端。"><span class="toc-number">10.</span> <span class="toc-text">fabric-ca client 的 Enroll 方法，先在本地调用 GenCSR 生成私钥和CSR请求(包含公钥)，然后再用CSR请求fabric-ca 服务端。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#我所理解的MSP和TLS证书秘钥配置"><span class="toc-number">11.</span> <span class="toc-text">我所理解的MSP和TLS证书秘钥配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DSA-ECDSA-与-RSA-的区别"><span class="toc-number">12.</span> <span class="toc-text">DSA/ECDSA 与 RSA 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#签名和加密的区别"><span class="toc-number">13.</span> <span class="toc-text">签名和加密的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CredentialManager"><span class="toc-number">14.</span> <span class="toc-text">CredentialManager</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-以组织为单位"><span class="toc-number">15.</span> <span class="toc-text">MSP 以组织为单位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#User-interface-的实现在-pkg-fabric-client-identity-identity-go"><span class="toc-number">16.</span> <span class="toc-text">User interface 的实现在 pkg/fabric-client/identity/identity.go</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sdk-NewPreEnrolledUser-返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert"><span class="toc-number">17.</span> <span class="toc-text">sdk.NewPreEnrolledUser 返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FabricSDK-与-FabricClient-的区别"><span class="toc-number">18.</span> <span class="toc-text">FabricSDK 与 FabricClient 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Config-接口的-TLSCACertPool-tlscert-string-方法"><span class="toc-number">19.</span> <span class="toc-text">Config 接口的 TLSCACertPool(tlscert string) 方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-和-TLS-的应用"><span class="toc-number">20.</span> <span class="toc-text">MSP 和 TLS 的应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-中的各种Provider-是由二次工厂产生"><span class="toc-number">21.</span> <span class="toc-text">SDK 中的各种Provider 是由二次工厂产生</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-用到的MSP和TLS证书和私钥目录配置在config-yaml中的cryptoconfig-path下"><span class="toc-number">22.</span> <span class="toc-text">SDK 用到的MSP和TLS证书和私钥目录配置在config.yaml中的cryptoconfig.path下</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SKD-提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。"><span class="toc-number">23.</span> <span class="toc-text">SKD 提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Channel-pkg-fabric-client-channel"><span class="toc-number">24.</span> <span class="toc-text">Channel (pkg/fabric-client/channel)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkg-fabric-client-channel-block-go-作用"><span class="toc-number">25.</span> <span class="toc-text">pkg/fabric-client/channel/block.go 作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#查询一个peer加入的所有channels"><span class="toc-number">26.</span> <span class="toc-text">查询一个peer加入的所有channels</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#crypto-config目录结构"><span class="toc-number">27.</span> <span class="toc-text">crypto-config目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-compose-启动某个yaml配置文件时，可以通过读取同目录下的-env-文件来配置环境变量"><span class="toc-number">28.</span> <span class="toc-text">docker-compose 启动某个yaml配置文件时，可以通过读取同目录下的 .env 文件来配置环境变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChannelClient-与-Channel-不同"><span class="toc-number">29.</span> <span class="toc-text">ChannelClient 与 Channel 不同</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DiscoveryProvider"><span class="toc-number">30.</span> <span class="toc-text">DiscoveryProvider</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SelectionProvider"><span class="toc-number">31.</span> <span class="toc-text">SelectionProvider</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Session-结构"><span class="toc-number">32.</span> <span class="toc-text">Session 结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SessionFactory"><span class="toc-number">33.</span> <span class="toc-text">SessionFactory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#批量删除镜像"><span class="toc-number">34.</span> <span class="toc-text">批量删除镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BaseSetupImpl-只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。-Initialize"><span class="toc-number">35.</span> <span class="toc-text">BaseSetupImpl 只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。[Initialize]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UpdateCC-的原理"><span class="toc-number">36.</span> <span class="toc-text">UpdateCC 的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-中发送-Query-和-Invoke-的区别"><span class="toc-number">37.</span> <span class="toc-text">SDK 中发送 Query 和 Invoke 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-与-PEER-的关系"><span class="toc-number">38.</span> <span class="toc-text">MSP 与 PEER 的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cauthdsl-包"><span class="toc-number">39.</span> <span class="toc-text">cauthdsl 包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ESCC-负责背书endorse的系统chaincode"><span class="toc-number">40.</span> <span class="toc-text">ESCC 负责背书endorse的系统chaincode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VSCC-策略检查"><span class="toc-number">41.</span> <span class="toc-text">VSCC 策略检查</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同一条Channel上的各个合约里面的字段是独立的还是公用的？"><span class="toc-number">42.</span> <span class="toc-text">同一条Channel上的各个合约里面的字段是独立的还是公用的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统chaincode都是-a-文件"><span class="toc-number">43.</span> <span class="toc-text">系统chaincode都是 .a 文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#configtx-yaml"><span class="toc-number">44.</span> <span class="toc-text">configtx.yaml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀"><span class="toc-number">45.</span> <span class="toc-text">不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用同一条数据库连接的时候，并发是必须加锁。"><span class="toc-number">46.</span> <span class="toc-text">使用同一条数据库连接的时候，并发是必须加锁。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chain-与-channel-区分"><span class="toc-number">47.</span> <span class="toc-text">chain 与 channel 区分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一致性"><span class="toc-number">48.</span> <span class="toc-text">一致性</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        fabric-go-sdk笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Drip</span>
      </span>
      
    <div class="postdate">
        <time datetime="2017-11-01T02:30:30.000Z" itemprop="datePublished">2017-11-01</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p><a href="http://blog.csdn.net/idsuf698987/article/list/2" target="_blank" rel="external">不错的学习文档</a></p>
</blockquote>
<h1 id="go-包管理器，基本是基于vendor目录"><a href="#go-包管理器，基本是基于vendor目录" class="headerlink" title="go 包管理器，基本是基于vendor目录"></a>go 包管理器，基本是基于vendor目录</h1><p><a href="https://ieevee.com/tech/2017/07/10/go-import.html" target="_blank" rel="external">链接</a><br>官方依赖包管理工具：dep<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ dep init    初始化</div><div class="line">$ dep ensure  分析源码，将项目所需的库填充(populate)至vendor目录下</div></pre></td></tr></table></figure></p>
<h1 id="lock-json-和-package-json"><a href="#lock-json-和-package-json" class="headerlink" title="lock.json 和 package.json"></a>lock.json 和 package.json</h1><p>一般来说依赖包管理器会有两个文件：</p>
<ol>
<li>package.json 用户定义的文件，里面定义了项目依赖的库的版本(^,~表示版本的范围)</li>
<li>lock.json 自动生成，里面是管理器自动从当前依赖库中读取的具体reversion(精确定义当前的依赖库版本，因为package.json中可能只定义了“^1.0.3”这种表示大版本相同的最新版本，而这类定义非常不精确，从而导致某个大版本下的最新版本不兼容项目的问题)</li>
</ol>
<h1 id="bccsp"><a href="#bccsp" class="headerlink" title="bccsp"></a>bccsp</h1><p>Fabric的密码算法模块BCCSP（blockchain crypto service provider)  </p>
<h1 id="fixture"><a href="#fixture" class="headerlink" title="fixture"></a>fixture</h1><p>配件的意思</p>
<h1 id="pkcs11"><a href="#pkcs11" class="headerlink" title="pkcs11"></a>pkcs11</h1><blockquote>
<p>一套统一的API接口</p>
</blockquote>
<p>公钥密码学标准（PKCS）是由RSA实验室与一个非正式联盟合作共同开发的一套公钥密码学的标准，这个非正式联盟最初包括Apple, Microsoft, DEC, Lotus, Sun 和 MIT。PKCS已经被OIW（OSI 标准实现研讨会）作为一个OSI标准实现。PKCS是基于二进制和ASCII编码来设计的，也兼容 ITU-T X.509 标准。已经发布的标准有PKCS #1, #3, #5, #7, #8, #9, #10 #11, #12, and #15。PKCS #13 and #14 正在开发中。</p>
<p>PKCS包括算法指定（algorithm-specific）和算法独立（algorithm-independent）两种实现标准。多种算法被支持，包括RSA算法和 Diffie-Hellman 密钥交换算法，然而只有后两种才特别详尽。PKCS也为数字签名、数字信封、可扩展证书 定义了一种算法独立（algorithm-independent）的语法；这就意味着任何加密算法都可以实现这套标准的语法，并且因此获得互操作性。</p>
<h1 id="BCCSP服务"><a href="#BCCSP服务" class="headerlink" title="BCCSP服务"></a>BCCSP服务</h1><p>BCCSP，是blockchain cryptographic service provider的缩写，个人译作区域链加密服务提供者，为fabric项目提供各种加密技术，签名技术，工具的性质很强，MSP服务模块中就使用到了BCCSP。<br>BCCSP的实现有两种：pkcs11 和 SW。简单明了的解释的话（虽不太精准），就是pckcs11是硬件基础的加密服务实现，sw是软件基础的加密服务实现。<br>BCCSP 定义的接口如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> BCCSP <span class="keyword">interface</span> &#123;</div><div class="line">    <span class="comment">//根据key生成选项opts生成一个key</span></div><div class="line">    <span class="comment">//与key有关的选项opts选项要适合原始的key（与“证书是一级一级的认证”对看）</span></div><div class="line">    KeyGen(opts KeyGenOpts) (k Key, err error)</div><div class="line">    <span class="comment">//根据key获取选项opts从k中重新获取一个key</span></div><div class="line">    KeyDeriv(k Key, opts KeyDerivOpts) (dk Key, err error)</div><div class="line">    <span class="comment">//根据key导入选项opts从一个key原始的数据中导入一个key</span></div><div class="line">    KeyImport(raw <span class="keyword">interface</span>&#123;&#125;, opts KeyImportOpts) (k Key, err error)</div><div class="line">    <span class="comment">//根据SKI返回与该接口实例有联系的key</span></div><div class="line">    GetKey(ski []<span class="keyword">byte</span>) (k Key, err error)</div><div class="line">    <span class="comment">//根据哈希选项opts哈希一个消息msg，如果opts为空，则使用默认选项</span></div><div class="line">    Hash(msg []<span class="keyword">byte</span>, opts HashOpts) (hash []<span class="keyword">byte</span>, err error)</div><div class="line">    <span class="comment">//根据哈希选项opts获取hash.Hash实例，如果opts为空，则使用默认选项</span></div><div class="line">    GetHash(opts HashOpts) (h hash.Hash, err error)</div><div class="line">    <span class="comment">//根据签名者选项opts，使用k对digest进行签名，注意如果需要对一个特别大的消息的hash值</span></div><div class="line">    <span class="comment">//进行签名，调用者则负责对该特别大的消息进行hash后将其作为digest传入</span></div><div class="line">    Sign(k Key, digest []<span class="keyword">byte</span>, opts SignerOpts) (signature []<span class="keyword">byte</span>, err error)</div><div class="line">    <span class="comment">//根据鉴定者选项opts，通过对比k和digest，鉴定签名</span></div><div class="line">    Verify(k Key, signature, digest []<span class="keyword">byte</span>, opts SignerOpts) (valid <span class="keyword">bool</span>, err error)</div><div class="line">    <span class="comment">//根据加密者选项opts，使用k加密plaintext</span></div><div class="line">    Encrypt(k Key, plaintext []<span class="keyword">byte</span>, opts EncrypterOpts) (ciphertext []<span class="keyword">byte</span>, err error)</div><div class="line">    <span class="comment">//根据解密者选项opts，使用k对ciphertext进行解密</span></div><div class="line">    Decrypt(k Key, ciphertext []<span class="keyword">byte</span>, opts DecrypterOpts) (plaintext []<span class="keyword">byte</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul>
<li><p>api 目录下是各个Interface，以及这些接口函数的参数结构体，everything is in api，即这个包不会去依赖其他包<br>  -apifabclient</p>
<pre><code>- identity.go 也定义了User接口，和下面是一样的
</code></pre><ul>
<li>apifabca <ul>
<li>user.go 定义一个已经enroll的用户的User接口，实现是在pkg/fabric-client/identity/identity.go中</li>
</ul>
</li>
</ul>
</li>
<li><p>def 目录下是该sdk的所有接口</p>
<ul>
<li>fabapi 该目录下包名为fabapi，即sdk的各个api方法<ul>
<li>pkgfactory.go提供生成各个类的工厂方法</li>
</ul>
</li>
</ul>
</li>
<li>pkg 目录下才是所有类型的定义</li>
</ul>
<h1 id="fabric-client-和-sdk-client-的区别"><a href="#fabric-client-和-sdk-client-的区别" class="headerlink" title="fabric-client 和 sdk-client 的区别"></a>fabric-client 和 sdk-client 的区别</h1><p>首先pkg/fabric-client中的Client就是实现api/apifabricclient中FabricClient接口。即一样！</p>
<h1 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h1><p>Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧.</p>
<h1 id="fabric-ca-client-的-Enroll-方法，先在本地调用-GenCSR-生成私钥和CSR请求-包含公钥-，然后再用CSR请求fabric-ca-服务端。"><a href="#fabric-ca-client-的-Enroll-方法，先在本地调用-GenCSR-生成私钥和CSR请求-包含公钥-，然后再用CSR请求fabric-ca-服务端。" class="headerlink" title="fabric-ca client 的 Enroll 方法，先在本地调用 GenCSR 生成私钥和CSR请求(包含公钥)，然后再用CSR请求fabric-ca 服务端。"></a>fabric-ca client 的 Enroll 方法，先在本地调用 GenCSR 生成私钥和CSR请求(包含公钥)，然后再用CSR请求fabric-ca 服务端。</h1><h1 id="我所理解的MSP和TLS证书秘钥配置"><a href="#我所理解的MSP和TLS证书秘钥配置" class="headerlink" title="我所理解的MSP和TLS证书秘钥配置"></a>我所理解的MSP和TLS证书秘钥配置</h1><p>MSP（可以是DSA或RSA）是用来Sign的，原文和签名（利用key加密）一起发送，接受者用证书验证签名，判断身份<br>TLS是用来加密传输的（不能是DSA），接受者那边只需要配置发送者证书的根证书即可。原文加密发送。</p>
<h1 id="DSA-ECDSA-与-RSA-的区别"><a href="#DSA-ECDSA-与-RSA-的区别" class="headerlink" title="DSA/ECDSA 与 RSA 的区别"></a>DSA/ECDSA 与 RSA 的区别</h1><ol>
<li>DSA/ECDSA都只是签名算法，<strong>但不能用来加密</strong><br>DSA和ECSDA的基本架构和RSA一样，签名者持有私钥，对应公钥向全世界公开。当需要对信息签名时，签名者用私钥对信息签名，然后将<strong>签名信息</strong>和<strong>信息原文</strong>发给对方（RSA协议中，信息原文不需要发给对方，签名信息解密后就是信息原文），验证者可用签名者公开的公钥对签名信息和信息原文验证签名。由于信息长度可能比较长，在实际操作中，大家通常在信息的HASH摘要上进行签名。<br>签名的工作原理：私钥A，公钥B，原文H，签名方将用A签名H后的C和H发送给接收方。接收方用公钥B处理原文H，如果得到的值与C相同，则证明身份。<a href="http://zhiqiang.org/blog/it/das-and-ecdsa-rsa.html" target="_blank" rel="external">链接</a></li>
<li>RSA 既可以用来签名也可以用来加密传输<br>因为它不需要发送原文</li>
</ol>
<h1 id="签名和加密的区别"><a href="#签名和加密的区别" class="headerlink" title="签名和加密的区别"></a>签名和加密的区别</h1><p>签名需要传递原文，加密肯定不可以。<br>证书颁发： 原文 =&gt; hash =&gt; 私钥加密，附加在原文上<br>证书验证： 公钥解密 =&gt; hash =&gt; 证是否与原文一致。<br>签名需要保证两点：<br>（1）保证信息是由签名者自己签名发送的，签名者不能否认或难以否认；<br>（2）保证信息自签发后到收到为止未曾作过任何修改，签发的文件是真实文件。</p>
<h1 id="CredentialManager"><a href="#CredentialManager" class="headerlink" title="CredentialManager"></a>CredentialManager</h1><p>Is used for retriving user’s signing identity (ecert + private key)  </p>
<h1 id="MSP-以组织为单位"><a href="#MSP-以组织为单位" class="headerlink" title="MSP 以组织为单位"></a>MSP 以组织为单位</h1><h1 id="User-interface-的实现在-pkg-fabric-client-identity-identity-go"><a href="#User-interface-的实现在-pkg-fabric-client-identity-identity-go" class="headerlink" title="User interface 的实现在 pkg/fabric-client/identity/identity.go"></a>User interface 的实现在 pkg/fabric-client/identity/identity.go</h1><h1 id="sdk-NewPreEnrolledUser-返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert"><a href="#sdk-NewPreEnrolledUser-返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert" class="headerlink" title="sdk.NewPreEnrolledUser 返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert"></a>sdk.NewPreEnrolledUser 返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert</h1><h1 id="FabricSDK-与-FabricClient-的区别"><a href="#FabricSDK-与-FabricClient-的区别" class="headerlink" title="FabricSDK 与 FabricClient 的区别"></a>FabricSDK 与 FabricClient 的区别</h1><ol>
<li>FabricClient有一个SaveUserToStateStore方法，它首先将user对象赋给this.userContext, 然后把user持久化到stateStore中。</li>
<li>FabricSDK 提供接口操作，用于方便的生成各种Client对象，包括NewSystemClient方法用于生成FabricClient对象。并且提供<strong>NewPreEnrolledUser</strong>方法利用CredentialManager从文件系统msp目录下获得用户的私钥和证书信息，生成User对象。(这些脏活都由FabricSDK来做。)</li>
<li>FabricSDK 提供获取ChannelClient，获取Session，获取User，获取FabricClient(SystemClient)，获取Context 等方法。</li>
</ol>
<h1 id="Config-接口的-TLSCACertPool-tlscert-string-方法"><a href="#Config-接口的-TLSCACertPool-tlscert-string-方法" class="headerlink" title="Config 接口的 TLSCACertPool(tlscert string) 方法"></a>Config 接口的 TLSCACertPool(tlscert string) 方法</h1><p>如果传入tlscert路径参数，则将其存入内部的tlsCertPool(x509.CertPool)，最后返回tlsCertPool对象。这个对象里面放着所有信任的根证书。<br>peer的证书tls证书是由org的tls ca证书签发的</p>
<h1 id="MSP-和-TLS-的应用"><a href="#MSP-和-TLS-的应用" class="headerlink" title="MSP 和 TLS 的应用"></a>MSP 和 TLS 的应用</h1><p>首先MSP是签名，而TLS是加密。其次，<br>MSP的工作原理：  </p>
<pre><code>1. 把MSP证书（由组织MSP的私钥签发）发送给对方 
2. 对方验证该证书是其所属组织签发，并获得其中MSP公钥
3. 己方将信息和签名发送给对方
4. 对方用获得的公钥验证签名
User的PrivateKey指的就是MSP下的私钥
</code></pre><p>TLS的工作原理：<br>    应该很了解</p>
<h1 id="SDK-中的各种Provider-是由二次工厂产生"><a href="#SDK-中的各种Provider-是由二次工厂产生" class="headerlink" title="SDK 中的各种Provider 是由二次工厂产生"></a>SDK 中的各种Provider 是由二次工厂产生</h1><p>ConfigProvider/Cryptosuite/StateStoreProvider等是由sdk.ProviderFactory产生的，而ProviderFactory也是由工厂方法生成的。</p>
<h1 id="SDK-用到的MSP和TLS证书和私钥目录配置在config-yaml中的cryptoconfig-path下"><a href="#SDK-用到的MSP和TLS证书和私钥目录配置在config-yaml中的cryptoconfig-path下" class="headerlink" title="SDK 用到的MSP和TLS证书和私钥目录配置在config.yaml中的cryptoconfig.path下"></a>SDK 用到的MSP和TLS证书和私钥目录配置在config.yaml中的cryptoconfig.path下</h1><p>这个地址从config.CryptoConfigPath()中读出，在NewCredentialManager（凭证管理器）中被用到，用于获得Enroll用户的身份。</p>
<h1 id="SKD-提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。"><a href="#SKD-提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。" class="headerlink" title="SKD 提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。"></a>SKD 提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。</h1><p>只有管理员可以进行创建/更新channel，安装和实例化chaincode（由SDK控制权限）。 配置在config.yaml的organizations.Orgxx.adminPrivateKey和signedCert下。（生产环境中，不能配置在文件中）<br>管理员可以执行的方法被集中定义在<strong>pkg/fabric-txn/admin/transactionconfig.go</strong> ，包名admin中。该文件的作用是集中放置admin可以执行的方法。实际权限还是要手动设置（因为Fabric网络不区分admin和普通用户）</p>
<ol>
<li>SendInstallCC</li>
<li>SendInstantiateCC</li>
<li>SendUpgradeCC</li>
<li>CreateOrUpdateChannel</li>
<li>JoinChannel</li>
<li>changeGOPATHToDeploy</li>
<li>resetGOPATH<br>其实上面的操作，普通用户也可以操作。我们需要通过手动控制SDK此时FabricClient对象中的User是Admin身份，然后调用该包内的方法。其实具体调用的自方法都在FabricClient中，例如CreateChannel， SendInstantiateProposal等等。</li>
</ol>
<h1 id="Channel-pkg-fabric-client-channel"><a href="#Channel-pkg-fabric-client-channel" class="headerlink" title="Channel (pkg/fabric-client/channel)"></a>Channel (pkg/fabric-client/channel)</h1><p>这只是SDK中的一个对象，封装了channel的一些配置。该对象内部有个clientContext接口，刚好FabricClient满足该接口，因此只要传递FabricClient对象进去即可。通过工厂方法NewChannel(name string, client fab.FabricClient)创建。</p>
<h1 id="pkg-fabric-client-channel-block-go-作用"><a href="#pkg-fabric-client-channel-block-go-作用" class="headerlink" title="pkg/fabric-client/channel/block.go 作用"></a>pkg/fabric-client/channel/block.go 作用</h1><h1 id="查询一个peer加入的所有channels"><a href="#查询一个peer加入的所有channels" class="headerlink" title="查询一个peer加入的所有channels"></a>查询一个peer加入的所有channels</h1><p>FabricClient的方法QueryChannels，其实是通过运行该peer上的cscc中的GetChannels方法。FabricClient提供了一个queryBySystemChaincodeByTarget方法来调用系统合约。</p>
<h1 id="crypto-config目录结构"><a href="#crypto-config目录结构" class="headerlink" title="crypto-config目录结构"></a>crypto-config目录结构</h1><ul>
<li>peer </li>
</ul>
<h1 id="docker-compose-启动某个yaml配置文件时，可以通过读取同目录下的-env-文件来配置环境变量"><a href="#docker-compose-启动某个yaml配置文件时，可以通过读取同目录下的-env-文件来配置环境变量" class="headerlink" title="docker-compose 启动某个yaml配置文件时，可以通过读取同目录下的 .env 文件来配置环境变量"></a>docker-compose 启动某个yaml配置文件时，可以通过读取同目录下的 .env 文件来配置环境变量</h1><h1 id="ChannelClient-与-Channel-不同"><a href="#ChannelClient-与-Channel-不同" class="headerlink" title="ChannelClient 与 Channel 不同"></a>ChannelClient 与 Channel 不同</h1><ol>
<li>Channel 对象是Fabric中channel的抽象对象，里面封装了channel交互操作的一些方法。</li>
<li>而ChannelClient provides a handler to interact with peers on specified channel. 例如<br>Query()<br>QueryWithOpts()  // 这个Opt就是提供一个chan供sync或者async调用<br>ExecuteTx()<br>即ChannelClient提供了操作这个Channel对象的上层封装方法。ChannelClient内部拥有一个Channel对象的引用。</li>
</ol>
<h1 id="DiscoveryProvider"><a href="#DiscoveryProvider" class="headerlink" title="DiscoveryProvider"></a>DiscoveryProvider</h1><p>DiscoveryProvider 提供一个 NewDiscoveryService(channelID string) 获得特定链的peer发现服务。而获得的DiscoveryService对象的GetPeers()就可以拿到链上的所有peer。<br>目前SDK只提供了一个staticdiscovery的实现，其实就是解析config配置文件，找到所有peers。</p>
<h1 id="SelectionProvider"><a href="#SelectionProvider" class="headerlink" title="SelectionProvider"></a>SelectionProvider</h1><p>类似上面，默认的也是StaticSelection的简单实现。</p>
<h1 id="Session-结构"><a href="#Session-结构" class="headerlink" title="Session 结构"></a>Session 结构</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</div><div class="line">    factory context.SessionClientFactroy</div><div class="line">    user    fab.User</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h1><p>NewChannelClient</p>
<h1 id="批量删除镜像"><a href="#批量删除镜像" class="headerlink" title="批量删除镜像"></a>批量删除镜像</h1><p>docker images | grep xxx | awk ‘{print $3}’ | xargs docker rmi</p>
<h1 id="BaseSetupImpl-只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。-Initialize"><a href="#BaseSetupImpl-只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。-Initialize" class="headerlink" title="BaseSetupImpl 只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。[Initialize]"></a>BaseSetupImpl 只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。[Initialize]</h1><h1 id="UpdateCC-的原理"><a href="#UpdateCC-的原理" class="headerlink" title="UpdateCC 的原理"></a>UpdateCC 的原理</h1><ol>
<li>首先设置一个新的verison号</li>
<li>发送安装这个cc</li>
<li>发送初始化请求至这个cc</li>
</ol>
<h1 id="SDK-中发送-Query-和-Invoke-的区别"><a href="#SDK-中发送-Query-和-Invoke-的区别" class="headerlink" title="SDK 中发送 Query 和 Invoke 的区别"></a>SDK 中发送 Query 和 Invoke 的区别</h1><ol>
<li>Query： 只调用sendTransactionProposal </li>
<li>Invoke: 先调用sendTransactionProposal，然后调用sendTransaction （一气呵成，因此我们必须设置发送给背书策略中需要的peer）</li>
<li>目前，无论是Fabric还是SDK，都是进入Chaincode的Invoke方法(不能修改也无法修改！)，不会进Query方法（已经废弃，原因是query和invoke都是发送的Proposal）。之所以区分开invoke和query（SDK中是Query() / Invoke()，或者Fabric中peer chaincode invoke / peer chaincode query ，这是因为要区别是否还有第二个步骤sendTransaction）</li>
<li>ChannelClient.Query() 会发送请求到该channel上的所有peer 并返回所有请求的响应包数组，但是不用担心其中的节点挂掉造成无畏的等待。因为返回的数组里面只会包含成功返回的响应。最后Query返回数组中第一个响应作为返回值。</li>
<li>无论是Query 或者 Invoke，其第一阶段都是调用 internal.CreateAndSendTransactionProposal 来发送Proposal请求，其返回的响应数组中的每个响应结构体TransactionProposalResponse 中有一个Endorser字段表示背书签名。而Query()方法只返回了第一个响应结构体中的ProposalResponse字段作为结果</li>
</ol>
<h1 id="MSP-与-PEER-的关系"><a href="#MSP-与-PEER-的关系" class="headerlink" title="MSP 与 PEER 的关系"></a>MSP 与 PEER 的关系</h1><h1 id="cauthdsl-包"><a href="#cauthdsl-包" class="headerlink" title="cauthdsl 包"></a>cauthdsl 包</h1><p>cauthdsl 用来build产生背书策略（一种语法）</p>
<h1 id="ESCC-负责背书endorse的系统chaincode"><a href="#ESCC-负责背书endorse的系统chaincode" class="headerlink" title="ESCC 负责背书endorse的系统chaincode"></a>ESCC 负责背书endorse的系统chaincode</h1><p>peer用Member的身份还是Admin的身份才背书该Proposal，取决于它用的MSP是谁的，例如下面的docker-compose.yaml的第二条就是使用Admin的MSP。注意，不要把第三条的TLS的证书也改成Admin的，这样会导致tls验证失败。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">volumes:</div><div class="line">  - /var/run/:/host/var/run/</div><div class="line">  - ./channel/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp:/etc/hyperledger/msp/peer</div><div class="line">  - ./channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/tls/peer</div></pre></td></tr></table></figure></p>
<h1 id="VSCC-策略检查"><a href="#VSCC-策略检查" class="headerlink" title="VSCC 策略检查"></a>VSCC 策略检查</h1><p>当一个peer收到一个block数据时，开启检查该条交易的背书验证</p>
<h1 id="同一条Channel上的各个合约里面的字段是独立的还是公用的？"><a href="#同一条Channel上的各个合约里面的字段是独立的还是公用的？" class="headerlink" title="同一条Channel上的各个合约里面的字段是独立的还是公用的？"></a>同一条Channel上的各个合约里面的字段是独立的还是公用的？</h1><h1 id="系统chaincode都是-a-文件"><a href="#系统chaincode都是-a-文件" class="headerlink" title="系统chaincode都是 .a 文件"></a>系统chaincode都是 .a 文件</h1><h1 id="configtx-yaml"><a href="#configtx-yaml" class="headerlink" title="configtx.yaml"></a>configtx.yaml</h1><ol>
<li>AdminPrincipal: Role.ADMIN / Role.MEMBER 表示那些人具有Admin的权限:<ul>
<li>create/update channel</li>
<li>install/instantiate chaincode</li>
<li>query installed/instantiated chaincode</li>
</ul>
</li>
<li>AdminPrincipal 不填表示默认为Role.Admin，即只有管理员的MSP才可以执行上述属于管理员的权限</li>
<li>这个跟Endorsing 用的权限无关</li>
</ol>
<h1 id="不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀"><a href="#不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀" class="headerlink" title="不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀"></a>不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀</h1><p>因此想要访问另一个合约中的某个值，只能通过<strong>合约调合约</strong>来实现。</p>
<h1 id="使用同一条数据库连接的时候，并发是必须加锁。"><a href="#使用同一条数据库连接的时候，并发是必须加锁。" class="headerlink" title="使用同一条数据库连接的时候，并发是必须加锁。"></a>使用同一条数据库连接的时候，并发是必须加锁。</h1><p>数据库即使有并发处理，也要求是不同的数据库连接。</p>
<h1 id="chain-与-channel-区分"><a href="#chain-与-channel-区分" class="headerlink" title="chain 与 channel 区分"></a>chain 与 channel 区分</h1><ol>
<li>chain链，即block构成的chain，也叫blockchain，其隶属于某个通道channel</li>
<li>channel通道</li>
<li>orderer上还有一个系统链systemchain，而genesis.block是其第一块block。任何组织、成员或通道的改变，都会产生新的block，连接到这个systemchain上</li>
<li>管理员创建某个channel通道以后，会得到一个channel.block，它就是这个channel中的blockchain的首块block </li>
<li>账本是隶属于某个channel的，由blockchain和world state构成</li>
</ol>
<h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p>例子：组织A和组织B现在加入同一个通道channel，现在两家的管理员分别在自家的所有peer上安装chaincode，如果两家都动了坏心思，分别安装了修改后的对自家有利的合约（而不是提前商量好的合约）。 但是毕竟是两家一起玩的事情，因此合约的背书策略肯定是设置成需要两家的签名的(因为没有两家的签名的话，拿出去怎么让其他人信服)。这样，当组织A发起Invoke时，需要也发给组织B的peer，由于两家合约不同，计算出的结果不同的话，最后进行到channel中所有peer commit 阶段时，由于结果不一致而commit失败！</p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-包管理器，基本是基于vendor目录"><span class="toc-number">1.</span> <span class="toc-text">go 包管理器，基本是基于vendor目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lock-json-和-package-json"><span class="toc-number">2.</span> <span class="toc-text">lock.json 和 package.json</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bccsp"><span class="toc-number">3.</span> <span class="toc-text">bccsp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fixture"><span class="toc-number">4.</span> <span class="toc-text">fixture</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkcs11"><span class="toc-number">5.</span> <span class="toc-text">pkcs11</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BCCSP服务"><span class="toc-number">6.</span> <span class="toc-text">BCCSP服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目录结构"><span class="toc-number">7.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-client-和-sdk-client-的区别"><span class="toc-number">8.</span> <span class="toc-text">fabric-client 和 sdk-client 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSR"><span class="toc-number">9.</span> <span class="toc-text">CSR</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-ca-client-的-Enroll-方法，先在本地调用-GenCSR-生成私钥和CSR请求-包含公钥-，然后再用CSR请求fabric-ca-服务端。"><span class="toc-number">10.</span> <span class="toc-text">fabric-ca client 的 Enroll 方法，先在本地调用 GenCSR 生成私钥和CSR请求(包含公钥)，然后再用CSR请求fabric-ca 服务端。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#我所理解的MSP和TLS证书秘钥配置"><span class="toc-number">11.</span> <span class="toc-text">我所理解的MSP和TLS证书秘钥配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DSA-ECDSA-与-RSA-的区别"><span class="toc-number">12.</span> <span class="toc-text">DSA/ECDSA 与 RSA 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#签名和加密的区别"><span class="toc-number">13.</span> <span class="toc-text">签名和加密的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CredentialManager"><span class="toc-number">14.</span> <span class="toc-text">CredentialManager</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-以组织为单位"><span class="toc-number">15.</span> <span class="toc-text">MSP 以组织为单位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#User-interface-的实现在-pkg-fabric-client-identity-identity-go"><span class="toc-number">16.</span> <span class="toc-text">User interface 的实现在 pkg/fabric-client/identity/identity.go</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sdk-NewPreEnrolledUser-返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert"><span class="toc-number">17.</span> <span class="toc-text">sdk.NewPreEnrolledUser 返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FabricSDK-与-FabricClient-的区别"><span class="toc-number">18.</span> <span class="toc-text">FabricSDK 与 FabricClient 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Config-接口的-TLSCACertPool-tlscert-string-方法"><span class="toc-number">19.</span> <span class="toc-text">Config 接口的 TLSCACertPool(tlscert string) 方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-和-TLS-的应用"><span class="toc-number">20.</span> <span class="toc-text">MSP 和 TLS 的应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-中的各种Provider-是由二次工厂产生"><span class="toc-number">21.</span> <span class="toc-text">SDK 中的各种Provider 是由二次工厂产生</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-用到的MSP和TLS证书和私钥目录配置在config-yaml中的cryptoconfig-path下"><span class="toc-number">22.</span> <span class="toc-text">SDK 用到的MSP和TLS证书和私钥目录配置在config.yaml中的cryptoconfig.path下</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SKD-提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。"><span class="toc-number">23.</span> <span class="toc-text">SKD 提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Channel-pkg-fabric-client-channel"><span class="toc-number">24.</span> <span class="toc-text">Channel (pkg/fabric-client/channel)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkg-fabric-client-channel-block-go-作用"><span class="toc-number">25.</span> <span class="toc-text">pkg/fabric-client/channel/block.go 作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#查询一个peer加入的所有channels"><span class="toc-number">26.</span> <span class="toc-text">查询一个peer加入的所有channels</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#crypto-config目录结构"><span class="toc-number">27.</span> <span class="toc-text">crypto-config目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-compose-启动某个yaml配置文件时，可以通过读取同目录下的-env-文件来配置环境变量"><span class="toc-number">28.</span> <span class="toc-text">docker-compose 启动某个yaml配置文件时，可以通过读取同目录下的 .env 文件来配置环境变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChannelClient-与-Channel-不同"><span class="toc-number">29.</span> <span class="toc-text">ChannelClient 与 Channel 不同</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DiscoveryProvider"><span class="toc-number">30.</span> <span class="toc-text">DiscoveryProvider</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SelectionProvider"><span class="toc-number">31.</span> <span class="toc-text">SelectionProvider</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Session-结构"><span class="toc-number">32.</span> <span class="toc-text">Session 结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SessionFactory"><span class="toc-number">33.</span> <span class="toc-text">SessionFactory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#批量删除镜像"><span class="toc-number">34.</span> <span class="toc-text">批量删除镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BaseSetupImpl-只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。-Initialize"><span class="toc-number">35.</span> <span class="toc-text">BaseSetupImpl 只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。[Initialize]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UpdateCC-的原理"><span class="toc-number">36.</span> <span class="toc-text">UpdateCC 的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-中发送-Query-和-Invoke-的区别"><span class="toc-number">37.</span> <span class="toc-text">SDK 中发送 Query 和 Invoke 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-与-PEER-的关系"><span class="toc-number">38.</span> <span class="toc-text">MSP 与 PEER 的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cauthdsl-包"><span class="toc-number">39.</span> <span class="toc-text">cauthdsl 包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ESCC-负责背书endorse的系统chaincode"><span class="toc-number">40.</span> <span class="toc-text">ESCC 负责背书endorse的系统chaincode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VSCC-策略检查"><span class="toc-number">41.</span> <span class="toc-text">VSCC 策略检查</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同一条Channel上的各个合约里面的字段是独立的还是公用的？"><span class="toc-number">42.</span> <span class="toc-text">同一条Channel上的各个合约里面的字段是独立的还是公用的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统chaincode都是-a-文件"><span class="toc-number">43.</span> <span class="toc-text">系统chaincode都是 .a 文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#configtx-yaml"><span class="toc-number">44.</span> <span class="toc-text">configtx.yaml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀"><span class="toc-number">45.</span> <span class="toc-text">不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用同一条数据库连接的时候，并发是必须加锁。"><span class="toc-number">46.</span> <span class="toc-text">使用同一条数据库连接的时候，并发是必须加锁。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chain-与-channel-区分"><span class="toc-number">47.</span> <span class="toc-text">chain 与 channel 区分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一致性"><span class="toc-number">48.</span> <span class="toc-text">一致性</span></a></li></ol>
    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2017 Landleany
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


