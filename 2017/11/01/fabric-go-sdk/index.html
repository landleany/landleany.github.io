<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="不错的学习文档  go 包管理器，基本是基于vendor目录链接官方依赖包管理工具：dep12$ dep init    初始化$ dep ensure  分析源码，将项目所需的库填充(populate)至vendor目录下 lock.json 和 package.json一般来说依赖包管理器会有两个文件：  package.json 用户定义的文件，里面定义了项目依赖的库的版本(^,~表示版本">
<meta property="og:type" content="article">
<meta property="og:title" content="fabric-go-sdk笔记">
<meta property="og:url" content="http://yoursite.com/2017/11/01/fabric-go-sdk/index.html">
<meta property="og:site_name" content="Drip">
<meta property="og:description" content="不错的学习文档  go 包管理器，基本是基于vendor目录链接官方依赖包管理工具：dep12$ dep init    初始化$ dep ensure  分析源码，将项目所需的库填充(populate)至vendor目录下 lock.json 和 package.json一般来说依赖包管理器会有两个文件：  package.json 用户定义的文件，里面定义了项目依赖的库的版本(^,~表示版本">
<meta property="og:updated_time" content="2018-05-26T02:49:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fabric-go-sdk笔记">
<meta name="twitter:description" content="不错的学习文档  go 包管理器，基本是基于vendor目录链接官方依赖包管理工具：dep12$ dep init    初始化$ dep ensure  分析源码，将项目所需的库填充(populate)至vendor目录下 lock.json 和 package.json一般来说依赖包管理器会有两个文件：  package.json 用户定义的文件，里面定义了项目依赖的库的版本(^,~表示版本">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>fabric-go-sdk笔记</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2017/11/11/fabric_1/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2017/10/29/k8s/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2017/11/01/fabric-go-sdk/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&text=fabric-go-sdk笔记"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&is_video=false&description=fabric-go-sdk笔记"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=fabric-go-sdk笔记&body=Check out this article: http://yoursite.com/2017/11/01/fabric-go-sdk/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&title=fabric-go-sdk笔记"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2017/11/01/fabric-go-sdk/&name=fabric-go-sdk笔记&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-包管理器，基本是基于vendor目录"><span class="toc-number">1.</span> <span class="toc-text">go 包管理器，基本是基于vendor目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lock-json-和-package-json"><span class="toc-number">2.</span> <span class="toc-text">lock.json 和 package.json</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bccsp"><span class="toc-number">3.</span> <span class="toc-text">bccsp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fixture"><span class="toc-number">4.</span> <span class="toc-text">fixture</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkcs11"><span class="toc-number">5.</span> <span class="toc-text">pkcs11</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BCCSP服务"><span class="toc-number">6.</span> <span class="toc-text">BCCSP服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目录结构"><span class="toc-number">7.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-client-和-sdk-client-的区别"><span class="toc-number">8.</span> <span class="toc-text">fabric-client 和 sdk-client 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSR"><span class="toc-number">9.</span> <span class="toc-text">CSR</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-ca-client-的-Enroll-方法，先在本地调用-GenCSR-生成私钥和CSR请求-包含公钥-，然后再用CSR请求fabric-ca-服务端。"><span class="toc-number">10.</span> <span class="toc-text">fabric-ca client 的 Enroll 方法，先在本地调用 GenCSR 生成私钥和CSR请求(包含公钥)，然后再用CSR请求fabric-ca 服务端。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#我所理解的MSP和TLS证书秘钥配置"><span class="toc-number">11.</span> <span class="toc-text">我所理解的MSP和TLS证书秘钥配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DSA-ECDSA-与-RSA-的区别"><span class="toc-number">12.</span> <span class="toc-text">DSA/ECDSA 与 RSA 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#签名和加密的区别"><span class="toc-number">13.</span> <span class="toc-text">签名和加密的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CredentialManager"><span class="toc-number">14.</span> <span class="toc-text">CredentialManager</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-以组织为单位"><span class="toc-number">15.</span> <span class="toc-text">MSP 以组织为单位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#User-interface-的实现在-pkg-fabric-client-identity-identity-go"><span class="toc-number">16.</span> <span class="toc-text">User interface 的实现在 pkg/fabric-client/identity/identity.go</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sdk-NewPreEnrolledUser-返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert"><span class="toc-number">17.</span> <span class="toc-text">sdk.NewPreEnrolledUser 返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FabricSDK-与-FabricClient-的区别"><span class="toc-number">18.</span> <span class="toc-text">FabricSDK 与 FabricClient 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Config-接口的-TLSCACertPool-tlscert-string-方法"><span class="toc-number">19.</span> <span class="toc-text">Config 接口的 TLSCACertPool(tlscert string) 方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-和-TLS-的应用"><span class="toc-number">20.</span> <span class="toc-text">MSP 和 TLS 的应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-中的各种Provider-是由二次工厂产生"><span class="toc-number">21.</span> <span class="toc-text">SDK 中的各种Provider 是由二次工厂产生</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-用到的MSP和TLS证书和私钥目录配置在config-yaml中的cryptoconfig-path下"><span class="toc-number">22.</span> <span class="toc-text">SDK 用到的MSP和TLS证书和私钥目录配置在config.yaml中的cryptoconfig.path下</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SKD-提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。"><span class="toc-number">23.</span> <span class="toc-text">SKD 提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Channel-pkg-fabric-client-channel"><span class="toc-number">24.</span> <span class="toc-text">Channel (pkg/fabric-client/channel)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkg-fabric-client-channel-block-go-作用"><span class="toc-number">25.</span> <span class="toc-text">pkg/fabric-client/channel/block.go 作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#查询一个peer加入的所有channels"><span class="toc-number">26.</span> <span class="toc-text">查询一个peer加入的所有channels</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#crypto-config目录结构"><span class="toc-number">27.</span> <span class="toc-text">crypto-config目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-compose-启动某个yaml配置文件时，可以通过读取同目录下的-env-文件来配置环境变量"><span class="toc-number">28.</span> <span class="toc-text">docker-compose 启动某个yaml配置文件时，可以通过读取同目录下的 .env 文件来配置环境变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChannelClient-与-Channel-不同"><span class="toc-number">29.</span> <span class="toc-text">ChannelClient 与 Channel 不同</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DiscoveryProvider"><span class="toc-number">30.</span> <span class="toc-text">DiscoveryProvider</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SelectionProvider"><span class="toc-number">31.</span> <span class="toc-text">SelectionProvider</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Session-结构"><span class="toc-number">32.</span> <span class="toc-text">Session 结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SessionFactory"><span class="toc-number">33.</span> <span class="toc-text">SessionFactory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#批量删除镜像"><span class="toc-number">34.</span> <span class="toc-text">批量删除镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BaseSetupImpl-只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。-Initialize"><span class="toc-number">35.</span> <span class="toc-text">BaseSetupImpl 只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。[Initialize]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UpdateCC-的原理"><span class="toc-number">36.</span> <span class="toc-text">UpdateCC 的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-中发送-Query-和-Invoke-的区别"><span class="toc-number">37.</span> <span class="toc-text">SDK 中发送 Query 和 Invoke 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-与-PEER-的关系"><span class="toc-number">38.</span> <span class="toc-text">MSP 与 PEER 的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cauthdsl-包"><span class="toc-number">39.</span> <span class="toc-text">cauthdsl 包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ESCC-负责背书endorse的系统chaincode"><span class="toc-number">40.</span> <span class="toc-text">ESCC 负责背书endorse的系统chaincode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VSCC-策略检查"><span class="toc-number">41.</span> <span class="toc-text">VSCC 策略检查</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同一条Channel上的各个合约里面的字段是独立的还是公用的？"><span class="toc-number">42.</span> <span class="toc-text">同一条Channel上的各个合约里面的字段是独立的还是公用的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统chaincode也是有源码的，在scc文件夹中"><span class="toc-number">43.</span> <span class="toc-text">系统chaincode也是有源码的，在scc文件夹中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#configtx-yaml"><span class="toc-number">44.</span> <span class="toc-text">configtx.yaml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀"><span class="toc-number">45.</span> <span class="toc-text">不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用同一条数据库连接的时候，并发是必须加锁。"><span class="toc-number">46.</span> <span class="toc-text">使用同一条数据库连接的时候，并发是必须加锁。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chain-与-channel-区分"><span class="toc-number">47.</span> <span class="toc-text">chain 与 channel 区分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一致性"><span class="toc-number">48.</span> <span class="toc-text">一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#upgrade-chaincode"><span class="toc-number">49.</span> <span class="toc-text">upgrade chaincode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自签名证书"><span class="toc-number">50.</span> <span class="toc-text">自签名证书</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenSSL、OpenSSH、SSH、SSL-区别"><span class="toc-number">51.</span> <span class="toc-text">OpenSSL、OpenSSH、SSH、SSL 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-keygen-和-openssl-genrsa-rsa-区别"><span class="toc-number">52.</span> <span class="toc-text">ssh-keygen 和 openssl genrsa/rsa 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#当证书用于TLS时，CN必须设置成域名。而当其用作MSP或者其他用途时，可以设置成其他的值。"><span class="toc-number">53.</span> <span class="toc-text">当证书用于TLS时，CN必须设置成域名。而当其用作MSP或者其他用途时，可以设置成其他的值。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如果一些服务端不但启动了TSL，还开启了SSL客户端认证，那么客户端还需要配置自己的证书和密钥文件。（即双向TLS）"><span class="toc-number">54.</span> <span class="toc-text">如果一些服务端不但启动了TSL，还开启了SSL客户端认证，那么客户端还需要配置自己的证书和密钥文件。（即双向TLS）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-ca"><span class="toc-number">55.</span> <span class="toc-text">fabric-ca</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#世界状态的键被表示成两个组件-chaincodeID-and-ckey-的通过nil字节的级联，如：key-chaincodeID-nil-cKey。"><span class="toc-number">56.</span> <span class="toc-text">世界状态的键被表示成两个组件(chaincodeID and ckey) 的通过nil字节的级联，如：key = chaincodeID+nil+cKey。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7051-7052-7053"><span class="toc-number">57.</span> <span class="toc-text">7051, 7052, 7053</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChaincodeSupport"><span class="toc-number">58.</span> <span class="toc-text">ChaincodeSupport</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chaincodeRTEnv"><span class="toc-number">59.</span> <span class="toc-text">chaincodeRTEnv</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ccprovider-CCContext"><span class="toc-number">60.</span> <span class="toc-text">ccprovider.CCContext</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SignedProposal-和-Proposal-区别"><span class="toc-number">61.</span> <span class="toc-text">SignedProposal 和 Proposal 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#core-chaincode-exectransaction-go"><span class="toc-number">62.</span> <span class="toc-text">core/chaincode/exectransaction.go</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LSCC"><span class="toc-number">63.</span> <span class="toc-text">LSCC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TxSimulator"><span class="toc-number">64.</span> <span class="toc-text">TxSimulator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#testchainid"><span class="toc-number">65.</span> <span class="toc-text">testchainid</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多个orderer的作用"><span class="toc-number">66.</span> <span class="toc-text">多个orderer的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#solo模式下只有一个orderer"><span class="toc-number">67.</span> <span class="toc-text">solo模式下只有一个orderer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric里面好玩的地方，逻辑的复用"><span class="toc-number">68.</span> <span class="toc-text">fabric里面好玩的地方，逻辑的复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可以看看fabric下sampleconfig中的文件，其中configtx-yaml-core-yaml-orderer-yaml"><span class="toc-number">69.</span> <span class="toc-text">可以看看fabric下sampleconfig中的文件，其中configtx.yaml, core.yaml, orderer.yaml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reconfiguring-with-configtxlator"><span class="toc-number">70.</span> <span class="toc-text">Reconfiguring with configtxlator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#x509-证书-CN-SAN-详解（已验证）"><span class="toc-number">71.</span> <span class="toc-text">x509 证书 CN/SAN 详解（已验证）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pem-与-der"><span class="toc-number">72.</span> <span class="toc-text">.pem 与 .der</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Proposal-里面有个-signatureheader，里面有-signer-的-identity-的-bytes-信息。而-signed-Proposal-就是再用这个-singer-对-Proposal-进行-sign"><span class="toc-number">73.</span> <span class="toc-text">Proposal 里面有个 signatureheader，里面有 signer 的 identity 的 bytes 信息。而 signed Proposal 就是再用这个 singer 对 Proposal 进行 sign</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        fabric-go-sdk笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Drip</span>
      </span>
      
    <div class="postdate">
        <time datetime="2017-11-01T02:30:30.000Z" itemprop="datePublished">2017-11-01</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p><a href="http://blog.csdn.net/idsuf698987/article/list/2" target="_blank" rel="external">不错的学习文档</a></p>
</blockquote>
<h1 id="go-包管理器，基本是基于vendor目录"><a href="#go-包管理器，基本是基于vendor目录" class="headerlink" title="go 包管理器，基本是基于vendor目录"></a>go 包管理器，基本是基于vendor目录</h1><p><a href="https://ieevee.com/tech/2017/07/10/go-import.html" target="_blank" rel="external">链接</a><br>官方依赖包管理工具：dep<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ dep init    初始化</div><div class="line">$ dep ensure  分析源码，将项目所需的库填充(populate)至vendor目录下</div></pre></td></tr></table></figure></p>
<h1 id="lock-json-和-package-json"><a href="#lock-json-和-package-json" class="headerlink" title="lock.json 和 package.json"></a>lock.json 和 package.json</h1><p>一般来说依赖包管理器会有两个文件：</p>
<ol>
<li>package.json 用户定义的文件，里面定义了项目依赖的库的版本(^,~表示版本的范围)</li>
<li>lock.json 自动生成，里面是管理器自动从当前依赖库中读取的具体reversion(精确定义当前的依赖库版本，因为package.json中可能只定义了“^1.0.3”这种表示大版本相同的最新版本，而这类定义非常不精确，从而导致某个大版本下的最新版本不兼容项目的问题)</li>
</ol>
<h1 id="bccsp"><a href="#bccsp" class="headerlink" title="bccsp"></a>bccsp</h1><p>Fabric的密码算法模块BCCSP（blockchain crypto service provider)  </p>
<h1 id="fixture"><a href="#fixture" class="headerlink" title="fixture"></a>fixture</h1><p>配件的意思</p>
<h1 id="pkcs11"><a href="#pkcs11" class="headerlink" title="pkcs11"></a>pkcs11</h1><blockquote>
<p>一套统一的API接口</p>
</blockquote>
<p>公钥密码学标准（PKCS）是由RSA实验室与一个非正式联盟合作共同开发的一套公钥密码学的标准，这个非正式联盟最初包括Apple, Microsoft, DEC, Lotus, Sun 和 MIT。PKCS已经被OIW（OSI 标准实现研讨会）作为一个OSI标准实现。PKCS是基于二进制和ASCII编码来设计的，也兼容 ITU-T X.509 标准。已经发布的标准有PKCS #1, #3, #5, #7, #8, #9, #10 #11, #12, and #15。PKCS #13 and #14 正在开发中。</p>
<p>PKCS包括算法指定（algorithm-specific）和算法独立（algorithm-independent）两种实现标准。多种算法被支持，包括RSA算法和 Diffie-Hellman 密钥交换算法，然而只有后两种才特别详尽。PKCS也为数字签名、数字信封、可扩展证书 定义了一种算法独立（algorithm-independent）的语法；这就意味着任何加密算法都可以实现这套标准的语法，并且因此获得互操作性。</p>
<h1 id="BCCSP服务"><a href="#BCCSP服务" class="headerlink" title="BCCSP服务"></a>BCCSP服务</h1><p>BCCSP，是blockchain cryptographic service provider的缩写，个人译作区域链加密服务提供者，为fabric项目提供各种加密技术，签名技术，工具的性质很强，MSP服务模块中就使用到了BCCSP。<br>BCCSP的实现有两种：pkcs11 和 SW。简单明了的解释的话（虽不太精准），就是pckcs11是硬件基础的加密服务实现，sw是软件基础的加密服务实现。<br>BCCSP 定义的接口如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> BCCSP <span class="keyword">interface</span> &#123;</div><div class="line">    <span class="comment">//根据key生成选项opts生成一个key</span></div><div class="line">    <span class="comment">//与key有关的选项opts选项要适合原始的key（与“证书是一级一级的认证”对看）</span></div><div class="line">    KeyGen(opts KeyGenOpts) (k Key, err error)</div><div class="line">    <span class="comment">//根据key获取选项opts从k中重新获取一个key</span></div><div class="line">    KeyDeriv(k Key, opts KeyDerivOpts) (dk Key, err error)</div><div class="line">    <span class="comment">//根据key导入选项opts从一个key原始的数据中导入一个key</span></div><div class="line">    KeyImport(raw <span class="keyword">interface</span>&#123;&#125;, opts KeyImportOpts) (k Key, err error)</div><div class="line">    <span class="comment">//根据SKI返回与该接口实例有联系的key</span></div><div class="line">    GetKey(ski []<span class="keyword">byte</span>) (k Key, err error)</div><div class="line">    <span class="comment">//根据哈希选项opts哈希一个消息msg，如果opts为空，则使用默认选项</span></div><div class="line">    Hash(msg []<span class="keyword">byte</span>, opts HashOpts) (hash []<span class="keyword">byte</span>, err error)</div><div class="line">    <span class="comment">//根据哈希选项opts获取hash.Hash实例，如果opts为空，则使用默认选项</span></div><div class="line">    GetHash(opts HashOpts) (h hash.Hash, err error)</div><div class="line">    <span class="comment">//根据签名者选项opts，使用k对digest进行签名，注意如果需要对一个特别大的消息的hash值</span></div><div class="line">    <span class="comment">//进行签名，调用者则负责对该特别大的消息进行hash后将其作为digest传入</span></div><div class="line">    Sign(k Key, digest []<span class="keyword">byte</span>, opts SignerOpts) (signature []<span class="keyword">byte</span>, err error)</div><div class="line">    <span class="comment">//根据鉴定者选项opts，通过对比k和digest，鉴定签名</span></div><div class="line">    Verify(k Key, signature, digest []<span class="keyword">byte</span>, opts SignerOpts) (valid <span class="keyword">bool</span>, err error)</div><div class="line">    <span class="comment">//根据加密者选项opts，使用k加密plaintext</span></div><div class="line">    Encrypt(k Key, plaintext []<span class="keyword">byte</span>, opts EncrypterOpts) (ciphertext []<span class="keyword">byte</span>, err error)</div><div class="line">    <span class="comment">//根据解密者选项opts，使用k对ciphertext进行解密</span></div><div class="line">    Decrypt(k Key, ciphertext []<span class="keyword">byte</span>, opts DecrypterOpts) (plaintext []<span class="keyword">byte</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul>
<li><p>api 目录下是各个Interface，以及这些接口函数的参数结构体，everything is in api，即这个包不会去依赖其他包<br>  -apifabclient</p>
<pre><code>- identity.go 也定义了User接口，和下面是一样的
</code></pre><ul>
<li>apifabca <ul>
<li>user.go 定义一个已经enroll的用户的User接口，实现是在pkg/fabric-client/identity/identity.go中</li>
</ul>
</li>
</ul>
</li>
<li><p>def 目录下是该sdk的所有接口</p>
<ul>
<li>fabapi 该目录下包名为fabapi，即sdk的各个api方法<ul>
<li>pkgfactory.go提供生成各个类的工厂方法</li>
</ul>
</li>
</ul>
</li>
<li>pkg 目录下才是所有类型的定义</li>
</ul>
<h1 id="fabric-client-和-sdk-client-的区别"><a href="#fabric-client-和-sdk-client-的区别" class="headerlink" title="fabric-client 和 sdk-client 的区别"></a>fabric-client 和 sdk-client 的区别</h1><p>首先pkg/fabric-client中的Client就是实现api/apifabricclient中FabricClient接口。即一样！</p>
<h1 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h1><p>Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧.</p>
<h1 id="fabric-ca-client-的-Enroll-方法，先在本地调用-GenCSR-生成私钥和CSR请求-包含公钥-，然后再用CSR请求fabric-ca-服务端。"><a href="#fabric-ca-client-的-Enroll-方法，先在本地调用-GenCSR-生成私钥和CSR请求-包含公钥-，然后再用CSR请求fabric-ca-服务端。" class="headerlink" title="fabric-ca client 的 Enroll 方法，先在本地调用 GenCSR 生成私钥和CSR请求(包含公钥)，然后再用CSR请求fabric-ca 服务端。"></a>fabric-ca client 的 Enroll 方法，先在本地调用 GenCSR 生成私钥和CSR请求(包含公钥)，然后再用CSR请求fabric-ca 服务端。</h1><h1 id="我所理解的MSP和TLS证书秘钥配置"><a href="#我所理解的MSP和TLS证书秘钥配置" class="headerlink" title="我所理解的MSP和TLS证书秘钥配置"></a>我所理解的MSP和TLS证书秘钥配置</h1><p>MSP（可以是DSA或RSA）是用来Sign的，原文和签名（利用key加密）一起发送，接受者用证书验证签名，判断身份<br>TLS是用来加密传输的（不能是DSA），接受者那边只需要配置发送者证书的根证书即可。原文加密发送。</p>
<h1 id="DSA-ECDSA-与-RSA-的区别"><a href="#DSA-ECDSA-与-RSA-的区别" class="headerlink" title="DSA/ECDSA 与 RSA 的区别"></a>DSA/ECDSA 与 RSA 的区别</h1><ol>
<li>DSA/ECDSA都只是签名算法，<strong>但不能用来加密</strong><br>DSA和ECSDA的基本架构和RSA一样，签名者持有私钥，对应公钥向全世界公开。当需要对信息签名时，签名者用私钥对信息签名，然后将<strong>签名信息</strong>和<strong>信息原文</strong>发给对方（RSA协议中，信息原文不需要发给对方，签名信息解密后就是信息原文），验证者可用签名者公开的公钥对签名信息和信息原文验证签名。由于信息长度可能比较长，在实际操作中，大家通常在信息的HASH摘要上进行签名。<br>签名的工作原理：私钥A，公钥B，原文H，签名方将用A签名H后的C和H发送给接收方。接收方用公钥B处理原文H，如果得到的值与C相同，则证明身份。<a href="http://zhiqiang.org/blog/it/das-and-ecdsa-rsa.html" target="_blank" rel="external">链接</a></li>
<li>RSA 既可以用来签名也可以用来加密传输<br>因为它不需要发送原文</li>
</ol>
<h1 id="签名和加密的区别"><a href="#签名和加密的区别" class="headerlink" title="签名和加密的区别"></a>签名和加密的区别</h1><p>签名需要传递原文，加密肯定不可以。<br>证书颁发： 原文 =&gt; hash =&gt; 私钥加密，附加在原文上<br>证书验证： 公钥解密 =&gt; hash =&gt; 证是否与原文一致。<br>签名需要保证两点：<br>（1）保证信息是由签名者自己签名发送的，签名者不能否认或难以否认；<br>（2）保证信息自签发后到收到为止未曾作过任何修改，签发的文件是真实文件。</p>
<h1 id="CredentialManager"><a href="#CredentialManager" class="headerlink" title="CredentialManager"></a>CredentialManager</h1><p>Is used for retriving user’s signing identity (ecert + private key)  </p>
<h1 id="MSP-以组织为单位"><a href="#MSP-以组织为单位" class="headerlink" title="MSP 以组织为单位"></a>MSP 以组织为单位</h1><h1 id="User-interface-的实现在-pkg-fabric-client-identity-identity-go"><a href="#User-interface-的实现在-pkg-fabric-client-identity-identity-go" class="headerlink" title="User interface 的实现在 pkg/fabric-client/identity/identity.go"></a>User interface 的实现在 pkg/fabric-client/identity/identity.go</h1><h1 id="sdk-NewPreEnrolledUser-返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert"><a href="#sdk-NewPreEnrolledUser-返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert" class="headerlink" title="sdk.NewPreEnrolledUser 返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert"></a>sdk.NewPreEnrolledUser 返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert</h1><h1 id="FabricSDK-与-FabricClient-的区别"><a href="#FabricSDK-与-FabricClient-的区别" class="headerlink" title="FabricSDK 与 FabricClient 的区别"></a>FabricSDK 与 FabricClient 的区别</h1><ol>
<li>FabricClient有一个SaveUserToStateStore方法，它首先将user对象赋给this.userContext, 然后把user持久化到stateStore中。</li>
<li>FabricSDK 提供接口操作，用于方便的生成各种Client对象，包括NewSystemClient方法用于生成FabricClient对象。并且提供<strong>NewPreEnrolledUser</strong>方法利用CredentialManager从文件系统msp目录下获得用户的私钥和证书信息，生成User对象。(这些脏活都由FabricSDK来做。)</li>
<li>FabricSDK 提供获取ChannelClient，获取Session，获取User，获取FabricClient(SystemClient)，获取Context 等方法。</li>
</ol>
<h1 id="Config-接口的-TLSCACertPool-tlscert-string-方法"><a href="#Config-接口的-TLSCACertPool-tlscert-string-方法" class="headerlink" title="Config 接口的 TLSCACertPool(tlscert string) 方法"></a>Config 接口的 TLSCACertPool(tlscert string) 方法</h1><p>如果传入tlscert路径参数，则将其存入内部的tlsCertPool(x509.CertPool)，最后返回tlsCertPool对象。这个对象里面放着所有信任的根证书。<br>peer的证书tls证书是由org的tls ca证书签发的</p>
<h1 id="MSP-和-TLS-的应用"><a href="#MSP-和-TLS-的应用" class="headerlink" title="MSP 和 TLS 的应用"></a>MSP 和 TLS 的应用</h1><p>首先MSP是签名，而TLS是加密。其次，<br>MSP的工作原理：  </p>
<pre><code>1. 把MSP证书（由组织MSP的私钥签发）发送给对方 
2. 对方验证该证书是其所属组织签发，并获得其中MSP公钥
3. 己方将信息和签名发送给对方
4. 对方用获得的公钥验证签名
User的PrivateKey指的就是MSP下的私钥
</code></pre><p>TLS的工作原理：<br>    应该很了解</p>
<h1 id="SDK-中的各种Provider-是由二次工厂产生"><a href="#SDK-中的各种Provider-是由二次工厂产生" class="headerlink" title="SDK 中的各种Provider 是由二次工厂产生"></a>SDK 中的各种Provider 是由二次工厂产生</h1><p>ConfigProvider/Cryptosuite/StateStoreProvider等是由sdk.ProviderFactory产生的，而ProviderFactory也是由工厂方法生成的。</p>
<h1 id="SDK-用到的MSP和TLS证书和私钥目录配置在config-yaml中的cryptoconfig-path下"><a href="#SDK-用到的MSP和TLS证书和私钥目录配置在config-yaml中的cryptoconfig-path下" class="headerlink" title="SDK 用到的MSP和TLS证书和私钥目录配置在config.yaml中的cryptoconfig.path下"></a>SDK 用到的MSP和TLS证书和私钥目录配置在config.yaml中的cryptoconfig.path下</h1><p>这个地址从config.CryptoConfigPath()中读出，在NewCredentialManager（凭证管理器）中被用到，用于获得Enroll用户的身份。</p>
<h1 id="SKD-提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。"><a href="#SKD-提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。" class="headerlink" title="SKD 提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。"></a>SKD 提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。</h1><p>只有管理员可以进行创建/更新channel，安装和实例化chaincode（由SDK控制权限）。 配置在config.yaml的organizations.Orgxx.adminPrivateKey和signedCert下。（生产环境中，不能配置在文件中）<br>管理员可以执行的方法被集中定义在<strong>pkg/fabric-txn/admin/transactionconfig.go</strong> ，包名admin中。该文件的作用是集中放置admin可以执行的方法。实际权限还是要手动设置（因为Fabric网络不区分admin和普通用户）</p>
<ol>
<li>SendInstallCC</li>
<li>SendInstantiateCC</li>
<li>SendUpgradeCC</li>
<li>CreateOrUpdateChannel</li>
<li>JoinChannel</li>
<li>changeGOPATHToDeploy</li>
<li>resetGOPATH<br>其实上面的操作，普通用户也可以操作。我们需要通过手动控制SDK此时FabricClient对象中的User是Admin身份，然后调用该包内的方法。其实具体调用的自方法都在FabricClient中，例如CreateChannel， SendInstantiateProposal等等。</li>
</ol>
<h1 id="Channel-pkg-fabric-client-channel"><a href="#Channel-pkg-fabric-client-channel" class="headerlink" title="Channel (pkg/fabric-client/channel)"></a>Channel (pkg/fabric-client/channel)</h1><p>这只是SDK中的一个对象，封装了channel的一些配置。该对象内部有个clientContext接口，刚好FabricClient满足该接口，因此只要传递FabricClient对象进去即可。通过工厂方法NewChannel(name string, client fab.FabricClient)创建。</p>
<h1 id="pkg-fabric-client-channel-block-go-作用"><a href="#pkg-fabric-client-channel-block-go-作用" class="headerlink" title="pkg/fabric-client/channel/block.go 作用"></a>pkg/fabric-client/channel/block.go 作用</h1><h1 id="查询一个peer加入的所有channels"><a href="#查询一个peer加入的所有channels" class="headerlink" title="查询一个peer加入的所有channels"></a>查询一个peer加入的所有channels</h1><p>FabricClient的方法QueryChannels，其实是通过运行该peer上的cscc中的GetChannels方法。FabricClient提供了一个queryBySystemChaincodeByTarget方法来调用系统合约。</p>
<h1 id="crypto-config目录结构"><a href="#crypto-config目录结构" class="headerlink" title="crypto-config目录结构"></a>crypto-config目录结构</h1><ul>
<li>peer </li>
</ul>
<h1 id="docker-compose-启动某个yaml配置文件时，可以通过读取同目录下的-env-文件来配置环境变量"><a href="#docker-compose-启动某个yaml配置文件时，可以通过读取同目录下的-env-文件来配置环境变量" class="headerlink" title="docker-compose 启动某个yaml配置文件时，可以通过读取同目录下的 .env 文件来配置环境变量"></a>docker-compose 启动某个yaml配置文件时，可以通过读取同目录下的 .env 文件来配置环境变量</h1><h1 id="ChannelClient-与-Channel-不同"><a href="#ChannelClient-与-Channel-不同" class="headerlink" title="ChannelClient 与 Channel 不同"></a>ChannelClient 与 Channel 不同</h1><ol>
<li>Channel 对象是Fabric中channel的抽象对象，里面封装了channel交互操作的一些方法。</li>
<li>而ChannelClient provides a handler to interact with peers on specified channel. 例如<br>Query()<br>QueryWithOpts()  // 这个Opt就是提供一个chan供sync或者async调用<br>ExecuteTx()<br>即ChannelClient提供了操作这个Channel对象的上层封装方法。ChannelClient内部拥有一个Channel对象的引用。</li>
</ol>
<h1 id="DiscoveryProvider"><a href="#DiscoveryProvider" class="headerlink" title="DiscoveryProvider"></a>DiscoveryProvider</h1><p>DiscoveryProvider 提供一个 NewDiscoveryService(channelID string) 获得特定链的peer发现服务。而获得的DiscoveryService对象的GetPeers()就可以拿到链上的所有peer。<br>目前SDK只提供了一个staticdiscovery的实现，其实就是解析config配置文件，找到所有peers。</p>
<h1 id="SelectionProvider"><a href="#SelectionProvider" class="headerlink" title="SelectionProvider"></a>SelectionProvider</h1><p>类似上面，默认的也是StaticSelection的简单实现。</p>
<h1 id="Session-结构"><a href="#Session-结构" class="headerlink" title="Session 结构"></a>Session 结构</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</div><div class="line">    factory context.SessionClientFactroy</div><div class="line">    user    fab.User</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h1><p>NewChannelClient</p>
<h1 id="批量删除镜像"><a href="#批量删除镜像" class="headerlink" title="批量删除镜像"></a>批量删除镜像</h1><p>docker images | grep xxx | awk ‘{print $3}’ | xargs docker rmi</p>
<h1 id="BaseSetupImpl-只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。-Initialize"><a href="#BaseSetupImpl-只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。-Initialize" class="headerlink" title="BaseSetupImpl 只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。[Initialize]"></a>BaseSetupImpl 只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。[Initialize]</h1><h1 id="UpdateCC-的原理"><a href="#UpdateCC-的原理" class="headerlink" title="UpdateCC 的原理"></a>UpdateCC 的原理</h1><ol>
<li>首先设置一个新的verison号</li>
<li>发送安装这个cc</li>
<li>发送初始化请求至这个cc</li>
</ol>
<h1 id="SDK-中发送-Query-和-Invoke-的区别"><a href="#SDK-中发送-Query-和-Invoke-的区别" class="headerlink" title="SDK 中发送 Query 和 Invoke 的区别"></a>SDK 中发送 Query 和 Invoke 的区别</h1><ol>
<li>Query： 只调用sendTransactionProposal </li>
<li>Invoke: 先调用sendTransactionProposal，然后调用sendTransaction （一气呵成，因此我们必须设置发送给背书策略中需要的peer）</li>
<li>目前，无论是Fabric还是SDK，都是进入Chaincode的Invoke方法(不能修改也无法修改！)，不会进Query方法（已经废弃，原因是query和invoke都是发送的Proposal）。之所以区分开invoke和query（SDK中是Query() / Invoke()，或者Fabric中peer chaincode invoke / peer chaincode query ，这是因为要区别是否还有第二个步骤sendTransaction）</li>
<li>ChannelClient.Query() 会发送请求到该channel上的所有peer 并返回所有请求的响应包数组，但是不用担心其中的节点挂掉造成无畏的等待。因为返回的数组里面只会包含成功返回的响应。最后Query返回数组中第一个响应作为返回值。</li>
<li>无论是Query 或者 Invoke，其第一阶段都是调用 internal.CreateAndSendTransactionProposal 来发送Proposal请求，其返回的响应数组中的每个响应结构体TransactionProposalResponse 中有一个Endorser字段表示背书签名。而Query()方法只返回了第一个响应结构体中的ProposalResponse字段作为结果</li>
</ol>
<h1 id="MSP-与-PEER-的关系"><a href="#MSP-与-PEER-的关系" class="headerlink" title="MSP 与 PEER 的关系"></a>MSP 与 PEER 的关系</h1><h1 id="cauthdsl-包"><a href="#cauthdsl-包" class="headerlink" title="cauthdsl 包"></a>cauthdsl 包</h1><p>cauthdsl 用来build产生背书策略（一种语法）</p>
<h1 id="ESCC-负责背书endorse的系统chaincode"><a href="#ESCC-负责背书endorse的系统chaincode" class="headerlink" title="ESCC 负责背书endorse的系统chaincode"></a>ESCC 负责背书endorse的系统chaincode</h1><p>peer用Member的身份还是Admin的身份才背书该Proposal，取决于它用的MSP是谁的，例如下面的docker-compose.yaml的第二条就是使用Admin的MSP。注意，不要把第三条的TLS的证书也改成Admin的，这样会导致tls验证失败。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">volumes:</div><div class="line">  - /var/run/:/host/var/run/</div><div class="line">  - ./channel/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp:/etc/hyperledger/msp/peer</div><div class="line">  - ./channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/tls/peer</div></pre></td></tr></table></figure></p>
<h1 id="VSCC-策略检查"><a href="#VSCC-策略检查" class="headerlink" title="VSCC 策略检查"></a>VSCC 策略检查</h1><p>当一个peer收到一个block数据时，开启检查该条交易的背书验证</p>
<h1 id="同一条Channel上的各个合约里面的字段是独立的还是公用的？"><a href="#同一条Channel上的各个合约里面的字段是独立的还是公用的？" class="headerlink" title="同一条Channel上的各个合约里面的字段是独立的还是公用的？"></a>同一条Channel上的各个合约里面的字段是独立的还是公用的？</h1><p>独立的，不会发生key冲突</p>
<h1 id="系统chaincode也是有源码的，在scc文件夹中"><a href="#系统chaincode也是有源码的，在scc文件夹中" class="headerlink" title="系统chaincode也是有源码的，在scc文件夹中"></a>系统chaincode也是有源码的，在scc文件夹中</h1><h1 id="configtx-yaml"><a href="#configtx-yaml" class="headerlink" title="configtx.yaml"></a>configtx.yaml</h1><ol>
<li>AdminPrincipal: Role.ADMIN / Role.MEMBER 表示那些人具有Admin的权限:<ul>
<li>create/update channel</li>
<li>install/instantiate chaincode</li>
<li>query installed/instantiated chaincode</li>
</ul>
</li>
<li>AdminPrincipal 不填表示默认为Role.Admin，即只有管理员的MSP才可以执行上述属于管理员的权限</li>
<li>这个跟Endorsing 用的权限无关</li>
</ol>
<h1 id="不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀"><a href="#不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀" class="headerlink" title="不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀"></a>不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀</h1><p>因此想要访问另一个合约中的某个值，只能通过<strong>合约调合约</strong>来实现。</p>
<h1 id="使用同一条数据库连接的时候，并发是必须加锁。"><a href="#使用同一条数据库连接的时候，并发是必须加锁。" class="headerlink" title="使用同一条数据库连接的时候，并发是必须加锁。"></a>使用同一条数据库连接的时候，并发是必须加锁。</h1><p>数据库即使有并发处理，也要求是不同的数据库连接。</p>
<h1 id="chain-与-channel-区分"><a href="#chain-与-channel-区分" class="headerlink" title="chain 与 channel 区分"></a>chain 与 channel 区分</h1><ol>
<li>chain链，即block构成的chain，也叫blockchain，其隶属于某个通道channel</li>
<li>channel通道</li>
<li>orderer上还有一个系统链systemchain，而genesis.block是其第一块block。任何组织、成员或通道的改变，都会产生新的block，连接到这个systemchain上</li>
<li>管理员创建某个channel通道以后，会得到一个channel.block，它就是这个channel中的blockchain的首块block </li>
<li>账本是隶属于某个channel的，由blockchain和world state构成</li>
</ol>
<h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p>例子：组织A和组织B现在加入同一个通道channel，现在两家的管理员分别在自家的所有peer上安装chaincode，如果两家都动了坏心思，分别安装了修改后的对自家有利的合约（而不是提前商量好的合约）。 但是毕竟是两家一起玩的事情，因此合约的背书策略肯定是设置成需要两家的签名的(因为没有两家的签名的话，拿出去怎么让其他人信服)。这样，当组织A发起Invoke时，需要也发给组织B的peer，由于两家合约不同，计算出的结果不同的话，最后进行到channel中所有peer commit 阶段时，由于结果不一致而commit失败！</p>
<h1 id="upgrade-chaincode"><a href="#upgrade-chaincode" class="headerlink" title="upgrade chaincode"></a>upgrade chaincode</h1><ol>
<li>首先install一个版本号更高的</li>
<li>然后upgrade这个新的chaincode<br>如果install一个版本号一样的chaincode，会报错提醒已经安装过了<br>如果install之后，使用initiate，会报错<br>因此只能靠upgrade来执行chaincode的init函数<br>query/invoke 某个chaincode时不能加版本号<br>升级后，之前的合约容器还在  </li>
</ol>
<h1 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h1><p>证书中带的公钥对应的私钥签名的证书，一般用做根证书。<br>因为是签名，所以有原文（二进制 .pem或者base64 .crt），因此我们可以直接拿到证书中的公钥，然后用这个公钥验证签名对不对，即自签名证书。<br>证书的签发一般需要：csr，ca.cert，ca.key</p>
<h1 id="OpenSSL、OpenSSH、SSH、SSL-区别"><a href="#OpenSSL、OpenSSH、SSH、SSL-区别" class="headerlink" title="OpenSSL、OpenSSH、SSH、SSL 区别"></a>OpenSSL、OpenSSH、SSH、SSL 区别</h1><p>SSL：Secure Sockets Layer 安全套接层，一种安全协议，现在以及过时，其继任者传输层安全（Transport Layer Security，TLS）。<br>SSH：Secure SHell协议，SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。<br>OpenSSH：SSH协议族的开源实现，内部用到了OpenSSL。<br>OpenSSL：sslv2、sslv3、TLS以及DTLS（Datagram TLS，基于UDP的TLS实现）的开源实现。OpenSSL还提供了其它的一些辅助功能，如从口令生成密钥的API，证书签发和管理中的配置文件机制等等。OpenSSL一共实现了4种非对称加密算法，包括DH算法、RSA算法、DSA算法和椭圆曲线算法（EC）。DH算法一般用于密钥交换。RSA算法既可以用于密钥交换，也可以用于数字签名，当然，如果你能够忍受其缓慢的速度，那么也可以用于数据加密。DSA算法则一般只用于数字签名。OpenSSL实现了5种信息摘要算法，分别是MD2、MD5、MDC2、SHA（SHA1）和RIPEMD。SHA算法事实上包括了SHA和SHA1两种信息摘要算法。此外，OpenSSL还实现了DSS标准中规定的两种信息摘要算法DSS和DSS1。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa -out rsa_private_key.pem 1024 <span class="comment"># 生成私钥</span></div><div class="line">$ openssl rsa -<span class="keyword">in</span> rsa_private_key.pem -pubout -out rsa_public_key.pem <span class="comment"># 生成公钥</span></div><div class="line"><span class="comment"># 只能根据私钥生成公钥，不能根据公钥生成私钥</span></div></pre></td></tr></table></figure></p>
<p><a href="http://www.fzb.me/2015-1-15-openssl-rsa.html" target="_blank" rel="external">链接</a><br><a href="http://www.cnblogs.com/freeman-rain/archive/2012/05/07/2486781.html" target="_blank" rel="external">生成自签名证书的方法</a></p>
<h1 id="ssh-keygen-和-openssl-genrsa-rsa-区别"><a href="#ssh-keygen-和-openssl-genrsa-rsa-区别" class="headerlink" title="ssh-keygen 和 openssl genrsa/rsa 区别"></a>ssh-keygen 和 openssl genrsa/rsa 区别</h1><ol>
<li>ssh-keygen 和 openssl 产生的公钥的格式不同，一个是.pub，一个是.pem(二进制)</li>
<li>ssh-keygen 也可以根据私钥产生对应的公钥<br>The file format is different but they both encode the same kind of keys. Moreover, they are both generated with the same code: openssl (the command-line tool) is a wrapper around OpenSSL (the library), and OpenSSH actually uses OpenSSL (the library) for its cryptographic operations, including key pair generation. So there is no direct security difference.</li>
</ol>
<h1 id="当证书用于TLS时，CN必须设置成域名。而当其用作MSP或者其他用途时，可以设置成其他的值。"><a href="#当证书用于TLS时，CN必须设置成域名。而当其用作MSP或者其他用途时，可以设置成其他的值。" class="headerlink" title="当证书用于TLS时，CN必须设置成域名。而当其用作MSP或者其他用途时，可以设置成其他的值。"></a>当证书用于TLS时，CN必须设置成域名。而当其用作MSP或者其他用途时，可以设置成其他的值。</h1><h1 id="如果一些服务端不但启动了TSL，还开启了SSL客户端认证，那么客户端还需要配置自己的证书和密钥文件。（即双向TLS）"><a href="#如果一些服务端不但启动了TSL，还开启了SSL客户端认证，那么客户端还需要配置自己的证书和密钥文件。（即双向TLS）" class="headerlink" title="如果一些服务端不但启动了TSL，还开启了SSL客户端认证，那么客户端还需要配置自己的证书和密钥文件。（即双向TLS）"></a>如果一些服务端不但启动了TSL，还开启了<em>SSL客户端认证</em>，那么客户端还需要配置自己的证书和密钥文件。（即双向TLS）</h1><h1 id="fabric-ca"><a href="#fabric-ca" class="headerlink" title="fabric-ca"></a>fabric-ca</h1><ol>
<li>所有的用户都必须Enroll后才能拥有证书，即获得MSP内容</li>
<li><p>区别是，对于配置在ca服务器上的初始用户（一般是管理员），可以直接调用Enroll命令。如下，其中admin和adminpw是配置在服务器初始化文件中的用户名和密码</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin <span class="comment"># 配置MSP目录</span></div><div class="line">$ fabric-ca-client enroll -u http://admin:adminpw@localhost:7054</div></pre></td></tr></table></figure>
</li>
<li><p>接上面，对于非初始用户，需要借助<strong>有权限</strong>且<strong>已经Enroll</strong>的用户来注册一个身份，以及获得对应的密码，如下</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin</div><div class="line">$ fabric-ca-client register --id.name admin2 --id.type user --id.affiliation org1.department1 --id.attr hf.Revoker=<span class="literal">true</span>  <span class="comment"># 会返回一个密码</span></div></pre></td></tr></table></figure>
<p> 然后再调用</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/peer1</div><div class="line">$ fabric-ca-client enroll -u http://peer1:peer1pw@localhost:7054 -M <span class="variable">$FABRIC_CA_CLIENT_HOME</span>/msp <span class="comment"># 其中peer1是之前注册的身份，peer1pw是注册返回的密码</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="世界状态的键被表示成两个组件-chaincodeID-and-ckey-的通过nil字节的级联，如：key-chaincodeID-nil-cKey。"><a href="#世界状态的键被表示成两个组件-chaincodeID-and-ckey-的通过nil字节的级联，如：key-chaincodeID-nil-cKey。" class="headerlink" title="世界状态的键被表示成两个组件(chaincodeID and ckey) 的通过nil字节的级联，如：key = chaincodeID+nil+cKey。"></a>世界状态的键被表示成两个组件(chaincodeID and ckey) 的通过nil字节的级联，如：key = chaincodeID+nil+cKey。</h1><h1 id="7051-7052-7053"><a href="#7051-7052-7053" class="headerlink" title="7051, 7052, 7053"></a>7051, 7052, 7053</h1><ol>
<li>7051 用于peer监听其他的请求，Proposal，gossip等</li>
<li>7052 用于peer监听cli的请求，或者如果在core.yaml配置了chaincodeListenAddress: 127.0.0.1:7052，则用于监听本地chaincode容器对peer的请求（如果没有配置该项，则还是使用listenAddress，则为7051端口）</li>
<li>7053 用于peer监听事件的请求</li>
</ol>
<h1 id="ChaincodeSupport"><a href="#ChaincodeSupport" class="headerlink" title="ChaincodeSupport"></a>ChaincodeSupport</h1><p>单例<br>Responsible for providing interfacing with chaincodes from the Peer.<br>方法：</p>
<pre><code>1. Launch: will launch the chaincode if not running (if running return nil) and will wait for handler of the chaincode to get into FSM ready state. 
2. Execute: executes a transaction and waits for it to complete until a timeout value. 
3. Register: (该方法是grpc service 中定义的) 被chaincode调用，该方法中创建handler，因为这里可以拿到grpc的Stream对象。 
4. Stop: 
5. launchAndWaitForRegister: 创建chaincode的虚拟机（容器 or else），
6. 
</code></pre><p>内部有个runningChaincodes的对象，该对象内部有一个map[string]*chaincodeRTEnv，存放各个chaincode对应的chaincodeRTEnv对象。<br>peer/node/start.go 中 registerChaincodeSupport，该方法被serve方法调用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// userRunsCC 即 dev-mode1</span></div><div class="line">ccSrv := chaincode.NewChaincodeSupport(ccEpFunc, userRunsCC, ccStartupTimeout) </div><div class="line"><span class="comment">// 注册进 rpc server</span></div><div class="line">pb.RegisterChaincodeSupportServer(grpcServer, ccSrv)</div></pre></td></tr></table></figure></p>
<h1 id="chaincodeRTEnv"><a href="#chaincodeRTEnv" class="headerlink" title="chaincodeRTEnv"></a>chaincodeRTEnv</h1><p>chaincode runtime environment encapsulates handler and container environment<br>This is where the VM that’s running the chaincode would hook in<br>内部有一个core/chaincode/handler.go 中的Handler对象（注意：不是shim中的handler，但基本一样），Handler responsible for management of Peer’s side of chaincode stream</p>
<h1 id="ccprovider-CCContext"><a href="#ccprovider-CCContext" class="headerlink" title="ccprovider.CCContext"></a>ccprovider.CCContext</h1><p>chaincode调用信息的封装：ChainID, Name, Version, TxID, Syscc, SignedProposal, Proposal, canonicalName …<br>ccprovider.go 里放置了一些chaincode相关的util函数和结构体。</p>
<h1 id="SignedProposal-和-Proposal-区别"><a href="#SignedProposal-和-Proposal-区别" class="headerlink" title="SignedProposal 和 Proposal 区别"></a>SignedProposal 和 Proposal 区别</h1><h1 id="core-chaincode-exectransaction-go"><a href="#core-chaincode-exectransaction-go" class="headerlink" title="core/chaincode/exectransaction.go"></a>core/chaincode/exectransaction.go</h1><p>其中 Execute方法，执行proposal，返回chaincode原始的返回。其中proposal包括: 1. ChaincodeDeployment (初始化chaincode) 2. ChaincodeInvocation。<br>该方法首先调用ChaincodeSupport.Launch方法，确保chaincode已经Lauch并处于ready状态。然后调用ChaincodeSupport.Execute方法执行proposal。</p>
<h1 id="LSCC"><a href="#LSCC" class="headerlink" title="LSCC"></a>LSCC</h1><h1 id="TxSimulator"><a href="#TxSimulator" class="headerlink" title="TxSimulator"></a>TxSimulator</h1><h1 id="testchainid"><a href="#testchainid" class="headerlink" title="testchainid"></a>testchainid</h1><p>This genesis block is used to bootstrap the ordering system channel, which the orderers use to authorize and orchestrate creation of other channels. By default, the channel ID encoded into the genesis block by configtxgen will be testchainid. It is recommended that you modify this identifier to something which will be globally unique.<br>简而言之：orderer上的系统通道的ChannelID为testchainid</p>
<h1 id="多个orderer的作用"><a href="#多个orderer的作用" class="headerlink" title="多个orderer的作用"></a>多个orderer的作用</h1><p>在config.yaml中，有如下配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Orderer:</span> <span class="meta">&amp;OrdererDefaults</span></div><div class="line"><span class="attr">    OrdererType:</span> <span class="string">solo</span></div><div class="line"><span class="attr">    Addresses:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">orderer0.example.com:7050</span></div></pre></td></tr></table></figure></p>
<p>Addresses字段可以填写多个，但是这些orderer的配置文件，即创世块必须是一致的。其实kafka模式下，各个orderer的创世块也是一致的。<br>多个orderer的作用：<br>client向某个peer发送模拟执行请求后，将得到的响应发送给指定的一个orderer，然后各个commit节点根据自己所加入的channel，例如目前加入channel1通道，即commit节点拿到channel1的配置块，从中拿到上面配置的各个orderer地址，选一个可以连接的orderer去连接，调用Deliver接口获得block。  </p>
<p>虽然orderer地址是配置在configtx.yaml中genesis.block的配置中，但是一旦orderer启动后。往该orderer上create channel 之后拿到的 channel.block（注意：不是生成的channel.tx，而是用它创建channel后得到的block，用于join channel） 中就可以拿到orderer中的一些配置信息。</p>
<h1 id="solo模式下只有一个orderer"><a href="#solo模式下只有一个orderer" class="headerlink" title="solo模式下只有一个orderer"></a>solo模式下只有一个orderer</h1><h1 id="fabric里面好玩的地方，逻辑的复用"><a href="#fabric里面好玩的地方，逻辑的复用" class="headerlink" title="fabric里面好玩的地方，逻辑的复用"></a>fabric里面好玩的地方，逻辑的复用</h1><p>其实配置orderer，无非就是配置orderer中系统链testchainid（默认名，也可以改，该链只存在于orderer中）。因为genesis.block也就可以理解为该channel中的第一个区块，它和一般交易块的区别是：它里面放的都是配置信息。因此，在orderer上创建其他的channel，我们传入的都是channelxx.tx（就是个交易），orderer执行后，commit到testchainid这条链的账本中。如果遇到是配置信息的交易（例如，升级anchor的anchor1.tx），commit时会自动把这种配置的交易单独放到一个区块中，而且该区块中会有修改配置后的完整信息。<br>对应于我们自己创建的channel，用create后拿到channel初始块，加入网络后，该块就是该channel的初始块，里面就是配置信息。之后接受到其他的交易时，如果是配置信息的交易，则也会单独将它切成一块，里面写入更新配置之后的信息（也就是交易信息和配置信息不会混在一个块中）。（这样做是因为方便client去获取某个版本的配置信息）。  </p>
<h1 id="可以看看fabric下sampleconfig中的文件，其中configtx-yaml-core-yaml-orderer-yaml"><a href="#可以看看fabric下sampleconfig中的文件，其中configtx-yaml-core-yaml-orderer-yaml" class="headerlink" title="可以看看fabric下sampleconfig中的文件，其中configtx.yaml, core.yaml, orderer.yaml"></a>可以看看fabric下sampleconfig中的文件，其中configtx.yaml, core.yaml, orderer.yaml</h1><h1 id="Reconfiguring-with-configtxlator"><a href="#Reconfiguring-with-configtxlator" class="headerlink" title="Reconfiguring with configtxlator"></a>Reconfiguring with configtxlator</h1><p>Channel configuration is stored as a transaction in configuration blocks of a channel and may be manipulated directly. However, at the time of this writing, no SDK natively supports manipulating the configuration directly, so the configtxlator tool is designed to provide an API which consumers of any SDK may interact with to assist with configuration updates.<br>用法：</p>
<ol>
<li>SDK retrieves latest config</li>
<li>configtxlator produces human readable version of config</li>
<li>User or application edits the config</li>
<li>configtxlator is used to compute config update representation of changes to the config</li>
<li>SDK submits signs and submits config</li>
</ol>
<p>$ peer channel fetch config config_block.pb -o 127.0.0.1:7050 -c testchainid</p>
<h1 id="x509-证书-CN-SAN-详解（已验证）"><a href="#x509-证书-CN-SAN-详解（已验证）" class="headerlink" title="x509 证书 CN/SAN 详解（已验证）"></a>x509 证书 CN/SAN 详解（已验证）</h1><p>什么是SAN. SAN(Subject Alternative Name) 是SSL 标准x509 中定义的一个扩展。使用了SAN 字段的SSL 证书，可以扩展此证书支持的域名，使得一个证书可以支持多个不同域名的解析。<br>证书的验证过程：   </p>
<ol>
<li>判断 CN 是否与访问的地址一致 （CN 将来会被废弃使用）</li>
<li>不一致的话，再判断 SAN 域与访问的地址是否一致 （目前标准建议多使用SAN域）</li>
<li>非常重要，如果你签发IP证书，则 CN 可以随便写，但是 SAN 里面必须加上该 IP ！！！（因为 CN 只支持域名匹配，如果浏览器访问的是IP，则会去证书的SAN域匹配，<code>因此IP证书的CN可以随便填，反正会跳过CN匹配去查SAN</code>）</li>
</ol>
<p>SAN 支持三种格式：域名、邮箱、IP   </p>
<p> Matching is performed using the matching rules specified by<br>   [PKIX-OLD].  If more than one identity of a given type is present in<br>   the certificate (e.g., more than one dNSName name, a match in any one<br>   of the set is considered acceptable.)  Names may contain the wildcard<br>   character <em> which is considered to match any single domain name<br>   component or component fragment.  E.g., </em>.a.com matches foo.a.com but<br>   not bar.foo.a.com. f*.com matches foo.com but not bar.com.</p>
<p>   In some cases, the URI is specified as an IP address rather than a<br>   hostname.  In this case, the iPAddress subjectAltName must be present<br>   in the certificate and must exactly match the IP in the URI.    </p>
<blockquote>
<p>URI被指定为IP地址而不是主机名。 在这种情况下，CN可以随便设置，iPAddress subjectAltName必须存在于证书中，并且必须与URI中的IP完全匹配。</p>
</blockquote>
<h1 id="pem-与-der"><a href="#pem-与-der" class="headerlink" title=".pem 与 .der"></a>.pem 与 .der</h1><p><a href="http://blog.csdn.net/anxuegang/article/details/6157927" target="_blank" rel="external">链接</a></p>
<h1 id="Proposal-里面有个-signatureheader，里面有-signer-的-identity-的-bytes-信息。而-signed-Proposal-就是再用这个-singer-对-Proposal-进行-sign"><a href="#Proposal-里面有个-signatureheader，里面有-signer-的-identity-的-bytes-信息。而-signed-Proposal-就是再用这个-singer-对-Proposal-进行-sign" class="headerlink" title="Proposal 里面有个 signatureheader，里面有 signer 的 identity 的 bytes 信息。而 signed Proposal 就是再用这个 singer 对 Proposal 进行 sign"></a>Proposal 里面有个 signatureheader，里面有 signer 的 identity 的 bytes 信息。而 signed Proposal 就是再用这个 singer 对 Proposal 进行 sign</h1>
  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-包管理器，基本是基于vendor目录"><span class="toc-number">1.</span> <span class="toc-text">go 包管理器，基本是基于vendor目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lock-json-和-package-json"><span class="toc-number">2.</span> <span class="toc-text">lock.json 和 package.json</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bccsp"><span class="toc-number">3.</span> <span class="toc-text">bccsp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fixture"><span class="toc-number">4.</span> <span class="toc-text">fixture</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkcs11"><span class="toc-number">5.</span> <span class="toc-text">pkcs11</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BCCSP服务"><span class="toc-number">6.</span> <span class="toc-text">BCCSP服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目录结构"><span class="toc-number">7.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-client-和-sdk-client-的区别"><span class="toc-number">8.</span> <span class="toc-text">fabric-client 和 sdk-client 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSR"><span class="toc-number">9.</span> <span class="toc-text">CSR</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-ca-client-的-Enroll-方法，先在本地调用-GenCSR-生成私钥和CSR请求-包含公钥-，然后再用CSR请求fabric-ca-服务端。"><span class="toc-number">10.</span> <span class="toc-text">fabric-ca client 的 Enroll 方法，先在本地调用 GenCSR 生成私钥和CSR请求(包含公钥)，然后再用CSR请求fabric-ca 服务端。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#我所理解的MSP和TLS证书秘钥配置"><span class="toc-number">11.</span> <span class="toc-text">我所理解的MSP和TLS证书秘钥配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DSA-ECDSA-与-RSA-的区别"><span class="toc-number">12.</span> <span class="toc-text">DSA/ECDSA 与 RSA 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#签名和加密的区别"><span class="toc-number">13.</span> <span class="toc-text">签名和加密的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CredentialManager"><span class="toc-number">14.</span> <span class="toc-text">CredentialManager</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-以组织为单位"><span class="toc-number">15.</span> <span class="toc-text">MSP 以组织为单位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#User-interface-的实现在-pkg-fabric-client-identity-identity-go"><span class="toc-number">16.</span> <span class="toc-text">User interface 的实现在 pkg/fabric-client/identity/identity.go</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sdk-NewPreEnrolledUser-返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert"><span class="toc-number">17.</span> <span class="toc-text">sdk.NewPreEnrolledUser 返回先前enrolled的用户，是从文件系统中的msp文件夹下获取key和signingcert</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FabricSDK-与-FabricClient-的区别"><span class="toc-number">18.</span> <span class="toc-text">FabricSDK 与 FabricClient 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Config-接口的-TLSCACertPool-tlscert-string-方法"><span class="toc-number">19.</span> <span class="toc-text">Config 接口的 TLSCACertPool(tlscert string) 方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-和-TLS-的应用"><span class="toc-number">20.</span> <span class="toc-text">MSP 和 TLS 的应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-中的各种Provider-是由二次工厂产生"><span class="toc-number">21.</span> <span class="toc-text">SDK 中的各种Provider 是由二次工厂产生</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-用到的MSP和TLS证书和私钥目录配置在config-yaml中的cryptoconfig-path下"><span class="toc-number">22.</span> <span class="toc-text">SDK 用到的MSP和TLS证书和私钥目录配置在config.yaml中的cryptoconfig.path下</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SKD-提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。"><span class="toc-number">23.</span> <span class="toc-text">SKD 提供一个管理员身份，属于组织ORg。每个Org都可以有一个管理员。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Channel-pkg-fabric-client-channel"><span class="toc-number">24.</span> <span class="toc-text">Channel (pkg/fabric-client/channel)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pkg-fabric-client-channel-block-go-作用"><span class="toc-number">25.</span> <span class="toc-text">pkg/fabric-client/channel/block.go 作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#查询一个peer加入的所有channels"><span class="toc-number">26.</span> <span class="toc-text">查询一个peer加入的所有channels</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#crypto-config目录结构"><span class="toc-number">27.</span> <span class="toc-text">crypto-config目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-compose-启动某个yaml配置文件时，可以通过读取同目录下的-env-文件来配置环境变量"><span class="toc-number">28.</span> <span class="toc-text">docker-compose 启动某个yaml配置文件时，可以通过读取同目录下的 .env 文件来配置环境变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChannelClient-与-Channel-不同"><span class="toc-number">29.</span> <span class="toc-text">ChannelClient 与 Channel 不同</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DiscoveryProvider"><span class="toc-number">30.</span> <span class="toc-text">DiscoveryProvider</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SelectionProvider"><span class="toc-number">31.</span> <span class="toc-text">SelectionProvider</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Session-结构"><span class="toc-number">32.</span> <span class="toc-text">Session 结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SessionFactory"><span class="toc-number">33.</span> <span class="toc-text">SessionFactory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#批量删除镜像"><span class="toc-number">34.</span> <span class="toc-text">批量删除镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BaseSetupImpl-只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。-Initialize"><span class="toc-number">35.</span> <span class="toc-text">BaseSetupImpl 只是用于快速的设置FabricSDK当前的User，Channel，Org这些信息，并根据配置文件创建channel。[Initialize]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UpdateCC-的原理"><span class="toc-number">36.</span> <span class="toc-text">UpdateCC 的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SDK-中发送-Query-和-Invoke-的区别"><span class="toc-number">37.</span> <span class="toc-text">SDK 中发送 Query 和 Invoke 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MSP-与-PEER-的关系"><span class="toc-number">38.</span> <span class="toc-text">MSP 与 PEER 的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cauthdsl-包"><span class="toc-number">39.</span> <span class="toc-text">cauthdsl 包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ESCC-负责背书endorse的系统chaincode"><span class="toc-number">40.</span> <span class="toc-text">ESCC 负责背书endorse的系统chaincode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VSCC-策略检查"><span class="toc-number">41.</span> <span class="toc-text">VSCC 策略检查</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同一条Channel上的各个合约里面的字段是独立的还是公用的？"><span class="toc-number">42.</span> <span class="toc-text">同一条Channel上的各个合约里面的字段是独立的还是公用的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统chaincode也是有源码的，在scc文件夹中"><span class="toc-number">43.</span> <span class="toc-text">系统chaincode也是有源码的，在scc文件夹中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#configtx-yaml"><span class="toc-number">44.</span> <span class="toc-text">configtx.yaml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀"><span class="toc-number">45.</span> <span class="toc-text">不同合约里面的Key不会冲突，因为在数据库里面会加上合约的前缀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用同一条数据库连接的时候，并发是必须加锁。"><span class="toc-number">46.</span> <span class="toc-text">使用同一条数据库连接的时候，并发是必须加锁。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chain-与-channel-区分"><span class="toc-number">47.</span> <span class="toc-text">chain 与 channel 区分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一致性"><span class="toc-number">48.</span> <span class="toc-text">一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#upgrade-chaincode"><span class="toc-number">49.</span> <span class="toc-text">upgrade chaincode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自签名证书"><span class="toc-number">50.</span> <span class="toc-text">自签名证书</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenSSL、OpenSSH、SSH、SSL-区别"><span class="toc-number">51.</span> <span class="toc-text">OpenSSL、OpenSSH、SSH、SSL 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ssh-keygen-和-openssl-genrsa-rsa-区别"><span class="toc-number">52.</span> <span class="toc-text">ssh-keygen 和 openssl genrsa/rsa 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#当证书用于TLS时，CN必须设置成域名。而当其用作MSP或者其他用途时，可以设置成其他的值。"><span class="toc-number">53.</span> <span class="toc-text">当证书用于TLS时，CN必须设置成域名。而当其用作MSP或者其他用途时，可以设置成其他的值。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如果一些服务端不但启动了TSL，还开启了SSL客户端认证，那么客户端还需要配置自己的证书和密钥文件。（即双向TLS）"><span class="toc-number">54.</span> <span class="toc-text">如果一些服务端不但启动了TSL，还开启了SSL客户端认证，那么客户端还需要配置自己的证书和密钥文件。（即双向TLS）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric-ca"><span class="toc-number">55.</span> <span class="toc-text">fabric-ca</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#世界状态的键被表示成两个组件-chaincodeID-and-ckey-的通过nil字节的级联，如：key-chaincodeID-nil-cKey。"><span class="toc-number">56.</span> <span class="toc-text">世界状态的键被表示成两个组件(chaincodeID and ckey) 的通过nil字节的级联，如：key = chaincodeID+nil+cKey。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7051-7052-7053"><span class="toc-number">57.</span> <span class="toc-text">7051, 7052, 7053</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ChaincodeSupport"><span class="toc-number">58.</span> <span class="toc-text">ChaincodeSupport</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chaincodeRTEnv"><span class="toc-number">59.</span> <span class="toc-text">chaincodeRTEnv</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ccprovider-CCContext"><span class="toc-number">60.</span> <span class="toc-text">ccprovider.CCContext</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SignedProposal-和-Proposal-区别"><span class="toc-number">61.</span> <span class="toc-text">SignedProposal 和 Proposal 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#core-chaincode-exectransaction-go"><span class="toc-number">62.</span> <span class="toc-text">core/chaincode/exectransaction.go</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LSCC"><span class="toc-number">63.</span> <span class="toc-text">LSCC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TxSimulator"><span class="toc-number">64.</span> <span class="toc-text">TxSimulator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#testchainid"><span class="toc-number">65.</span> <span class="toc-text">testchainid</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多个orderer的作用"><span class="toc-number">66.</span> <span class="toc-text">多个orderer的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#solo模式下只有一个orderer"><span class="toc-number">67.</span> <span class="toc-text">solo模式下只有一个orderer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fabric里面好玩的地方，逻辑的复用"><span class="toc-number">68.</span> <span class="toc-text">fabric里面好玩的地方，逻辑的复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可以看看fabric下sampleconfig中的文件，其中configtx-yaml-core-yaml-orderer-yaml"><span class="toc-number">69.</span> <span class="toc-text">可以看看fabric下sampleconfig中的文件，其中configtx.yaml, core.yaml, orderer.yaml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reconfiguring-with-configtxlator"><span class="toc-number">70.</span> <span class="toc-text">Reconfiguring with configtxlator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#x509-证书-CN-SAN-详解（已验证）"><span class="toc-number">71.</span> <span class="toc-text">x509 证书 CN/SAN 详解（已验证）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pem-与-der"><span class="toc-number">72.</span> <span class="toc-text">.pem 与 .der</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Proposal-里面有个-signatureheader，里面有-signer-的-identity-的-bytes-信息。而-signed-Proposal-就是再用这个-singer-对-Proposal-进行-sign"><span class="toc-number">73.</span> <span class="toc-text">Proposal 里面有个 signatureheader，里面有 signer 的 identity 的 bytes 信息。而 signed Proposal 就是再用这个 singer 对 Proposal 进行 sign</span></a></li></ol>
    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 Landleany
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


