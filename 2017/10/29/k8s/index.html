<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="kubernetes教程kubernetes教程 rancher 通过可视化界面部署 HA k8s集群Minikube可以很方便的在本地快速部署一个单节点的k8s集群 zookeeper 扩容链接依次重启即可，网络可以不间断地提供服务。 重启docker服务12$ systemctl restart docker.service$ service docker restart docker 中央仓">
<meta property="og:type" content="article">
<meta property="og:title" content="k8s&#x2F;rancher笔记">
<meta property="og:url" content="http://yoursite.com/2017/10/29/k8s/index.html">
<meta property="og:site_name" content="Drip">
<meta property="og:description" content="kubernetes教程kubernetes教程 rancher 通过可视化界面部署 HA k8s集群Minikube可以很方便的在本地快速部署一个单节点的k8s集群 zookeeper 扩容链接依次重启即可，网络可以不间断地提供服务。 重启docker服务12$ systemctl restart docker.service$ service docker restart docker 中央仓">
<meta property="og:updated_time" content="2018-01-13T11:36:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="k8s&#x2F;rancher笔记">
<meta name="twitter:description" content="kubernetes教程kubernetes教程 rancher 通过可视化界面部署 HA k8s集群Minikube可以很方便的在本地快速部署一个单节点的k8s集群 zookeeper 扩容链接依次重启即可，网络可以不间断地提供服务。 重启docker服务12$ systemctl restart docker.service$ service docker restart docker 中央仓">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>k8s/rancher笔记</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2017/11/01/fabric-go-sdk/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2017/10/22/golang/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2017/10/29/k8s/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2017/10/29/k8s/&text=k8s/rancher笔记"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2017/10/29/k8s/&title=k8s/rancher笔记"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2017/10/29/k8s/&is_video=false&description=k8s/rancher笔记"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=k8s/rancher笔记&body=Check out this article: http://yoursite.com/2017/10/29/k8s/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2017/10/29/k8s/&title=k8s/rancher笔记"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2017/10/29/k8s/&title=k8s/rancher笔记"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2017/10/29/k8s/&title=k8s/rancher笔记"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2017/10/29/k8s/&title=k8s/rancher笔记"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2017/10/29/k8s/&name=k8s/rancher笔记&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rancher-通过可视化界面部署-HA-k8s集群"><span class="toc-number">1.</span> <span class="toc-text">rancher 通过可视化界面部署 HA k8s集群</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Minikube"><span class="toc-number">2.</span> <span class="toc-text">Minikube</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zookeeper-扩容"><span class="toc-number">3.</span> <span class="toc-text">zookeeper 扩容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重启docker服务"><span class="toc-number">4.</span> <span class="toc-text">重启docker服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-中央仓库-和-私有仓库"><span class="toc-number">5.</span> <span class="toc-text">docker 中央仓库 和 私有仓库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#minikube-中用到的一些命令"><span class="toc-number">6.</span> <span class="toc-text">minikube 中用到的一些命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-command-TYPE-NAME-flags"><span class="toc-number">7.</span> <span class="toc-text">kubectl [command] [TYPE] [NAME] [flags]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rollout-上线-运行-的意思"><span class="toc-number">8.</span> <span class="toc-text">rollout 上线/运行 的意思</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Deployment-介绍（k8s新功能）"><span class="toc-number">9.</span> <span class="toc-text">Deployment 介绍（k8s新功能）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#何时使用ReplicaSet-（不要直接使用，而使用Deployment自动管理ReplicaSet）"><span class="toc-number">10.</span> <span class="toc-text">何时使用ReplicaSet （不要直接使用，而使用Deployment自动管理ReplicaSet）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReplicaController"><span class="toc-number">11.</span> <span class="toc-text">ReplicaController</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-edit-deployment-nginx-deployment-会打开vi，修改保存后会自动触发相关工作"><span class="toc-number">12.</span> <span class="toc-text">kubectl edit deployment/nginx-deployment 会打开vi，修改保存后会自动触发相关工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StatefulSets"><span class="toc-number">13.</span> <span class="toc-text">StatefulSets</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Namespace"><span class="toc-number">14.</span> <span class="toc-text">Namespace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pod"><span class="toc-number">15.</span> <span class="toc-text">Pod</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pod-的原理"><span class="toc-number">16.</span> <span class="toc-text">Pod 的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ftok"><span class="toc-number">17.</span> <span class="toc-text">ftok</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dev-shim"><span class="toc-number">18.</span> <span class="toc-text">/dev/shim</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-mount-的文件的inode是不会变的，因此可以使用ftok"><span class="toc-number">19.</span> <span class="toc-text">docker mount 的文件的inode是不会变的，因此可以使用ftok</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Volume"><span class="toc-number">20.</span> <span class="toc-text">Volume</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Persistent-Volume"><span class="toc-number">21.</span> <span class="toc-text">Persistent Volume</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Service"><span class="toc-number">22.</span> <span class="toc-text">Service</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Headless-Service"><span class="toc-number">23.</span> <span class="toc-text">Headless Service</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不使用label-selector-的-Service"><span class="toc-number">24.</span> <span class="toc-text">不使用label selector 的 Service</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nginx"><span class="toc-number">25.</span> <span class="toc-text">nginx</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Secret"><span class="toc-number">26.</span> <span class="toc-text">Secret</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#echo-“xxxxx”-和-echo-n-“xxxxx”-的区别"><span class="toc-number">27.</span> <span class="toc-text">echo “xxxxx” 和 echo -n “xxxxx” 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-apply-和-kubectl-create-区别"><span class="toc-number">28.</span> <span class="toc-text">kubectl apply 和 kubectl create 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在一个Pod中的多个容器，用localhost就可以通信"><span class="toc-number">29.</span> <span class="toc-text">在一个Pod中的多个容器，用localhost就可以通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConfigMap"><span class="toc-number">30.</span> <span class="toc-text">ConfigMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-rolling-update-type-name-f-xxx-yaml"><span class="toc-number">31.</span> <span class="toc-text">kubectl rolling-update type name -f xxx.yaml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-rollout-type-name-可以管理资源的rollout状态"><span class="toc-number">32.</span> <span class="toc-text">kubectl rollout type name 可以管理资源的rollout状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-命令整理"><span class="toc-number">33.</span> <span class="toc-text">kubectl 命令整理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#port-nodePort-targetPort"><span class="toc-number">34.</span> <span class="toc-text">port, nodePort, targetPort</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-Compose-Kompose"><span class="toc-number">35.</span> <span class="toc-text">Kubernetes + Compose = Kompose</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Metrics-API-度量"><span class="toc-number">36.</span> <span class="toc-text">Metrics API (度量)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount：前面挂载到后面"><span class="toc-number">37.</span> <span class="toc-text">mount：前面挂载到后面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-里面前面是主机，后面是容器"><span class="toc-number">38.</span> <span class="toc-text">docker 里面前面是主机，后面是容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#探针"><span class="toc-number">39.</span> <span class="toc-text">探针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go-client-库其实也是使用的k8s的-restful-接口"><span class="toc-number">40.</span> <span class="toc-text">go-client 库其实也是使用的k8s的 restful 接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-ps-a-awk-‘-Exited-print-1-’-xargs-docker-rm-f’"><span class="toc-number">41.</span> <span class="toc-text">docker ps -a | awk ‘/Exited/ {print $1}’ | xargs docker rm -f’</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#配置-kubectl-垃圾回收策略"><span class="toc-number">42.</span> <span class="toc-text">配置 kubectl 垃圾回收策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dealing-with-Disruptions"><span class="toc-number">43.</span> <span class="toc-text">Dealing with Disruptions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-中的port、nodePort、targetPort"><span class="toc-number">44.</span> <span class="toc-text">Kubernetes 中的port、nodePort、targetPort</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-基础知识"><span class="toc-number">45.</span> <span class="toc-text">Docker 基础知识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#–privilege-参数不能让-Docker-容器内的-root-用户修改宿主机普通用户无法修改的文件，防止越权"><span class="toc-number">46.</span> <span class="toc-text">–privilege 参数不能让 Docker 容器内的 root 用户修改宿主机普通用户无法修改的文件，防止越权</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-是否支持-Linux-User-Namespace"><span class="toc-number">47.</span> <span class="toc-text">Docker 是否支持 Linux User Namespace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-Capabilities-机制"><span class="toc-number">48.</span> <span class="toc-text">Linux Capabilities 机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#userns-remap"><span class="toc-number">49.</span> <span class="toc-text">userns-remap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pod-中的-label-至少被-Service-和-Deployment-中的-Selector-用到了"><span class="toc-number">50.</span> <span class="toc-text">Pod 中的 label 至少被 Service 和 Deployment 中的 Selector 用到了</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StatefulSet-中-spec-serviceName-很重要，这个参数在-Deployment-中都没有"><span class="toc-number">51.</span> <span class="toc-text">StatefulSet 中 .spec.serviceName 很重要，这个参数在 Deployment 中都没有</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#删除-PVC"><span class="toc-number">52.</span> <span class="toc-text">删除 PVC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#busybox"><span class="toc-number">53.</span> <span class="toc-text">busybox</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#针对部分系统无法使用-docker-–userns-remap-的解决方法"><span class="toc-number">54.</span> <span class="toc-text">针对部分系统无法使用 docker –userns-remap 的解决方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#minikube-默认不开启-–userns-remap"><span class="toc-number">55.</span> <span class="toc-text">minikube 默认不开启 –userns-remap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pv-recycler-好像不能跑在-docker-–userns-remap-default-下（User-namespace）"><span class="toc-number">56.</span> <span class="toc-text">pv recycler 好像不能跑在 docker –userns-remap=default 下（User namespace）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-kube-controller-manager-配置-pv-recycler-pod-模板"><span class="toc-number">57.</span> <span class="toc-text">使用 kube-controller-manager 配置 pv-recycler pod 模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#k8s-的-Ingress"><span class="toc-number">58.</span> <span class="toc-text">k8s 的 Ingress</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        k8s/rancher笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Drip</span>
      </span>
      
    <div class="postdate">
        <time datetime="2017-10-29T05:30:30.000Z" itemprop="datePublished">2017-10-29</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><a href="http://docs.kubernetes.org.cn/" target="_blank" rel="external">kubernetes教程</a><br><a href="http://blog.csdn.net/xingwangc2014/article/details/51204224" target="_blank" rel="external">kubernetes教程</a></p>
<h1 id="rancher-通过可视化界面部署-HA-k8s集群"><a href="#rancher-通过可视化界面部署-HA-k8s集群" class="headerlink" title="rancher 通过可视化界面部署 HA k8s集群"></a>rancher 通过可视化界面部署 HA k8s集群</h1><h1 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h1><p>可以很方便的在<strong>本地</strong>快速部署一个<strong>单节点</strong>的k8s集群</p>
<h1 id="zookeeper-扩容"><a href="#zookeeper-扩容" class="headerlink" title="zookeeper 扩容"></a>zookeeper 扩容</h1><p><a href="https://siye1982.github.io/2015/06/16/zookeeper/" target="_blank" rel="external">链接</a><br>依次重启即可，网络可以不间断地提供服务。</p>
<h1 id="重启docker服务"><a href="#重启docker服务" class="headerlink" title="重启docker服务"></a>重启docker服务</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ systemctl restart docker.service</div><div class="line">$ service docker restart</div></pre></td></tr></table></figure>
<h1 id="docker-中央仓库-和-私有仓库"><a href="#docker-中央仓库-和-私有仓库" class="headerlink" title="docker 中央仓库 和 私有仓库"></a>docker 中央仓库 和 私有仓库</h1><p>company/production 或 production 这类表示是中央仓库中的<br>xxx.com/company/produciton 或 xxx.com/production  这类表示是私有仓库中的</p>
<h1 id="minikube-中用到的一些命令"><a href="#minikube-中用到的一些命令" class="headerlink" title="minikube 中用到的一些命令"></a>minikube 中用到的一些命令</h1><p>kubectl get pod –all-namespaces<br>kubectl describe pod yyy –namespace xxxx<br>创建Deployment<br>创建Service</p>
<h1 id="kubectl-command-TYPE-NAME-flags"><a href="#kubectl-command-TYPE-NAME-flags" class="headerlink" title="kubectl [command] [TYPE] [NAME] [flags]"></a>kubectl [command] [TYPE] [NAME] [flags]</h1><p>command: create, get, describe, delete<br>TYPE: resource type，可以说单数，复数，简写<br>资源类型：pod, event, deployment, service, replicationcontroller(rc), replicaset(rs)<br>输入 kubectl get 命令可以返回所有的资源列表<br>下面命名结果是一样的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ kubectl get pod pod1</div><div class="line">$ kubectl get pods pod1</div><div class="line">$ kubectl get po pod1</div></pre></td></tr></table></figure></p>
<p>NAME: the name of the resource，如果名字被省略，显示所有资源，可以得知下面命令执行结果是一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ kubectl get pod</div><div class="line">$ kubectl get pods</div><div class="line">$ kubectl get po</div></pre></td></tr></table></figure></p>
<p>flags：-o json|yaml|wide|name|custom-columns … 输出类型，可以查看具体的内容，不加-o就是简要信息</p>
<h1 id="rollout-上线-运行-的意思"><a href="#rollout-上线-运行-的意思" class="headerlink" title="rollout 上线/运行 的意思"></a>rollout 上线/运行 的意思</h1><h1 id="Deployment-介绍（k8s新功能）"><a href="#Deployment-介绍（k8s新功能）" class="headerlink" title="Deployment 介绍（k8s新功能）"></a>Deployment 介绍（k8s新功能）</h1><p>在新版的Kubernetes官方推荐使用<code>Deployment</code>取代<code>Replication Controller(rc)</code>，两者都支持<strong>滚动升级</strong>（Rolling update），但前者额外支持回滚（Rollback）。   </p>
<blockquote>
<p>Deployment, Replica Sets, Pods 之间的关系<br>├─ Deployment: name<br>│  └─ Replica Set: name-rs<br>│      └─ Pod: name-rs-randomString<br><strong>Deployment管理多份ReplicaSet，ReplicaSet管理多个Pod</strong><br>ReplicaSet（RS）是Replication Controller（RC）的升级版本。ReplicaSet 和  Replication Controller之间的唯一区别是对选择器的支持。ReplicaSet支持labels user guide中描述的set-based选择器要求， 而Replication Controller仅支持equality-based的选择器要求。  </p>
</blockquote>
<h1 id="何时使用ReplicaSet-（不要直接使用，而使用Deployment自动管理ReplicaSet）"><a href="#何时使用ReplicaSet-（不要直接使用，而使用Deployment自动管理ReplicaSet）" class="headerlink" title="何时使用ReplicaSet （不要直接使用，而使用Deployment自动管理ReplicaSet）"></a>何时使用ReplicaSet （不要直接使用，而使用Deployment自动管理ReplicaSet）</h1><p>大多数kubectl 支持Replication Controller 命令的也支持ReplicaSets。rolling-update命令除外，如果要使用rolling-update，请使用Deployments来实现。<br>虽然ReplicaSets可以独立使用，但它主要被 Deployments用作pod 机制的创建、删除和更新。当使用Deployment时，你不必担心创建pod的ReplicaSets，因为可以通过Deployment实现管理ReplicaSets。Deployment 是一个更高层次的概念，它能管理ReplicaSets，并提供对pod的更新等功能。因此，我们建议你使用Deployment来管理ReplicaSets，除非你需要自定义更新编排。  </p>
<h1 id="ReplicaController"><a href="#ReplicaController" class="headerlink" title="ReplicaController"></a>ReplicaController</h1><p>确保用户定义的Pod副本数保持不变。  </p>
<ol>
<li>Rescheduling（重新规划）</li>
<li>扩展</li>
<li>滚动更新</li>
<li>多版本跟踪</li>
<li>使用ReplicationControllers与关联的Services  </li>
</ol>
<p>建议不要使用，Deployment > ReplicaSet > ReplicaController</p>
<h1 id="kubectl-edit-deployment-nginx-deployment-会打开vi，修改保存后会自动触发相关工作"><a href="#kubectl-edit-deployment-nginx-deployment-会打开vi，修改保存后会自动触发相关工作" class="headerlink" title="kubectl edit deployment/nginx-deployment 会打开vi，修改保存后会自动触发相关工作"></a>kubectl edit deployment/nginx-deployment 会打开vi，修改保存后会自动触发相关工作</h1><h1 id="StatefulSets"><a href="#StatefulSets" class="headerlink" title="StatefulSets"></a>StatefulSets</h1><p>Pod调度运行时，如果应用不需要任何稳定的标示、有序的部署、删除和扩展，则应该使用一组无状态副本的控制器来部署应用，例如 <strong>Deployment</strong> 或 <strong>ReplicaSet</strong>更适合无状态服务需求。   </p>
<h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><p>Kubernetes可以使用Namespaces（命名空间）创建多个虚拟集群。Namespace为名称提供了一个范围。资源的Names在Namespace中具有唯一性。<br>Namespace也是一种Resource<br>名字空间为K8s集群提供虚拟的隔离作用，K8s集群初始有两个名字空间，分别是默认名字空间<code>default</code>和系统名字空间<code>kube-system</code>，除此以外，管理员可以可以创建新的名字空间满足需要。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ kubectl create namespace new-namespace</div><div class="line"><span class="comment"># 或</span></div><div class="line">$ cat &lt; EOF &gt; my-namespace.yaml</div><div class="line">apiVersion: v1</div><div class="line">kind: Namespace</div><div class="line">metadata:</div><div class="line">  name: new-namespace</div><div class="line">EOF</div><div class="line">$ kubectl create -f ./my-namespace.yaml</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ kubectl delete namespace my-namespace</div><div class="line"><span class="comment"># 删除一个namespace会自动删除所有属于该namespace的资源。</span></div></pre></td></tr></table></figure>
<h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><p>Kubernetes 最小部署单位  </p>
<ul>
<li>共享相同IP</li>
<li>共享Volume</li>
<li>耦合性高<br>相較於 Docker 中每個容器會擁有各自獨立的 IP，Kubernetes 則是每個在 Pod 內的容器會共享同樣的 IP address 以及 Port space。最直接的好處就是同個 Pod 內的容器可以透過 localhost 來互相溝通。這點和我們在使用一般虛擬機是相同的情況: one prcoess find others with localhost:port</li>
</ul>
<p>由於擁有各自 IP 位址，因此每個位處於同樣 Kubernetes 集群內的 Pod 可以直接透過該 IP 和其他 Pod 進行聯繫，但一般而言我們會透過 service 來取代直接 Pod 存取，這其中表明一件很重要的事情: 在 Cloud 環境中有人做比起誰做來得重要。</p>
<h1 id="Pod-的原理"><a href="#Pod-的原理" class="headerlink" title="Pod 的原理"></a>Pod 的原理</h1><p>首先要明白docker容器是利用linux内核中<strong>namespace</strong> 和 <strong>cgroups</strong> 两个特性实现的。前者保证主机名，进程ID（PID），文件系统，网络接口，进程间通信（IPC）不会冲突。后者现在一个cgroups下运行的<strong>所有进程</strong>的主机资源。<br>默认的docker容器独享自己的namespace和cgroups，而Pod中的容器共享同一个namespace，（cgroups不清楚）。因此Pod中的容器可以：1. 端口不能重复，会冲突（–net）。 2. 可以通过IPC通信（–ipc）。 3. 可以看到各个容器内的进程号（–pid）。<br>docker原生支持融合namespace，<code>docker run --net=container:xx --pid=container:xx --ipc=container:xx</code> (貌似namespace可以分别融合net、ipc、pid的空间，分别是net命名空间，ipc命名空间和pid命名空间)<br><code>ipc</code>: 进程间通信，方法有四种：管道（限制父子进程），共享内存，信号量，消息队列。除去第一种，后面全部需要使用<code>ftok(&#39;filename&#39;, cid)</code> 获得key。而docker的ipc命名空间提供了相互隔离的共享内存、信号量和消息队列。只有通过系统调用将标志符传递给核心之后，进程才能存取这些资源。这种系统IPC对象使用的控制方法和文件系统非常类似。使用对象的引用标志符作为资源表中的索引。实际的<code>消息队列</code>/<code>共享内存</code>/<code>信号量</code>在<code>内核空间</code>。采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据。<br>docker的ipc模式有一下几种：</p>
<table border="1"><br>  <tr><br>    <th>Value</th><br>    <th>Description</th><br>  </tr><br>  <tr><br>    <td>“”</td><br>    <td>Use daemon’s default，maybe private or shareable</td><br>  </tr><br>  <tr><br>    <td>“none”</td><br>    <td>Own private IPC namespace, with /dev/shm not mounted</td><br>  </tr><br>  <tr><br>    <td>“private”</td><br>    <td>Own private IPC namespace</td><br>  </tr><br>  <tr><br>    <td>“shareable”</td><br>    <td>Own private IPC namespace, with a possibility to share it with other containers</td><br>  </tr><br>  <tr><br>    <td>“container”</td><br>    <td><_name-or-id_>“    Join another (“shareable”) container’s IPC namespace</_name-or-id_></td><br>  </tr><br>  <tr><br>    <td>“host”</td><br>    <td>Use the host system’s IPC namespace</td><br>  </tr><br></table>


<h1 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h1><p>系统建立IPC通讯（如消息队列、共享内存时）必须指定一个ID值。通常情况下，该id值通过ftok函数得到。 在一般的UNIX实现中，是将文件的索引（inode）节点号取出，前面加上子序号得到key_t的返回值。如指定文件的索引节点号为65538，换算成16进制为 0x010002，而你指定的ID值为38，换算成16进制为0x26，则最后的key_t返回值为0x26010002。<br>查询文件索引节点号的方法是： ls -i 或 stat    </p>
<h1 id="dev-shim"><a href="#dev-shim" class="headerlink" title="/dev/shim"></a>/dev/shim</h1><p>这个是linux提供的一个便捷的服务，它将共享内存映射为文件，操作文件即操作共享内存。所有进程不需要ftok即可根据/dev/shm中的文件来操作共享内存。</p>
<h1 id="docker-mount-的文件的inode是不会变的，因此可以使用ftok"><a href="#docker-mount-的文件的inode是不会变的，因此可以使用ftok" class="headerlink" title="docker mount 的文件的inode是不会变的，因此可以使用ftok"></a>docker mount 的文件的inode是不会变的，因此可以使用ftok</h1><h1 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h1><p>Volume是Pod中能够被多个容器访问的共享目录。Kubernetes的Volume概念、用途和目的与Docker的Volume比较类似，但不能等价。<br>Kubernetes中的Volume定义在Pod上，被其中的多个容器挂载到具体的文件目录；其次，<strong>Kubernetes中的Volume生命周期与Pod的生命周期相同，但与容器的生命周期不相关</strong>。最后，Kubernetes支持多种类型的Volume，例如Ceph等分布式文件系统。<br>使用方法：  </p>
<ol>
<li>在Deployment yaml中的spec中定义Volumes</li>
<li>在container里面定义volumeMounts</li>
</ol>
<p>丰富的Volume类型：  </p>
<ul>
<li>emptyDir</li>
<li>hostPath 可以永久存储</li>
<li>nfs</li>
</ul>
<h1 id="Persistent-Volume"><a href="#Persistent-Volume" class="headerlink" title="Persistent Volume"></a>Persistent Volume</h1><p><a href="http://blog.csdn.net/wlhdo71920145/article/details/47258367" target="_blank" rel="external">Kubernetes技术分析之存储</a><br>之前所说的Volume是定义在Pod上的，属于“计算资源”的一部分。<br><strong>persistentvolumes</strong>：pv，可以理解成Kubernetes集群中的某个网络存储中对应的一块存储，它与Volume很类似，区别是：</p>
<ol>
<li>PV只能是网络存储</li>
<li>PV不是定义在Pod中的，独立与Pod，是一种resource  </li>
</ol>
<p><strong>persistentvolumeclaims</strong>：pvc，如果某个Pod想用PV中的一部分，需要申请PersistenctVolumeClaim 资源，申请成功后再在Deployment中引用<br>它不和Pod直接发生关系，而是通过Persistent Volume Claim，简称PVC来实现动态绑定。Pod定义里指定的是PVC，然后PVC会根据Pod的要求去自动绑定合适的PV给Pod使用。<br>创建PV有两种，静态和动态：</p>
<ol>
<li>静态：是管理员手动创建一堆PV，组成一个PV池，供PVC来绑定。</li>
<li>动态：是指在现有PV不满足PVC的请求时，可以使用存储分类(StorageClass)，描述具体过程为：PV先创建分类，PVC请求已创建的某个类（StorageClass）的资源，这样就达到动态配置的效果。即通过一个叫 Storage Class的对象由存储系统根据PVC的要求自动创建。</li>
</ol>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>Service 是 Kubernetes 最核心的概念，通过创建Service，可以为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求进行负载分发到后端的各个容器应用上。这个 Service 将被指派一个 IP 地址（通常称为 “Cluster IP”），它会被服务的代理使用。<br>一般，我们创建一个带 selector 的Service，会自动生成一个对应的Endpoints（只有复数形式），里面写着对应的Pod地址。<br>定义在Deployment中的containerPort表示该容器对外的服务端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ kubectl expose deployment xxx <span class="comment"># 快速的创建Service，端口自动生成</span></div><div class="line">$ kubectl create -f xxx-svc.yaml <span class="comment"># 通过配置文件创建Service</span></div><div class="line"><span class="comment"># 在yaml中定义Service中</span></div><div class="line">spec:</div><div class="line">  ports:</div><div class="line">    - port: 8081  <span class="comment"># expose的端口</span></div><div class="line">      targetPort: 8080 <span class="comment"># 容器中的端口</span></div></pre></td></tr></table></figure></p>
<h1 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h1><p>service 需要将 spec.clusterIP 设置成 None。<br>因为没有ClusterIP，kube-proxy 并不处理此类服务，因为没有load balancing或 proxy 代理设置，在访问服务的时候回返回后端的全部的Pods IP地址，主要用于开发者自己根据pods进行负载均衡器的开发(设置了selector)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ cat headless_service.yaml</div><div class="line">kind: Service</div><div class="line">apiVersion: v1</div><div class="line">metadata:</div><div class="line">  name: nginx-service</div><div class="line">spec:</div><div class="line">  selector:</div><div class="line">    app: nginx_test</div><div class="line">  ports:</div><div class="line">    - protocol: TCP</div><div class="line">      port: 80</div><div class="line">      targetPort: 80</div><div class="line">  clusterIP: None</div><div class="line"></div><div class="line"><span class="comment"># 然后登录到pod中执行</span></div><div class="line">$ nslookup nginx-service</div><div class="line">Name:      nginx-service</div><div class="line">Address 1: 10.10.23.36</div><div class="line">Address 2: 10.10.23.39</div></pre></td></tr></table></figure></p>
<h1 id="不使用label-selector-的-Service"><a href="#不使用label-selector-的-Service" class="headerlink" title="不使用label selector 的 Service"></a>不使用label selector 的 Service</h1><p>service除了能够提供一个访问后端pod集的抽象层外，也能被用作抽象任何类型的后端。  </p>
<ul>
<li>你的程序需要访问Kubernetes集群外部的一个用于生产环境的数据库。</li>
<li>你希望service能够指向其他namespace或集群的service。</li>
<li>你正在将一部分的工作负载迁移到Kubernetes集群中而另一部分后端服务还运行在Kubernetes集群外<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先定义一个没有selector属性的Service对象</span></div><div class="line">kind: Service</div><div class="line">apiVersion: v1</div><div class="line">metadata:</div><div class="line">  name: my-service</div><div class="line">spec:</div><div class="line">  ports:</div><div class="line">  - protocol: TCP</div><div class="line">    port: 80</div><div class="line">    targetPort: 9376</div><div class="line"></div><div class="line"><span class="comment"># 然后定义一个Endpoint对象</span></div><div class="line">kind: Endpoints</div><div class="line">apiVersion: v1</div><div class="line">metadata:</div><div class="line">  name: my-service</div><div class="line">subsets:</div><div class="line">  - addresses:</div><div class="line">      - ip: 1.2.3.4</div><div class="line">    ports:</div><div class="line">      - port: 9376</div><div class="line"></div><div class="line"><span class="comment"># 访问一个没有selector属性的service实体的方法与访问有selector的没有任何区别，流量将会被路由到用户自定义的endpoints，在上面的例子中，即：173.194.112.206:80。</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h1 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h1><p>Secret解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者Pod Spec中。Secret可以以Volume或者环境变量的方式使用。<br>这种方式的好处包括：意图明确，避免重复，减少暴漏机会。<br>Secret有三种类型：</p>
<ol>
<li>Service Account：用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中；</li>
<li>Opaque：base64编码格式的Secret，用来存储密码、密钥等；</li>
<li>kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息。<blockquote>
<p>一般我们用第二种就行了  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个secret.yaml</span></div><div class="line">apiVersion: v1</div><div class="line">kind: Secret</div><div class="line">metadata:</div><div class="line">  name: mysecret</div><div class="line"><span class="built_in">type</span>: Opaque</div><div class="line">data:</div><div class="line">  password: MWYyZDFlMmU2N2Rm <span class="comment"># 必须是base64编码</span></div><div class="line">  username: YWRtaW4=</div><div class="line"></div><div class="line">$ kubectl create -f secret.yaml</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>有两种方式使用创建好的Secret资源，pod中读取的都是base64解码后的值  </p>
<ol>
<li>以Volume的形式（这种形式下，每个key都是一个文件，文件内容即为value）</li>
<li>以环境变量的形式（这种比较常用）</li>
</ol>
<h1 id="echo-“xxxxx”-和-echo-n-“xxxxx”-的区别"><a href="#echo-“xxxxx”-和-echo-n-“xxxxx”-的区别" class="headerlink" title="echo “xxxxx” 和 echo -n “xxxxx” 的区别"></a>echo “xxxxx” 和 echo -n “xxxxx” 的区别</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"xxx"</span> <span class="comment"># 自动添加换行符</span></div><div class="line">xxx</div><div class="line">$</div><div class="line">$ <span class="built_in">echo</span> -n <span class="string">"xxx"</span> <span class="comment"># 直接输出内容，不加换行符</span></div><div class="line">xxx$</div></pre></td></tr></table></figure>
<p>因此想要base64编解码正确的话，echo -n<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> -n <span class="string">'stan'</span> | base64  <span class="comment"># 编码</span></div><div class="line">$ <span class="built_in">echo</span> -n <span class="string">'Xcdsg=='</span> | base64 -D <span class="comment"># 解码</span></div></pre></td></tr></table></figure></p>
<h1 id="kubectl-apply-和-kubectl-create-区别"><a href="#kubectl-apply-和-kubectl-create-区别" class="headerlink" title="kubectl apply 和 kubectl create 区别"></a>kubectl apply 和 kubectl create 区别</h1><p>使用<code>kubectl create -f xxx.yaml</code> 之后，无论怎么修改更新<code>xxx.yaml</code>文件，再次调用<code>kubectl -f xxx.yaml</code> 是不会更新k8s上的Pod的。正确的做法是使用<code>kubectl replace -f xxx.yaml</code>。k8s还提供了一种灵活的方法，<code>kubectl edit deploy xxx 或 kubectl edit deploy/xxx</code>。<br><strong>或者更好的方法</strong>：<code>kubectl apply -f xxx.yaml</code>，如果没有该资源，会自动创建，如果已有，会判断是否需要更新！（推荐！）。kubectl apply可以用于之前kubectl create 出来的资源。  </p>
<h1 id="在一个Pod中的多个容器，用localhost就可以通信"><a href="#在一个Pod中的多个容器，用localhost就可以通信" class="headerlink" title="在一个Pod中的多个容器，用localhost就可以通信"></a>在一个Pod中的多个容器，用localhost就可以通信</h1><h1 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h1><p>也是k8s中的一种资源，与Secret结构一样，但是它里面的key-value对中的value必须是string类型。它的使用也有两种方法：volume和env。<br>ConfigMap 与 Secret 的最大区别就是，Secret里面的值都是用base64混淆过的，且使用时可以自动解码。</p>
<h1 id="kubectl-rolling-update-type-name-f-xxx-yaml"><a href="#kubectl-rolling-update-type-name-f-xxx-yaml" class="headerlink" title="kubectl rolling-update type name -f xxx.yaml"></a>kubectl rolling-update type name -f xxx.yaml</h1><p>滚动升级，直接用比较麻烦。我们可以使用Deployment资源，在其中设置.spec<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">strategy:</div><div class="line">    <span class="built_in">type</span>: RollingUpdate</div><div class="line">    rollingUpdate:</div><div class="line">      maxSurge: 1</div><div class="line">      maxUnavailable: 1</div></pre></td></tr></table></figure></p>
<p>然后，apply，replace，edit 都会触发rollingupdate</p>
<h1 id="kubectl-rollout-type-name-可以管理资源的rollout状态"><a href="#kubectl-rollout-type-name-可以管理资源的rollout状态" class="headerlink" title="kubectl rollout type name 可以管理资源的rollout状态"></a>kubectl rollout type name 可以管理资源的rollout状态</h1><p>rollout表示资源的升级/回退</p>
<h1 id="kubectl-命令整理"><a href="#kubectl-命令整理" class="headerlink" title="kubectl 命令整理"></a>kubectl 命令整理</h1><ol>
<li>基本命令，操作资源<ul>
<li>create</li>
<li>expose</li>
<li>get</li>
<li>delete</li>
<li>edit</li>
<li>describe</li>
</ul>
</li>
<li>Deploy命令（低阶命令，可以在Deployment中自动完成）<ul>
<li>rollout  管理资源rollout状态</li>
<li>rolling-update  滚动升级</li>
<li>scale  扩容</li>
<li>autoscale</li>
</ul>
</li>
<li>高阶命令（自动的帮你完成Deploy）<ul>
<li>apply</li>
<li>patch</li>
<li>replace</li>
<li>edit</li>
</ul>
</li>
<li>定位问题命令<ul>
<li>logs</li>
<li>exec</li>
<li>cp</li>
<li>attach</li>
</ul>
</li>
</ol>
<h1 id="port-nodePort-targetPort"><a href="#port-nodePort-targetPort" class="headerlink" title="port, nodePort, targetPort"></a>port, nodePort, targetPort</h1><ul>
<li>port: service暴露在cluster ip上的端口，<cluster ip="">:port 是提供给集群内部客户访问service的入口。</cluster></li>
<li>targetPort: targetPort是pod上的端口，从port和nodePort上到来的数据最终经过kube-proxy流入到后端pod的targetPort上进入容器。</li>
<li>nodePort: odePort是kubernetes提供给集群外部客户访问service入口的一种方式（另一种方式是LoadBalancer），所以，<nodeip>:nodePort 是提供给<strong>集群外部</strong>客户访问service的入口。If you set the type field to “NodePort”, the Kubernetes master will allocate a port from a flag-configured range (default: 30000-32767), and each Node will proxy that port (the same port number on every Node) into your Service. That port will be reported in your Service’s spec.ports[*].nodePort field.     <blockquote>
<p>如果master上也跑着kube-proxy，则也会在它上面打开nodePort这个端口。</p>
</blockquote>
</nodeip></li>
</ul>
<h1 id="Kubernetes-Compose-Kompose"><a href="#Kubernetes-Compose-Kompose" class="headerlink" title="Kubernetes + Compose = Kompose"></a>Kubernetes + Compose = Kompose</h1><p>用于快速的转化compose文件至k8s的yaml文件</p>
<h1 id="Metrics-API-度量"><a href="#Metrics-API-度量" class="headerlink" title="Metrics API (度量)"></a>Metrics API (度量)</h1><p>This API allows consumers to access arbitrary metrics which describe Kubernetes resources. 获取资源（cpu 和 memory）的统计量</p>
<h1 id="mount：前面挂载到后面"><a href="#mount：前面挂载到后面" class="headerlink" title="mount：前面挂载到后面"></a>mount：前面挂载到后面</h1><h1 id="docker-里面前面是主机，后面是容器"><a href="#docker-里面前面是主机，后面是容器" class="headerlink" title="docker 里面前面是主机，后面是容器"></a>docker 里面前面是主机，后面是容器</h1><h1 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h1><h1 id="go-client-库其实也是使用的k8s的-restful-接口"><a href="#go-client-库其实也是使用的k8s的-restful-接口" class="headerlink" title="go-client 库其实也是使用的k8s的 restful 接口"></a>go-client 库其实也是使用的k8s的 restful 接口</h1><h1 id="docker-ps-a-awk-‘-Exited-print-1-’-xargs-docker-rm-f’"><a href="#docker-ps-a-awk-‘-Exited-print-1-’-xargs-docker-rm-f’" class="headerlink" title="docker ps -a | awk ‘/Exited/ {print $1}’ | xargs docker rm -f’"></a>docker ps -a | awk ‘/Exited/ {print $1}’ | xargs docker rm -f’</h1><h1 id="配置-kubectl-垃圾回收策略"><a href="#配置-kubectl-垃圾回收策略" class="headerlink" title="配置 kubectl 垃圾回收策略"></a>配置 kubectl 垃圾回收策略</h1><p>Kubelet will perform garbage collection for containers <code>every minute</code> and garbage collection for images <code>every five minutes</code>.<br><strong>镜像回收</strong>:<br>The policy for garbage collecting images takes two factors into consideration: HighThresholdPercent and LowThresholdPercent. Disk usage above the high threshold will trigger garbage collection. The garbage collection will delete least recently used images until the low threshold has been met.<br>设置这两个参数： <code>image-gc-high-threshold</code> <code>image-gc-low-threshold</code></p>
<p><strong>容器回收</strong>:<br>The policy for garbage collecting containers considers three user-defined variables. MinAge is the minimum age at which a container can be garbage collected. MaxPerPodContainer is the maximum number of dead containers every single pod (UID, container name) pair is allowed to have. MaxContainers is the maximum number of total dead containers. These variables can be individually disabled by setting MinAge to zero and setting MaxPerPodContainer and MaxContainers respectively to less than zero.<br>设置这些参数： <code>minimum-container-ttl-duration</code> <code>maximum-dead-containers-per-container</code> <code>maximum-dead-containers</code> </p>
<h1 id="Dealing-with-Disruptions"><a href="#Dealing-with-Disruptions" class="headerlink" title="Dealing with Disruptions"></a>Dealing with Disruptions</h1><p><a href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/" target="_blank" rel="external">用于实现高可靠性自动伸缩的服务</a></p>
<h1 id="Kubernetes-中的port、nodePort、targetPort"><a href="#Kubernetes-中的port、nodePort、targetPort" class="headerlink" title="Kubernetes 中的port、nodePort、targetPort"></a>Kubernetes 中的port、nodePort、targetPort</h1><p>port 是 cluster-ip 使用的端口<br>targetPort 是 kube-proxy 转发至容器的端口，即 Deploy 中的 containerPort<br>nodePort 是暴露在 node 上的端口</p>
<h1 id="Docker-基础知识"><a href="#Docker-基础知识" class="headerlink" title="Docker 基础知识"></a>Docker 基础知识</h1><ol>
<li>挂载的文件/目录的RWX权限不会改变，但是所有用户/组会变成当前运行容器中用户和用户组。（即使容器中是root用户，也不能越权修改对应于宿主机用户没有权限的文件，因为它对应宿主机的进程的用户还是之前的普通用户）。即使加上 <code>--privileged</code> 参数也是不行的，容器的root对应的还是普通用户，只是开启了访问宿主机上device的权限（When the operator executes docker run –privileged, Docker will enable access to all devices on the host as well as set some configuration in AppArmor or SELinux to allow the container nearly all the same access to the host as processes running outside containers on the host. ）</li>
<li>如果容器需要访问宿主机上的某些device，除了使用 <code>--privileged</code> 开启访问所有device的权限，还可以使用 <code>--device=/dev/snd:/dev/snd</code> 显示指定容器内可以访问的device列表</li>
<li>Dockerfile 中若没有指定当前用户，则容器运行时默认是root（虽然是假的root），可以在Dockerfile中 <code>USER redis</code> 或者运行时 <code>docker run -u xxx</code> 来指定运行时的用户</li>
</ol>
<h1 id="–privilege-参数不能让-Docker-容器内的-root-用户修改宿主机普通用户无法修改的文件，防止越权"><a href="#–privilege-参数不能让-Docker-容器内的-root-用户修改宿主机普通用户无法修改的文件，防止越权" class="headerlink" title="–privilege 参数不能让 Docker 容器内的 root 用户修改宿主机普通用户无法修改的文件，防止越权"></a>–privilege 参数不能让 Docker 容器内的 root 用户修改宿主机普通用户无法修改的文件，防止越权</h1><p>容器内的 root 或 -u 指定的其他用户，在外部宿主机上都只对应当前的普通用户，只是在容器内非挂载的文件上有权限区分。<br>–privileged 提供容器访问宿主机device的权限</p>
<h1 id="Docker-是否支持-Linux-User-Namespace"><a href="#Docker-是否支持-Linux-User-Namespace" class="headerlink" title="Docker 是否支持 Linux User Namespace"></a>Docker 是否支持 Linux User Namespace</h1><p>在 Docker 1.10 版本之前，Docker 是不支持 user namespace。也就是说，默认地，容器内的进程的运行用户就是 host 上的 root 用户，这样的话，当 host 上的文件或者目录作为 volume 被映射到容器以后，容器内的进程其实是有 root 的几乎所有权限去修改这些 host 上的目录的，这会有很大的安全问题。<br>虽然在 Docker 1.10 版本之前，容器内的 root 用户就是宿主机上的 root 用户，但是 Docker 采用了 Linux Capabilities 机制（<strong>详见下一条知识点</strong>）来保证不会影响宿主机的安全。<br>在 1.10 版本之后，加入了 Linux User Namespace，采用了userns-remap（<strong>详情见下一条知识点</strong>），简单来说容器里面的 root 用户只对应宿主机上的普通用户。</p>
<blockquote>
<p>容器内的root其实就是宿主机的普通用户，如果想在容器内使用真正的root，可以尝试下 –privileged 参数</p>
</blockquote>
<h1 id="Linux-Capabilities-机制"><a href="#Linux-Capabilities-机制" class="headerlink" title="Linux Capabilities 机制"></a>Linux Capabilities 机制</h1><p>大家一定知道，在传统的 Unix 系统中，为了实现权限的检查，操作系统上运行的进程可以分为两种：特权进程（priviledged processes）和非特权进程（unpriviledged processes）。其中，前者的有效用户ID为0，也就是大家常说的超级用户或者 root 用户，而后者的有效用户非0，也常被称为普通用户。特权进程在运行时们可以绕过所有的内核权限检查，而非特权进程则必须完全接受这些检查。    </p>
<p>虽然如此，然而实际情况要比以上的描述复杂一些。实际情况下，Linux 会将传统超级用户的特权划分为多个单位，也就是我们关心的 Capabilties。Capabilities 会有很多种，而且对于 root 用户而言，完全可以单独启用或者关闭，因此同为 root 用户，权限却因 Capabilities 的不同而存在差异。   </p>
<p>Linux Capabilities 机制将超级用户的权限划分非常之细，所有的 Capabilities 列表有接近40项之多。我们可以通过几个具体的 Capability 来看看他们各自管理的权限范围。   </p>
<p>CAPSYSADMIN:CAPSYSADMIN 实现一系列的系统管理权限，比如实现磁盘配额的 quotactl，实现文件系统挂载的 mount 权限；比如在 fork 子进程时，通过 clone 和 unshare 系统调用，使用 CLONE_* 的 flag 参数来为子进程创建新的 namespaces ；比如实现各种特权块设备以及文件系统的 ioctl 操作等。   </p>
<p>CAPNETADMIN：CAPNETADMIN 实现一系列的网络管理权限，比如网络设备的配置，IP 防火墙，IP 伪装以及统计等功能；比如路由表的修改， TOS 的配置，混杂模式的配置等。   </p>
<p>CAPSETUID:CAPSETUID 有能力对进程 UID 做出任何管控。   </p>
<p>CAPSYSMODULE:CAPSYSMODULE 帮助 root 用户加载或者卸载相应的 Linux 内核模块。   </p>
<p>CAPSYSNICE:CAPSYSNICE 有能力对任意进程修改其 NICE 值，同时支持对任何进程设置调度策略与优先级，还有在进程的 CPU 亲和性以及 I/O 调度方面有相应的配置权限。   </p>
<p>Linux 总共有接近40项的 Capabilities，然而初步接触以上5项 Capabilties，我们可以发现：Linux 对于超级用户的特权也进行了种类繁多的划分，有划分就意味着有区别，有区别就意味着并不是所有的 root 用户都拥有相同的权限.   </p>
<p><em>Docker 容器的非特权模式</em><br>默认情况下，docker run 命令的 privileged 参数值为 false。因此，毫无疑问，Docker 容器内部的 root 用户将受到严格的权限限制，很多有系统相关的操作权限都将被剥夺，只具备超级用户的一些基本权限。    </p>
<p>研究 Docker 的源码，我们可以发现：在 Linux 接近40项的 Capabilities 中，Docker为了确保容器的安全，仅仅支持了其中的14项基本的 Capabilities，现在，我们不妨来看看这些 Capabilities 到底有哪些，它们分别是： CAP_CHOWN、 CAP_DAC_OVERRIDE、 CAP_FSETID、 CAP_MKNOD、 FOWNER、 NET_RAW、 SETGID、 SETUID、 SETFCAP、 SETPCAP、 NET_BIND_SERVICE、 SYS_CHROOT、 KILL和AUDIT_WRITE。    </p>
<p>我们可以发现：在这14项中几乎没有一项涉及到系统管理权限，比如 Docker 容器的 root 用户不具备 CAPSYSADMIN，磁盘限额操作，mount 操作，创建进程新命名空间等均无法实现；比如由于没有CAPNETADMIN，网络方面的配置管理也将受到管制。因此，默认情况下，Docker 容器中的 root 用户并没有以往我们想象得那么能力超群，Docker 依然对其存在限制，这样设计的出发点之一自然是安全。    </p>
<p><em>Docker 容器的特权模式</em><br>了解完 Docker 容器的非特权模式，大家也许会觉得 Docker 容器的 root 权限被削减得有点难以置信：确保安全，却剥夺了过多系统权限。其实，Docker 作为一个管理容器的工具，并未在容器 root 方面“一刀切”，Docker 容器的非特权模式就可以满足 root 用户的权限最大化。    </p>
<p>一旦将 docker run命令的 privileged 参数设为 true，那么 Docker 容器的 root 权限将得到大幅度的提升。此时，Docker容器的 root 用户将获得37项 Capabilities 能力。由于 Docker 容器与宿主机处于共享同一个内核操作系统的状态，因此，Docker 容器将完全拥有内核的管理权限。安全隐患，瞬间浮出水面。    </p>
<p>但是 1.10 版本之后，采用 User Namespace之后就没有这个问题了。</p>
<h1 id="userns-remap"><a href="#userns-remap" class="headerlink" title="userns-remap"></a>userns-remap</h1><p>Docker 1.10 中引入的 user namespace 就可以让容器有一个 “假”的  root 用户，它在容器内是 root，在容器外是一个非 root 用户。也就是说，user namespace 实现了 host users 和 container users 之间的映射。<br>启用步骤：    </p>
<ol>
<li>修改 /etc/default/docker 文件，添加行  DOCKER_OPTS=”–userns-remap=default”</li>
<li>重启 docker 服务，此时 dockerd 进程为 /usr/bin/dockerd –userns-remap=default –raw-logs</li>
</ol>
<p><a href="http://www.cnblogs.com/sammyliu/p/5878973.html" target="_blank" rel="external">详细说明</a></p>
<p><a href="https://docs.docker.com/engine/security/userns-remap/" target="_blank" rel="external">官方文档</a></p>
<p><a href="https://docs.docker.com/engine/admin/systemd/#start-automatically-at-system-boot" target="_blank" rel="external">Docker Daemon 配置参数</a></p>
<h1 id="Pod-中的-label-至少被-Service-和-Deployment-中的-Selector-用到了"><a href="#Pod-中的-label-至少被-Service-和-Deployment-中的-Selector-用到了" class="headerlink" title="Pod 中的 label 至少被 Service 和 Deployment 中的 Selector 用到了"></a>Pod 中的 label 至少被 Service 和 Deployment 中的 Selector 用到了</h1><p>Deployment 和 Service 中的 label 是不是设置了没什么用 ？？</p>
<h1 id="StatefulSet-中-spec-serviceName-很重要，这个参数在-Deployment-中都没有"><a href="#StatefulSet-中-spec-serviceName-很重要，这个参数在-Deployment-中都没有" class="headerlink" title="StatefulSet 中 .spec.serviceName 很重要，这个参数在 Deployment 中都没有"></a>StatefulSet 中 .spec.serviceName 很重要，这个参数在 Deployment 中都没有</h1><h1 id="删除-PVC"><a href="#删除-PVC" class="headerlink" title="删除 PVC"></a>删除 PVC</h1><p>设置PV时，如果设置了回收策略是“回收”的时候，在删除PVC时，系统（Controller-Manager）会启动一个recycler的Pod，用于清理数据卷中的内容。每种数据卷的回收Pod是不同的，都有自己特定的逻辑<br><a href="http://www.cnblogs.com/zhenyuyaodidiao/p/6632600.html" target="_blank" rel="external">链接</a></p>
<h1 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h1><p>瑞士军刀，一个很小的工具集Linux系统</p>
<h1 id="针对部分系统无法使用-docker-–userns-remap-的解决方法"><a href="#针对部分系统无法使用-docker-–userns-remap-的解决方法" class="headerlink" title="针对部分系统无法使用 docker –userns-remap 的解决方法"></a>针对部分系统无法使用 docker –userns-remap 的解决方法</h1><p><a href="https://github.com/boot2docker/boot2docker/issues/1134" target="_blank" rel="external">链接</a>    </p>
<ol>
<li>手动创建 dockremap 用户和群组</li>
<li>手动创建 /etc/subuid 和 /etc/subgid 文件，并写入 dockremap:100000:65536</li>
<li>重启 dockerd –userns-remap=defalut   (一旦设置为defalut，docker 会使用 dockremap 这个用户)</li>
</ol>
<h1 id="minikube-默认不开启-–userns-remap"><a href="#minikube-默认不开启-–userns-remap" class="headerlink" title="minikube 默认不开启 –userns-remap"></a>minikube 默认不开启 –userns-remap</h1><ol>
<li>使用上面的方法，手动开启</li>
<li>或者，minikube start –feature-gates=ExperimentalHostUserNamespaceDefaulting=true</li>
</ol>
<h1 id="pv-recycler-好像不能跑在-docker-–userns-remap-default-下（User-namespace）"><a href="#pv-recycler-好像不能跑在-docker-–userns-remap-default-下（User-namespace）" class="headerlink" title="pv recycler 好像不能跑在 docker –userns-remap=default 下（User namespace）"></a>pv recycler 好像不能跑在 docker –userns-remap=default 下（User namespace）</h1><p>因为不是root，可能无法删除一些文件。貌似 K8S 在 这种模式下的 Docker 中运行会有问题？</p>
<h1 id="使用-kube-controller-manager-配置-pv-recycler-pod-模板"><a href="#使用-kube-controller-manager-配置-pv-recycler-pod-模板" class="headerlink" title="使用 kube-controller-manager 配置 pv-recycler pod 模板"></a>使用 kube-controller-manager 配置 pv-recycler pod 模板</h1><p>若使用 minikube 创建的单机集群，可以使用下面的命令 <code>minikube start --extra-config=controller-manager.VolumeConfiguration.PersistentVolumeRecyclerConfiguration.PodTemplateFilePathNFS=/Users/landleany/go/src/myself/k8s/dep/kube/recycler.yaml</code></p>
<h1 id="k8s-的-Ingress"><a href="#k8s-的-Ingress" class="headerlink" title="k8s 的 Ingress"></a>k8s 的 Ingress</h1><p>Kubernetes 暴露服务的方式目前只有三种：LoadBlancer Service、NodePort Service、Ingress；前两种估计都应该很熟悉。<br>可是 nginx 的 L4 转发 还是会占用端口啊？？</p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rancher-通过可视化界面部署-HA-k8s集群"><span class="toc-number">1.</span> <span class="toc-text">rancher 通过可视化界面部署 HA k8s集群</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Minikube"><span class="toc-number">2.</span> <span class="toc-text">Minikube</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zookeeper-扩容"><span class="toc-number">3.</span> <span class="toc-text">zookeeper 扩容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重启docker服务"><span class="toc-number">4.</span> <span class="toc-text">重启docker服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-中央仓库-和-私有仓库"><span class="toc-number">5.</span> <span class="toc-text">docker 中央仓库 和 私有仓库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#minikube-中用到的一些命令"><span class="toc-number">6.</span> <span class="toc-text">minikube 中用到的一些命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-command-TYPE-NAME-flags"><span class="toc-number">7.</span> <span class="toc-text">kubectl [command] [TYPE] [NAME] [flags]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rollout-上线-运行-的意思"><span class="toc-number">8.</span> <span class="toc-text">rollout 上线/运行 的意思</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Deployment-介绍（k8s新功能）"><span class="toc-number">9.</span> <span class="toc-text">Deployment 介绍（k8s新功能）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#何时使用ReplicaSet-（不要直接使用，而使用Deployment自动管理ReplicaSet）"><span class="toc-number">10.</span> <span class="toc-text">何时使用ReplicaSet （不要直接使用，而使用Deployment自动管理ReplicaSet）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReplicaController"><span class="toc-number">11.</span> <span class="toc-text">ReplicaController</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-edit-deployment-nginx-deployment-会打开vi，修改保存后会自动触发相关工作"><span class="toc-number">12.</span> <span class="toc-text">kubectl edit deployment/nginx-deployment 会打开vi，修改保存后会自动触发相关工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StatefulSets"><span class="toc-number">13.</span> <span class="toc-text">StatefulSets</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Namespace"><span class="toc-number">14.</span> <span class="toc-text">Namespace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pod"><span class="toc-number">15.</span> <span class="toc-text">Pod</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pod-的原理"><span class="toc-number">16.</span> <span class="toc-text">Pod 的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ftok"><span class="toc-number">17.</span> <span class="toc-text">ftok</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dev-shim"><span class="toc-number">18.</span> <span class="toc-text">/dev/shim</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-mount-的文件的inode是不会变的，因此可以使用ftok"><span class="toc-number">19.</span> <span class="toc-text">docker mount 的文件的inode是不会变的，因此可以使用ftok</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Volume"><span class="toc-number">20.</span> <span class="toc-text">Volume</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Persistent-Volume"><span class="toc-number">21.</span> <span class="toc-text">Persistent Volume</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Service"><span class="toc-number">22.</span> <span class="toc-text">Service</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Headless-Service"><span class="toc-number">23.</span> <span class="toc-text">Headless Service</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不使用label-selector-的-Service"><span class="toc-number">24.</span> <span class="toc-text">不使用label selector 的 Service</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nginx"><span class="toc-number">25.</span> <span class="toc-text">nginx</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Secret"><span class="toc-number">26.</span> <span class="toc-text">Secret</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#echo-“xxxxx”-和-echo-n-“xxxxx”-的区别"><span class="toc-number">27.</span> <span class="toc-text">echo “xxxxx” 和 echo -n “xxxxx” 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-apply-和-kubectl-create-区别"><span class="toc-number">28.</span> <span class="toc-text">kubectl apply 和 kubectl create 区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在一个Pod中的多个容器，用localhost就可以通信"><span class="toc-number">29.</span> <span class="toc-text">在一个Pod中的多个容器，用localhost就可以通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConfigMap"><span class="toc-number">30.</span> <span class="toc-text">ConfigMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-rolling-update-type-name-f-xxx-yaml"><span class="toc-number">31.</span> <span class="toc-text">kubectl rolling-update type name -f xxx.yaml</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-rollout-type-name-可以管理资源的rollout状态"><span class="toc-number">32.</span> <span class="toc-text">kubectl rollout type name 可以管理资源的rollout状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kubectl-命令整理"><span class="toc-number">33.</span> <span class="toc-text">kubectl 命令整理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#port-nodePort-targetPort"><span class="toc-number">34.</span> <span class="toc-text">port, nodePort, targetPort</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-Compose-Kompose"><span class="toc-number">35.</span> <span class="toc-text">Kubernetes + Compose = Kompose</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Metrics-API-度量"><span class="toc-number">36.</span> <span class="toc-text">Metrics API (度量)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount：前面挂载到后面"><span class="toc-number">37.</span> <span class="toc-text">mount：前面挂载到后面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-里面前面是主机，后面是容器"><span class="toc-number">38.</span> <span class="toc-text">docker 里面前面是主机，后面是容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#探针"><span class="toc-number">39.</span> <span class="toc-text">探针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go-client-库其实也是使用的k8s的-restful-接口"><span class="toc-number">40.</span> <span class="toc-text">go-client 库其实也是使用的k8s的 restful 接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-ps-a-awk-‘-Exited-print-1-’-xargs-docker-rm-f’"><span class="toc-number">41.</span> <span class="toc-text">docker ps -a | awk ‘/Exited/ {print $1}’ | xargs docker rm -f’</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#配置-kubectl-垃圾回收策略"><span class="toc-number">42.</span> <span class="toc-text">配置 kubectl 垃圾回收策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dealing-with-Disruptions"><span class="toc-number">43.</span> <span class="toc-text">Dealing with Disruptions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-中的port、nodePort、targetPort"><span class="toc-number">44.</span> <span class="toc-text">Kubernetes 中的port、nodePort、targetPort</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-基础知识"><span class="toc-number">45.</span> <span class="toc-text">Docker 基础知识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#–privilege-参数不能让-Docker-容器内的-root-用户修改宿主机普通用户无法修改的文件，防止越权"><span class="toc-number">46.</span> <span class="toc-text">–privilege 参数不能让 Docker 容器内的 root 用户修改宿主机普通用户无法修改的文件，防止越权</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-是否支持-Linux-User-Namespace"><span class="toc-number">47.</span> <span class="toc-text">Docker 是否支持 Linux User Namespace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-Capabilities-机制"><span class="toc-number">48.</span> <span class="toc-text">Linux Capabilities 机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#userns-remap"><span class="toc-number">49.</span> <span class="toc-text">userns-remap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pod-中的-label-至少被-Service-和-Deployment-中的-Selector-用到了"><span class="toc-number">50.</span> <span class="toc-text">Pod 中的 label 至少被 Service 和 Deployment 中的 Selector 用到了</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StatefulSet-中-spec-serviceName-很重要，这个参数在-Deployment-中都没有"><span class="toc-number">51.</span> <span class="toc-text">StatefulSet 中 .spec.serviceName 很重要，这个参数在 Deployment 中都没有</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#删除-PVC"><span class="toc-number">52.</span> <span class="toc-text">删除 PVC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#busybox"><span class="toc-number">53.</span> <span class="toc-text">busybox</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#针对部分系统无法使用-docker-–userns-remap-的解决方法"><span class="toc-number">54.</span> <span class="toc-text">针对部分系统无法使用 docker –userns-remap 的解决方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#minikube-默认不开启-–userns-remap"><span class="toc-number">55.</span> <span class="toc-text">minikube 默认不开启 –userns-remap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pv-recycler-好像不能跑在-docker-–userns-remap-default-下（User-namespace）"><span class="toc-number">56.</span> <span class="toc-text">pv recycler 好像不能跑在 docker –userns-remap=default 下（User namespace）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-kube-controller-manager-配置-pv-recycler-pod-模板"><span class="toc-number">57.</span> <span class="toc-text">使用 kube-controller-manager 配置 pv-recycler pod 模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#k8s-的-Ingress"><span class="toc-number">58.</span> <span class="toc-text">k8s 的 Ingress</span></a></li></ol>
    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 Landleany
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


