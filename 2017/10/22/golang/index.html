<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="select case 不能像switch一样使用fallthrough 没有顺序，从多个不阻塞的case中随机选择一个执行  channel1234567ch := make(chan int)  // ch是没有缓冲的ch &amp;lt;- 1   // 该操作会被阻塞，必须在另一个协程中执行 &amp;lt;- ch 才能发送成功&amp;lt;- ch   // 因此在同一个协程中向一个没有缓冲的通道中发送数据">
<meta property="og:type" content="article">
<meta property="og:title" content="golang笔记">
<meta property="og:url" content="http://yoursite.com/2017/10/22/golang/index.html">
<meta property="og:site_name" content="Drip">
<meta property="og:description" content="select case 不能像switch一样使用fallthrough 没有顺序，从多个不阻塞的case中随机选择一个执行  channel1234567ch := make(chan int)  // ch是没有缓冲的ch &amp;lt;- 1   // 该操作会被阻塞，必须在另一个协程中执行 &amp;lt;- ch 才能发送成功&amp;lt;- ch   // 因此在同一个协程中向一个没有缓冲的通道中发送数据">
<meta property="og:updated_time" content="2018-09-07T06:12:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="golang笔记">
<meta name="twitter:description" content="select case 不能像switch一样使用fallthrough 没有顺序，从多个不阻塞的case中随机选择一个执行  channel1234567ch := make(chan int)  // ch是没有缓冲的ch &amp;lt;- 1   // 该操作会被阻塞，必须在另一个协程中执行 &amp;lt;- ch 才能发送成功&amp;lt;- ch   // 因此在同一个协程中向一个没有缓冲的通道中发送数据">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>golang笔记</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2017/10/29/k8s/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2017/10/21/dva/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2017/10/22/golang/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2017/10/22/golang/&text=golang笔记"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2017/10/22/golang/&title=golang笔记"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2017/10/22/golang/&is_video=false&description=golang笔记"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=golang笔记&body=Check out this article: http://yoursite.com/2017/10/22/golang/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2017/10/22/golang/&title=golang笔记"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2017/10/22/golang/&title=golang笔记"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2017/10/22/golang/&title=golang笔记"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2017/10/22/golang/&title=golang笔记"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2017/10/22/golang/&name=golang笔记&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#select-case"><span class="toc-number">1.</span> <span class="toc-text">select case</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#channel"><span class="toc-number">2.</span> <span class="toc-text">channel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#channel-操作要小心"><span class="toc-number">3.</span> <span class="toc-text">channel 操作要小心</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可以使用-reflection-DeepEqual-x-y-interface-bool-来判断两个元素是否相等"><span class="toc-number">4.</span> <span class="toc-text">可以使用 reflection.DeepEqual(x, y interface{}) bool 来判断两个元素是否相等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#byte-的比较"><span class="toc-number">5.</span> <span class="toc-text">[]byte 的比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带缓冲的channel"><span class="toc-number">6.</span> <span class="toc-text">带缓冲的channel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#千万不要在forloop-中的select中写break"><span class="toc-number">7.</span> <span class="toc-text">千万不要在forloop 中的select中写break</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#json-Unmarshal-原理和常见问题"><span class="toc-number">8.</span> <span class="toc-text">json.Unmarshal 原理和常见问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#struct-tag-中设置-json-quot-quot-表示忽略该字段。另外只有大写的字段才可以被-Marshal-和-Unmarshal"><span class="toc-number">9.</span> <span class="toc-text">struct tag 中设置 json:"-" 表示忽略该字段。另外只有大写的字段才可以被 Marshal 和 Unmarshal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#json-Unmarshal必须传入对象的地址"><span class="toc-number">10.</span> <span class="toc-text">json.Unmarshal必须传入对象的地址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注意strings-Split-“”-“-”-会形成长度为1的切片。第0个位置为一个空字符。"><span class="toc-number">11.</span> <span class="toc-text">注意strings.Split(“”, “,”)会形成长度为1的切片。第0个位置为一个空字符。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chan-int-和-chan-lt-int-和-lt-chan-int-作为参数类型的区别"><span class="toc-number">12.</span> <span class="toc-text">chan int 和 chan<- int 和 <-chan int 作为参数类型的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#全局中-var-a-make-map-int-int-是可以的，不用非要放到-init-中初始化"><span class="toc-number">13.</span> <span class="toc-text">全局中 var a = make(map[int]int) 是可以的，不用非要放到 init() 中初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sync-Once-一般用于惰性初始化"><span class="toc-number">14.</span> <span class="toc-text">sync.Once 一般用于惰性初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sync-Mutex-sync-RWMutex"><span class="toc-number">15.</span> <span class="toc-text">sync.Mutex sync.RWMutex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go-get-github-com-xxx-…-表示下载并安装xxx下所有库（即子库）"><span class="toc-number">16.</span> <span class="toc-text">go get github.com/xxx/… 表示下载并安装xxx下所有库（即子库）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关于嵌套-vendor-，你想知道的"><span class="toc-number">17.</span> <span class="toc-text">关于嵌套 vendor ，你想知道的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#由errors-New或fmt-Errorf返回的错误变量，它们实现了error-interface"><span class="toc-number">18.</span> <span class="toc-text">由errors.New或fmt.Errorf返回的错误变量，它们实现了error interface</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#govendor-使用方法"><span class="toc-number">19.</span> <span class="toc-text">govendor 使用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang-中的编码-UTF8"><span class="toc-number">20.</span> <span class="toc-text">golang 中的编码 UTF8</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang-版本选择"><span class="toc-number">21.</span> <span class="toc-text">golang 版本选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#build-main"><span class="toc-number">22.</span> <span class="toc-text">build main</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#继承"><span class="toc-number">23.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌入"><span class="toc-number">24.</span> <span class="toc-text">嵌入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang-的不同进制输出"><span class="toc-number">25.</span> <span class="toc-text">golang 的不同进制输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#就是取反"><span class="toc-number">26.</span> <span class="toc-text">^ 就是取反</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#切片类型的一个坑"><span class="toc-number">27.</span> <span class="toc-text">切片类型的一个坑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开发一个-golang-应用会用的一些常见库"><span class="toc-number">28.</span> <span class="toc-text">开发一个 golang 应用会用的一些常见库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang-实战技巧"><span class="toc-number">29.</span> <span class="toc-text">golang 实战技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何安全的写入-channel"><span class="toc-number">30.</span> <span class="toc-text">如何安全的写入 channel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iota-是重新计数的"><span class="toc-number">31.</span> <span class="toc-text">iota 是重新计数的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#encoding-gob-即Go-binary-的缩写-是-golang-自带的编码-解码器（可用于-rpc）"><span class="toc-number">32.</span> <span class="toc-text">encoding/gob (即Go binary 的缩写)是 golang 自带的编码/解码器（可用于 rpc）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#time-Tick-time-Duration-是对-time-NewTicker-time-Duration-的-wrapper，方便提供通道"><span class="toc-number">33.</span> <span class="toc-text">time.Tick(time.Duration) 是对 time.NewTicker(time.Duration) 的 wrapper，方便提供通道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RoundTripper"><span class="toc-number">34.</span> <span class="toc-text">RoundTripper</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go-run"><span class="toc-number">35.</span> <span class="toc-text">go run</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        golang笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Drip</span>
      </span>
      
    <div class="postdate">
        <time datetime="2017-10-22T05:30:30.000Z" itemprop="datePublished">2017-10-22</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="select-case"><a href="#select-case" class="headerlink" title="select case"></a>select case</h1><ul>
<li>不能像switch一样使用fallthrough</li>
<li>没有顺序，从多个不阻塞的case中随机选择一个执行</li>
</ul>
<h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">// ch是没有缓冲的</span></div><div class="line">ch &lt;- <span class="number">1</span>   <span class="comment">// 该操作会被阻塞，必须在另一个协程中执行 &lt;- ch 才能发送成功</span></div><div class="line">&lt;- ch   <span class="comment">// 因此在同一个协程中向一个没有缓冲的通道中发送数据会被阻塞</span></div><div class="line"></div><div class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)  <span class="comment">// ch带一个数据的缓冲</span></div><div class="line">ch &lt;- <span class="number">1</span></div><div class="line">&lt;- ch  <span class="comment">// 可以顺利执行</span></div></pre></td></tr></table></figure>
<h1 id="channel-操作要小心"><a href="#channel-操作要小心" class="headerlink" title="channel 操作要小心"></a>channel 操作要小心</h1><ul>
<li><p>向关闭的chan传值，不会被阻塞，而且会panic，非常危险</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 由于向关闭的chan传值不会阻塞，</span></div><div class="line"><span class="comment">//且case选择的随机性，</span></div><div class="line"><span class="comment">//下面的代码有一定概率出错</span></div><div class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line"><span class="built_in">close</span>(ch)</div><div class="line"><span class="keyword">select</span> &#123;</div><div class="line"><span class="keyword">case</span> &lt;- ch:</div><div class="line"><span class="keyword">case</span> ch &lt;- <span class="number">1</span>:</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>向关闭的chan取值还是比较安全的，至少不会panic</p>
</li>
</ul>
<h1 id="可以使用-reflection-DeepEqual-x-y-interface-bool-来判断两个元素是否相等"><a href="#可以使用-reflection-DeepEqual-x-y-interface-bool-来判断两个元素是否相等" class="headerlink" title="可以使用 reflection.DeepEqual(x, y interface{}) bool 来判断两个元素是否相等"></a>可以使用 reflection.DeepEqual(x, y interface{}) bool 来判断两个元素是否相等</h1><h1 id="byte-的比较"><a href="#byte-的比较" class="headerlink" title="[]byte 的比较"></a>[]byte 的比较</h1><p>不能使用 == ，而要使用 bytes.Compare(a, b []byte)</p>
<h1 id="带缓冲的channel"><a href="#带缓冲的channel" class="headerlink" title="带缓冲的channel"></a>带缓冲的channel</h1><p>一般来说channel用于跨协程的通信<br>但是对于带缓冲的channel，可以用于单协程(不会造成阻塞)<br>例如下面的代码交替输出ch和ph<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</div><div class="line">ph := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</div><div class="line">ph &lt;- <span class="number">1</span></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  <span class="keyword">select</span> &#123;</div><div class="line">  <span class="keyword">case</span> &lt;- ph:</div><div class="line">    ch &lt;- <span class="number">1</span></div><div class="line">  <span class="keyword">case</span> &lt;- ch:</div><div class="line">    ph &lt;- <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="千万不要在forloop-中的select中写break"><a href="#千万不要在forloop-中的select中写break" class="headerlink" title="千万不要在forloop 中的select中写break"></a>千万不要在forloop 中的select中写break</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面的代码会死循环</span></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">  <span class="keyword">select</span> &#123;</div><div class="line">  <span class="keyword">case</span> &lt;- <span class="built_in">close</span>:</div><div class="line">    <span class="keyword">break</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="json-Unmarshal-原理和常见问题"><a href="#json-Unmarshal-原理和常见问题" class="headerlink" title="json.Unmarshal 原理和常见问题"></a>json.Unmarshal 原理和常见问题</h1><ol>
<li>首先将json字符串转成Unmarshaler interface的对象，此时会因为json格式不对而报错</li>
<li>然后将这个对象的key依次对应的赋值给你传入的结构体指针，此时只会因为对应key类型不一致而报错<br>举个例子<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</div><div class="line">  Name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</div><div class="line">  Sex <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</div><div class="line">  Name <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 由A对象Marshal的结果可以被Unmarshal进B的对象，只是B.Sex为初始化的空字符串！</span></div><div class="line"><span class="comment">// 而由A对象Marshal的结果不可以被Unmarshal进C的对象，因为Name的类型在两个结构体中不一致！</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="struct-tag-中设置-json-quot-quot-表示忽略该字段。另外只有大写的字段才可以被-Marshal-和-Unmarshal"><a href="#struct-tag-中设置-json-quot-quot-表示忽略该字段。另外只有大写的字段才可以被-Marshal-和-Unmarshal" class="headerlink" title="struct tag 中设置 json:&quot;-&quot; 表示忽略该字段。另外只有大写的字段才可以被 Marshal 和 Unmarshal"></a>struct tag 中设置 <code>json:&quot;-&quot;</code> 表示忽略该字段。另外只有大写的字段才可以被 Marshal 和 Unmarshal</h1><h1 id="json-Unmarshal必须传入对象的地址"><a href="#json-Unmarshal必须传入对象的地址" class="headerlink" title="json.Unmarshal必须传入对象的地址"></a>json.Unmarshal必须传入对象的地址</h1><p>因为这个函数的形参是interface，所以内部有一个reflect.ValueOf的操作返回一个真实类型的<strong>新对象</strong>。</p>
<h1 id="注意strings-Split-“”-“-”-会形成长度为1的切片。第0个位置为一个空字符。"><a href="#注意strings-Split-“”-“-”-会形成长度为1的切片。第0个位置为一个空字符。" class="headerlink" title="注意strings.Split(“”, “,”)会形成长度为1的切片。第0个位置为一个空字符。"></a>注意strings.Split(“”, “,”)会形成长度为1的切片。第0个位置为一个空字符。</h1><p>然后再append一个“s”进入该切片，调用strings.Join(a, “,”)会返回“,s”这样的字符串！</p>
<h1 id="chan-int-和-chan-lt-int-和-lt-chan-int-作为参数类型的区别"><a href="#chan-int-和-chan-lt-int-和-lt-chan-int-作为参数类型的区别" class="headerlink" title="chan int 和 chan&lt;- int 和 &lt;-chan int 作为参数类型的区别"></a>chan int 和 chan&lt;- int 和 &lt;-chan int 作为参数类型的区别</h1><p>第一个表示对于client可以读写，第二个对于client只写，第三个对于client只读。</p>
<h1 id="全局中-var-a-make-map-int-int-是可以的，不用非要放到-init-中初始化"><a href="#全局中-var-a-make-map-int-int-是可以的，不用非要放到-init-中初始化" class="headerlink" title="全局中 var a = make(map[int]int) 是可以的，不用非要放到 init() 中初始化"></a>全局中 var a = make(map[int]int) 是可以的，不用非要放到 init() 中初始化</h1><h1 id="sync-Once-一般用于惰性初始化"><a href="#sync-Once-一般用于惰性初始化" class="headerlink" title="sync.Once 一般用于惰性初始化"></a>sync.Once 一般用于惰性初始化</h1><p>所谓惰性初始化，即不是放在func init() 中的初始化，而是使用时即时判断是否已经初始化（若没有则现场初始化）</p>
<h1 id="sync-Mutex-sync-RWMutex"><a href="#sync-Mutex-sync-RWMutex" class="headerlink" title="sync.Mutex sync.RWMutex"></a>sync.Mutex sync.RWMutex</h1><p>RWMutex: 多读单写锁，调用了RLock和RUnlock方法来获取和释放一个读取或者共享锁。调用mu.Lock和mu.Unlock方法来获取和释放一个写或互斥锁。(写的时候不能读)</p>
<h1 id="go-get-github-com-xxx-…-表示下载并安装xxx下所有库（即子库）"><a href="#go-get-github-com-xxx-…-表示下载并安装xxx下所有库（即子库）" class="headerlink" title="go get github.com/xxx/… 表示下载并安装xxx下所有库（即子库）"></a>go get github.com/xxx/… 表示下载并安装xxx下所有库（即子库）</h1><p>同理 govendor add github.com/xxx/… 可以移入所有xxx的子库，建议这样操作  </p>
<h1 id="关于嵌套-vendor-，你想知道的"><a href="#关于嵌套-vendor-，你想知道的" class="headerlink" title="关于嵌套 vendor ，你想知道的"></a>关于嵌套 vendor ，你想知道的</h1><p>首先总结下 vendor ：   </p>
<ul>
<li>vendor是一个特殊的目录，在应用的源码目录下，go doc工具会忽略它。</li>
<li>vendor机制支持嵌套vendor，vendor中的第三方包中也可以包含vendor目录。</li>
<li>若不同层次的vendor下存在相同的package，编译查找路径优先搜索当前pakcage下的vendor是否存在，若没有再向parent pacakge下的vendor搜索（x/y/z作为parentpath输入，搜索路径：x/y/z/vendor/path-&gt;x/y/vendor/path-&gt;x/vendor/path-&gt;vendor/path)</li>
<li>在使用时不用理会vendor这个路径的存在，该怎么import包就怎么import，不要出现import “d/vendor/p”的情况。vendor是由go tool隐式处理的。</li>
<li>不会校验vendor中package的import path是否与canonical import路径是否一致了。<br>vendor机制看似像node.js的node_modules，支持嵌套vendor，若一个工程中在着两个版本的相的包，可以放在不同的层次的vendor下：    </li>
<li>优点：可能解决不同的版本依赖冲突问题，不同的层次的vendor存放在不同的vendor。</li>
<li>缺点：由于go的package是以路径组织的，在编译时，不同层次的vendor中相同的包会编译两次，链接两份，程序文件变大，运行期是执行不同的代码逻辑。会导致一些问题，如果在package init中全局初始化，可能重复初化出问题，也可能初化为不同的变量（内存中不同），无法共享获取。像之前我们遇到gprc类似的问题就是不同层次的相同package重复init导致的，见社区反馈 。</li>
</ul>
<p>所以Russ Cox期望大家良好设计工程布局，作为lib的包 不携带vendor更佳 ，一个project内的所有vendor都集中在顶层vendor里面。Go的包依赖问题依旧困扰着开发人员，嵌套vendor可以一定程度解决多版本的依赖冲突问题，但也引入多份编译导致的问题。目前社区也在一直讨论如何更好的解决，将进入下一个改进周期。</p>
<blockquote>
<p>使用 godep 以自动地将第三方库中的 vendor 内容移动到顶层 vendor 下，同时处理冲突问题。（称为<strong>flattern</strong>）<br>或使用 govendor add +e 会将所有缺失的外部引用添加进 vendor，效果是一样的</p>
</blockquote>
<h1 id="由errors-New或fmt-Errorf返回的错误变量，它们实现了error-interface"><a href="#由errors-New或fmt-Errorf返回的错误变量，它们实现了error-interface" class="headerlink" title="由errors.New或fmt.Errorf返回的错误变量，它们实现了error interface"></a>由errors.New或fmt.Errorf返回的错误变量，它们实现了error interface</h1><h1 id="govendor-使用方法"><a href="#govendor-使用方法" class="headerlink" title="govendor 使用方法"></a>govendor 使用方法</h1><ol>
<li>govendor init</li>
<li>手动添加需要的包：govendor add github.com/xxx/… 或 govendor add github.com/xxx/yyy</li>
<li><p>或者如果项目中已经有可build的代码，可以自动添加依赖： govendor add +e </p>
<p><code>govendor list</code> 可以查看当前项目下，所有依赖包的状态，其中：</p>
</li>
</ol>
<ul>
<li>+local    (l) packages in your project</li>
<li>+external (e) referenced packages in GOPATH but not in current project</li>
<li>+vendor   (v) packages in the vendor folder</li>
<li><p>+std      (s) packages in the standard library</p>
</li>
<li><p>+excluded (x) external packages explicitly excluded from vendoring</p>
</li>
<li>+unused   (u) packages in the vendor folder, but unused</li>
<li><p>+missing  (m) referenced packages but not found</p>
</li>
<li><p>+program  (p) package is a main package</p>
</li>
<li><p>+outside  +external +missing</p>
</li>
<li>+all      +all packages</li>
</ul>
<p>对应，可以在添加依赖时 <code>govendor add +e</code> 或者在更新时 <code>govendor update +e</code></p>
<h1 id="golang-中的编码-UTF8"><a href="#golang-中的编码-UTF8" class="headerlink" title="golang 中的编码 UTF8"></a>golang 中的编码 UTF8</h1><p>var str string = “界”<br>fmt.Println(str[0],str[1],str[2])<br>输出的是231 149 140     </p>
<p>golang源码必须是UTF-8编码，所以这就是’界’用UTF-8编码后的3个byte。string用下标访问时，是当作[]byte来处理的，所以会访问到每个byte。如果需要按每个字符访问，要转换成[]rune，[]rune(“界”)[0]就是’界’，这是rune类型，表示一个unicode codepoint。用for range遍历string，也是按[]rune来处理。总之是介于[]byte和[]rune之间的一个类型。如果一个string不是来自源码而是文件或者网络等等，就不能保证是UTF-8编码的。如果不是，就要先转换成UTF-8，才能转换成[]rune。官方提供了package。<br>string 就是一个 readonly 的 []byte，str[0], str[1] 分别是第一个字节和第二个字节。string 里面可以放任何数据。如果你用来放文本，可以用任何编码。Go 编译器假设且只接受 UTF-8 编码的文件，也就是你的 .go 文件必须是 UTF-8 编码的。所以，你的代码里面的 “界” 在 Go 编译器看来，就是三个字节的一个字符串，这个就是 str 的初值，你打印的三个 byte 的值就是“界”字的 UTF-8 编码。   </p>
<blockquote>
<p> 也就是说 string 并没有编码成 utf8，只是按字节放入数组而已！ </p>
</blockquote>
<h1 id="golang-版本选择"><a href="#golang-版本选择" class="headerlink" title="golang 版本选择"></a>golang 版本选择</h1><p>go 1.9 会有 pie 问题<br><strong>go 1.8.3 不错，暂时没有问题</strong><br>go 1.10 编译 fabric-ca 时会有指针问题   </p>
<h1 id="build-main"><a href="#build-main" class="headerlink" title="build main"></a>build main</h1><p>main 函数只能定义在 main package 中。注意：可以在 main package 下多个文件中定义多个 main 函数，然后通过 go run xx.go 的方式选择入口 main 函数。但其无法通过编译，会报 redeclare 错误。<br>如果非要定义多个 main 函数的话，可以通过注释的方式（// +build ignore）注明该文件不参与编译，只是作为 go run 的一个可以选择的入口。  // +build 就是 build tag<br><a href="https://golang.org/pkg/go/build/" target="_blank" rel="external">go build 相关</a></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><a href="http://hackthology.com/golangzhong-de-mian-xiang-dui-xiang-ji-cheng.html" target="_blank" rel="external">链接</a><br>匿名嵌入： 1. 嵌入 interface  2. 嵌入 struct  3. 嵌入 *struct<br>匿名嵌入的好处是，嵌入对象的方法和数据直接被被嵌入对象拥有。  </p>
<h1 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h1><p>如果嵌入的是 *struct，需要注意不能直接赋值其中的属性，会报nil指针<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Foo1 <span class="keyword">struct</span> &#123;</div><div class="line">	A <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Goo2 <span class="keyword">struct</span> &#123;</div><div class="line">	*Foo1</div><div class="line">	B <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	g := &amp;Goo2&#123;&#125;</div><div class="line">	g.A = <span class="string">"11"</span> <span class="comment">// 错误，因为此时 g 中的 Foo1 对象为 nil，原理上其实是将 “11” 赋值给 g 中的 Foo1 这个指针上的属性。如果 Foo1 不是指针，则没有这个问题！ </span></div><div class="line">	g.B = <span class="string">"22"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="golang-的不同进制输出"><a href="#golang-的不同进制输出" class="headerlink" title="golang 的不同进制输出"></a>golang 的不同进制输出</h1><p>fmt.Printf(“%b”,34)   二进制<br>fmt.Printf(“%o”,34)   八进制<br>fmt.Printf(“%d”,34)   十进制<br>fmt.Printf(“%x”,34)   十六进制</p>
<h1 id="就是取反"><a href="#就是取反" class="headerlink" title="^ 就是取反"></a>^ 就是取反</h1><h1 id="切片类型的一个坑"><a href="#切片类型的一个坑" class="headerlink" title="切片类型的一个坑"></a>切片类型的一个坑</h1><p><strong>接口的切片</strong> 和 <strong>其实现的切片</strong> 不是一个类型，函数入参不能直接传入！！   </p>
<h1 id="开发一个-golang-应用会用的一些常见库"><a href="#开发一个-golang-应用会用的一些常见库" class="headerlink" title="开发一个 golang 应用会用的一些常见库"></a>开发一个 golang 应用会用的一些常见库</h1><ul>
<li>github.com/urfave/cli </li>
<li>os/exec （执行系统 cmd，比较上层的库）</li>
<li>net/http </li>
<li>Gorilla 是一个 web toolkit 仓库，有很多不错的项目</li>
<li>gorilla/mux 一个 URL 路由，而原生 http 中的 ServeMux 不支持正则，路由参数等特性</li>
<li>gorilla/websocket </li>
<li>os/signal</li>
<li>os/user</li>
<li>syscall 配合 os/signal 库，syscall 中有表示各种信号的变量</li>
<li>io.MultiWriter 可以创建一个总 writer，支持同时向多个内部的 writer 写入</li>
<li>natefinch/lumberjack 一个 rolling log</li>
<li>fsnotify/fsnotify 监听文件变化事件</li>
<li>bytes，可以生成 buffer，但是非阻塞的</li>
<li>bufio 带缓冲的 io，加速读写操作</li>
<li>io.Pipe() 可以产生阻塞的读写流</li>
<li>uber-go/zap 是一个高性能的 log 库，非常推荐 </li>
</ul>
<h1 id="golang-实战技巧"><a href="#golang-实战技巧" class="headerlink" title="golang 实战技巧"></a>golang 实战技巧</h1><ol>
<li><p>设置某个字符串为 Error 类型，可以返回明确的错误信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> SomeError <span class="keyword">string</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e SomeError)</span> <span class="title">Error</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span> <span class="string">"SomeError: "</span> + <span class="keyword">string</span>(e)&#125;</div><div class="line"><span class="comment">// 用法：</span></div><div class="line">err := SomeError(<span class="string">"some error info"</span>)  <span class="comment">// 返回 SomeError: some error info</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>XxxAdapter</code> 用于解耦，一般是个接口，被其他对象调用，以具体实现底层或上层的复杂逻辑</p>
</li>
</ol>
<h1 id="如何安全的写入-channel"><a href="#如何安全的写入-channel" class="headerlink" title="如何安全的写入 channel"></a>如何安全的写入 channel</h1><p>因为往 closed chananel 写入数据会 panic，一般我们会用一个 stopChan 来做通知。原则上 stopChan 是用于通知发送端结束发送（这样最容易实现，且不会 panic）。 但如果我们无法控制发送端（使用别人的库等情况）。 我们必须在接收端正确的处理（虽然也不完美），如下所示：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// do runs fn in the ServeHTTP goroutine.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ht *serverHandlerTransport)</span> <span class="title">do</span><span class="params">(fn <span class="keyword">func</span>()</span>) <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// Avoid a panic writing to closed channel. Imperfect but maybe good enough.</span></div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> &lt;-ht.closedCh:</div><div class="line">		<span class="keyword">return</span> ErrConnClosing</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> ht.writes &lt;- fn:  <span class="comment">// 因为我们可能无法控制 do 这个函数被发送端不停的调用，所以用双层 select</span></div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		<span class="keyword">case</span> &lt;-ht.closedCh:</div><div class="line">			<span class="keyword">return</span> ErrConnClosing</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但要注意不要同时 close(closedCh) 和 close(ht.writes)，因为这样操作还是会有问题（因为上述的方法只能解决调用do函数的时候 closedCh 已经 closed 的情况下不会 panic。但在 default 阻塞中，同时关闭 ht.writes 和 closedCh 还是有几率 panic ）。而是在 case &lt;- closedCh 中 close(ht.writes)</p>
<h1 id="iota-是重新计数的"><a href="#iota-是重新计数的" class="headerlink" title="iota 是重新计数的"></a>iota 是重新计数的</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> state <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	aa <span class="keyword">int</span> = <span class="literal">iota</span>   <span class="comment">// 0</span></div><div class="line">	bb				<span class="comment">// 1</span></div><div class="line">	cc				<span class="comment">// 2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	dd state = <span class="literal">iota</span>  <span class="comment">// 0</span></div><div class="line">	ee				 <span class="comment">// 1</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h1 id="encoding-gob-即Go-binary-的缩写-是-golang-自带的编码-解码器（可用于-rpc）"><a href="#encoding-gob-即Go-binary-的缩写-是-golang-自带的编码-解码器（可用于-rpc）" class="headerlink" title="encoding/gob (即Go binary 的缩写)是 golang 自带的编码/解码器（可用于 rpc）"></a>encoding/gob (即Go binary 的缩写)是 golang 自带的编码/解码器（可用于 rpc）</h1><p>注意：fileds 必须大写，即 exported<br>除了使用 json.Unmarshal，我们可以用 gob 这个库，官方说效率高于 json/xml<br><code>gob.NewEncoder</code> <code>gob.NewDecoder</code> 配合 bytes.NewBuffer</p>
<p>First, and most obvious, it had to be very easy to use. First, because Go has reflection, there is no need for a separate interface definition language or “protocol compiler”. The data structure itself is all the package should need to figure out how to encode and decode it. On the other hand, this approach means that gobs will never work as well with other languages, but that’s OK: gobs are unashamedly Go-centric.</p>
<h1 id="time-Tick-time-Duration-是对-time-NewTicker-time-Duration-的-wrapper，方便提供通道"><a href="#time-Tick-time-Duration-是对-time-NewTicker-time-Duration-的-wrapper，方便提供通道" class="headerlink" title="time.Tick(time.Duration) 是对 time.NewTicker(time.Duration) 的 wrapper，方便提供通道"></a>time.Tick(time.Duration) 是对 time.NewTicker(time.Duration) 的 wrapper，方便提供通道</h1><h1 id="RoundTripper"><a href="#RoundTripper" class="headerlink" title="RoundTripper"></a>RoundTripper</h1><p>go http 发送请求的几个方法：    </p>
<ol>
<li>http.Get()   简化方法</li>
<li>http.Post()  简化方法</li>
<li>client := &amp;http.Client{/<em> 可以加很多定制 </em>/}   req, err := http.NewRequest()   client.Do(req)</li>
</ol>
<p>不管是用上述哪个方法，其实内部都会调用 <code>http.Client</code> 这个类型的对象的 <code>Do(req)</code> 方法。其中第一个和第二个方法中，会调用 <code>DefaultClient</code> 其实就是 <code>&amp;http.Client{}</code>。        </p>
<p>而在 <code>http.Client</code> 中有个属性为接口 <code>RoundTripper</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RoundTripper is an interface representing the ability to execute a</span></div><div class="line"><span class="comment">// single HTTP transaction, obtaining the Response for a given Request.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// A RoundTripper must be safe for concurrent use by multiple</span></div><div class="line"><span class="comment">// goroutines.</span></div><div class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;</div><div class="line">	RoundTrip(*Request) (*Response, error)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其默认的实现类为 <code>http.Transport</code>。如果 <code>http.Client</code> 中的 <code>RoundTripper</code> 没有在初始化时配置，默认使用 <code>DefaultTransport</code>，是 <code>http.Transport</code> 的全局对象。<br>net/http 实际的请求都是通过该接口的 <code>RoundTrip</code> 方法         </p>
<p>实现类 <code>http.Transport</code> 有很多优化的地方，比如会保持连接池，实现连接复用<br><a href="https://segmentfault.com/a/1190000003735562" target="_blank" rel="external">RoundTripper 学习</a></p>
<h1 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h1><p>如果 main 包内有不止一个文件，需要在 go run 后面加上所有文件，例如 go run main.go file1.go  或者直接 go run *.go </p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#select-case"><span class="toc-number">1.</span> <span class="toc-text">select case</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#channel"><span class="toc-number">2.</span> <span class="toc-text">channel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#channel-操作要小心"><span class="toc-number">3.</span> <span class="toc-text">channel 操作要小心</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可以使用-reflection-DeepEqual-x-y-interface-bool-来判断两个元素是否相等"><span class="toc-number">4.</span> <span class="toc-text">可以使用 reflection.DeepEqual(x, y interface{}) bool 来判断两个元素是否相等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#byte-的比较"><span class="toc-number">5.</span> <span class="toc-text">[]byte 的比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#带缓冲的channel"><span class="toc-number">6.</span> <span class="toc-text">带缓冲的channel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#千万不要在forloop-中的select中写break"><span class="toc-number">7.</span> <span class="toc-text">千万不要在forloop 中的select中写break</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#json-Unmarshal-原理和常见问题"><span class="toc-number">8.</span> <span class="toc-text">json.Unmarshal 原理和常见问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#struct-tag-中设置-json-quot-quot-表示忽略该字段。另外只有大写的字段才可以被-Marshal-和-Unmarshal"><span class="toc-number">9.</span> <span class="toc-text">struct tag 中设置 json:"-" 表示忽略该字段。另外只有大写的字段才可以被 Marshal 和 Unmarshal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#json-Unmarshal必须传入对象的地址"><span class="toc-number">10.</span> <span class="toc-text">json.Unmarshal必须传入对象的地址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注意strings-Split-“”-“-”-会形成长度为1的切片。第0个位置为一个空字符。"><span class="toc-number">11.</span> <span class="toc-text">注意strings.Split(“”, “,”)会形成长度为1的切片。第0个位置为一个空字符。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chan-int-和-chan-lt-int-和-lt-chan-int-作为参数类型的区别"><span class="toc-number">12.</span> <span class="toc-text">chan int 和 chan<- int 和 <-chan int 作为参数类型的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#全局中-var-a-make-map-int-int-是可以的，不用非要放到-init-中初始化"><span class="toc-number">13.</span> <span class="toc-text">全局中 var a = make(map[int]int) 是可以的，不用非要放到 init() 中初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sync-Once-一般用于惰性初始化"><span class="toc-number">14.</span> <span class="toc-text">sync.Once 一般用于惰性初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sync-Mutex-sync-RWMutex"><span class="toc-number">15.</span> <span class="toc-text">sync.Mutex sync.RWMutex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go-get-github-com-xxx-…-表示下载并安装xxx下所有库（即子库）"><span class="toc-number">16.</span> <span class="toc-text">go get github.com/xxx/… 表示下载并安装xxx下所有库（即子库）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关于嵌套-vendor-，你想知道的"><span class="toc-number">17.</span> <span class="toc-text">关于嵌套 vendor ，你想知道的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#由errors-New或fmt-Errorf返回的错误变量，它们实现了error-interface"><span class="toc-number">18.</span> <span class="toc-text">由errors.New或fmt.Errorf返回的错误变量，它们实现了error interface</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#govendor-使用方法"><span class="toc-number">19.</span> <span class="toc-text">govendor 使用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang-中的编码-UTF8"><span class="toc-number">20.</span> <span class="toc-text">golang 中的编码 UTF8</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang-版本选择"><span class="toc-number">21.</span> <span class="toc-text">golang 版本选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#build-main"><span class="toc-number">22.</span> <span class="toc-text">build main</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#继承"><span class="toc-number">23.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#嵌入"><span class="toc-number">24.</span> <span class="toc-text">嵌入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang-的不同进制输出"><span class="toc-number">25.</span> <span class="toc-text">golang 的不同进制输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#就是取反"><span class="toc-number">26.</span> <span class="toc-text">^ 就是取反</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#切片类型的一个坑"><span class="toc-number">27.</span> <span class="toc-text">切片类型的一个坑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开发一个-golang-应用会用的一些常见库"><span class="toc-number">28.</span> <span class="toc-text">开发一个 golang 应用会用的一些常见库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#golang-实战技巧"><span class="toc-number">29.</span> <span class="toc-text">golang 实战技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何安全的写入-channel"><span class="toc-number">30.</span> <span class="toc-text">如何安全的写入 channel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iota-是重新计数的"><span class="toc-number">31.</span> <span class="toc-text">iota 是重新计数的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#encoding-gob-即Go-binary-的缩写-是-golang-自带的编码-解码器（可用于-rpc）"><span class="toc-number">32.</span> <span class="toc-text">encoding/gob (即Go binary 的缩写)是 golang 自带的编码/解码器（可用于 rpc）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#time-Tick-time-Duration-是对-time-NewTicker-time-Duration-的-wrapper，方便提供通道"><span class="toc-number">33.</span> <span class="toc-text">time.Tick(time.Duration) 是对 time.NewTicker(time.Duration) 的 wrapper，方便提供通道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RoundTripper"><span class="toc-number">34.</span> <span class="toc-text">RoundTripper</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go-run"><span class="toc-number">35.</span> <span class="toc-text">go run</span></a></li></ol>
    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 Landleany
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


